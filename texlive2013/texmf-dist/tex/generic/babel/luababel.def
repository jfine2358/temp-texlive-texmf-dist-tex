%%
%% This is file `luababel.def',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% bbunicode.dtx  (with options: `luatex')
%% This is a generated file.
%% 
%% Copyright 2012-2013 Javier Bezos and Johannes L. Braams.
%% Copyright 1989-2008 Johannes L. Braams and any individual authors
%% listed elsewhere in this file.  All rights reserved.
%% 
%% This file was generated from file(s) of the Babel system.
%% ---------------------------------------------------------
%% 
%% It may be distributed and/or modified under the
%% conditions of the LaTeX Project Public License, either version 1.3
%% of this license or (at your option) any later version.
%% The latest version of this license is in
%%   http://www.latex-project.org/lppl.txt
%% and version 1.3 or later is part of all distributions of LaTeX
%% version 2003/12/01 or later.
%% 
%% This work has the LPPL maintenance status "maintained".
%% 
%% The Current Maintainer of this work is Javier Bezos.
%% 
%% This file may only be distributed together with a copy of the Babel
%% system. You may however distribute the Babel system without
%% such generated files.
%% 
%% The list of all files belonging to the Babel distribution is
%% given in the file `manifest.bbl'. See also `legal.bbl for additional
%% information.
%% 
%% The list of derived (unpacked) files belonging to the distribution
%% and covered by LPPL is defined by the unpacking scripts (with
%% extension .ins) which are part of the distribution.
%% File `bbunicode.dtx'
%% Babel package for LaTeX version 2e
%% Copyright (C) 2103
%%           by Javier Bezos
\directlua{%
  require("luatex-hyphen")
  Babel = {}
  function Babel.bytes(line)
    return line:gsub("(.)",
      function (chr) return unicode.utf8.char(string.byte(chr)) end)
  end
  function Babel.begin_process_input()
    if luatexbase and luatexbase.add_to_callback then
      luatexbase.add_to_callback('process_input_buffer',Babel.bytes,'Babel.bytes')
    else
      Babel.callback = callback.find('process_input_buffer')
      callback.register('process_input_buffer',Babel.bytes)
    end
  end
  function Babel.end_process_input ()
    if luatexbase and luatexbase.remove_from_callback then
      luatexbase.remove_from_callback('process_input_buffer','Babel.bytes')
    else
      callback.register('process_input_buffer',Babel.callback)
    end
  end
}
\def\BabelStringsDefault{unicode}
\let\luabbl@stop\relax
\AddBabelHook{luatex}{encodedcommands}{%
  \def\bbl@tempa{utf8}\def\bbl@tempb{#1}%
  \ifx\bbl@tempa\bbl@tempb\else
    \directlua{Babel.begin_process_input()}%
    \def\luabbl@stop{%
      \directlua{Babel.end_process_input()}}%
  \fi}%
\AddBabelHook{luatex}{stopcommands}{%
  \luabbl@stop
  \let\luabbl@stop\relax}
\AddBabelHook{luatex}{patterns}{%
  \ifx\directlua\relax\else
    \ifcsname lu@texhyphen@loaded@\the\language\endcsname \else
      \global\@namedef{lu@texhyphen@loaded@\the\language}{}%
      \directlua{
        luatexhyphen.loadlanguage('\luatexluaescapestring{\string#1}',
          '\the\language')}%
    \fi
  \fi}
\AddBabelHook{luatex}{adddialect}{%
  \ifx\directlua\relax\else
    \directlua{
      luatexhyphen.adddialect('\luatexluaescapestring{\string#1}',
        '\luatexluaescapestring{\string#2}')
    }%
  \fi}
\AddBabelHook{luatex}{everylanguage}{%
  \directlua{
    processnow = (tex.language == 0) or
      (luatexhyphen.lookupname('\luatexluaescapestring{\string#1}') == nil)}%
  \ifnum0=\directlua{tex.sprint(processnow and "0" or "1")}\relax
    \global\@namedef{lu@texhyphen@loaded@\the\language}{}%
  \fi}
\AddBabelHook{luatex}{loadpatterns}{%
  \ifnum0=\directlua{tex.sprint(processnow and "0" or "1")}\relax
    \input #1\relax
  \fi}
\AddBabelHook{luatex}{loadexceptions}{%
  \ifnum0=\directlua{tex.sprint(processnow and "0" or "1")}\relax
    \input #1\relax
  \fi
  \directlua{processnow = nil}}
\endinput
%%
%% End of file `luababel.def'.
