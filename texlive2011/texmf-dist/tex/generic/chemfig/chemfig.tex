%  __________________________________________________________________
% |                                                                  |
% |                                                                  |
% |                           chemfig v0.4b                          |
% |                                                                  |
% |                          April 24, 2011                          |
% |                                                                  |
% |__________________________________________________________________|
%
% This is chemfig.tex, the code of the "chemfig" package.
%
% Maintainer: Christian Tellechea
% E-mail    : unbonpetit@gmail.com
%             Comments, bug reports and suggestions are welcome.
% Licence   : Released under the LaTeX Project Public License v1.3c or
%             later, see http://www.latex-project.org/lppl.txt
% Copyright : Christian Tellechea 2010-2011
%
% The "chemfig" package consists of the 8 following files:
%   chemfig.tex (this file)
%   chemfig.sty (the package file for LaTeX)
%   t-chemfig.tex (the package file for conTeXt)
%   README
%   chemfig_doc_en.tex, chemfig_doc_en.pdf (english manual)
%   chemfig_doc_fr.tex, chemfig_doc_fr.pdf (manual in french)
%
% --------------------------------------------------------------------
% This work may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either version 1.3
% of this license or (at your option) any later version.
% The latest version of this license is in
%
% %     http://www.latex-project.org/lppl.txt
%
% and version 1.3 or later is part of all distributions of LaTeX
% version 2005/12/01 or later.
% --------------------------------------------------------------------
% This work has the LPPL maintenance status `maintained'.
%
% The Current Maintainer of this work is Christian Tellechea
% --------------------------------------------------------------------

% Sauvegarde tous les catcodes des caract\`eres sp\'eciaux sauf #
\begingroup
\def\X#1{\catcode\number`#1=\number\catcode`#1\relax}
\expandafter\xdef\csname CF@savedcatcode\endcsname{%
	\X\[\X\]\X\:\X\(\X\)\X\,\X\-\X\=\X\~\X\!\X\?\X\<\X\>\X\;\X\*\X\|\X\@%
}
\endgroup

% Pour la dur\'ee de lecture du package, changer les catcodes :
\catcode`\[12 \catcode`\]12 \catcode`\:12 \catcode`\(12
\catcode`\)12 \catcode`\,12 \catcode`\-12 \catcode`\=12
\catcode`\~12 \catcode`\!12 \catcode`\?12 \catcode`\<12
\catcode`\>12 \catcode`\;12 \catcode`\*12 \catcode`\|12
\catcode`\@11 \catcode`\#6  \catcode`\ 10

\def\CF@def#1{%
	\ifdefined#1%
		\errmessage{Package chemfig Error: the macro \string#1\space is already defined. Please, email the author.}%
	\fi
	\def#1%
}

\CF@def\CF@ver         {0.4b}
\CF@def\CF@date        {2011/04/24}
\CF@def\CF@fr@date     {24 avril 2011}
\CF@def\CF@en@date     {April 24, 2011}
\CF@def\CF@package@name{chemfig}

\expandafter\ifx\csname @latexerr\endcsname\relax% on n'utilise pas LaTeX ?
	\ifdefined\tikzpicture\else
		\def\CF@next@action{\input tikz.tex}%
		\expandafter\CF@next@action
	\fi
	\immediate\write\m@ne{Package: \CF@package@name\space\CF@date\space\space v\CF@ver\space\space Draw molecule with an easy syntax}%
	\long\def\@firstoftwo#1#2{#1}
	\long\def\@secondoftwo#1#2{#2}
	\long\def\@firstofone#1{#1}
	\long\def\@gobble#1{}
	\long\def\@gobbletwo#1#2{}
	\def\@car#1#2\@nil{#1}
	\def\@makeother#1{\catcode`#1=12\relax}
	\long\def\@ifnextchar#1#2#3{%
		\let\reserved@d=#1%
		\def\reserved@a{#2}%
		\def\reserved@b{#3}%
		\futurelet\@let@arg\@ifnch}
	\def\@ifnch{%
		\ifx\@let@arg\@sptoken
			\let\reserved@c\@xifnch
		\else
			\ifx\@let@arg\reserved@d
				\let\reserved@c\reserved@a
			\else
				\let\reserved@c\reserved@b
			\fi
		\fi
		\reserved@c}
	\def\:{\let\@sptoken= } \:
	\def\:{\@xifnch} \expandafter\def\: {\futurelet\@let@arg\@ifnch}
	\def\@ifstar#1{\@ifnextchar *{\@firstoftwo{#1}}}
	\long\def\@testopt#1#2{\@ifnextchar[{#1}{#1[{#2}]}}
	\def\@empty{}
	\def\space{ }
	\CF@def\printatom#1{\ifmmode\rm#1\else$\rm#1$\fi}% \printatom pour TeX et ConTeXt
\else% fin des d\'efinitions LaTeX
	\CF@def\printatom#1{\ensuremath{\mathrm{#1}}}% \printatom pour LaTeX.
\fi

\newcount\CF@cnt@atomingroup
\newcount\CF@cnt@groupnumber
\newcount\CF@cnt@atomnumber
\newcount\CF@cnt@cycle

\newif\ifCF@incycle
\newif\ifCF@cyclearc
\newif\ifCF@definesubmol

\newdimen\CF@dim

\newbox\CF@lewis@box
\newbox\CF@box@boxa
\newbox\CF@box@boxb
\newbox\CF@stuff@box

\newwrite\CF@unused

\CF@def\CF@sanitize@catcode{%
	\@makeother\[\@makeother\]\@makeother\:\@makeother\(\@makeother\)%
	\@makeother\,\@makeother\-\@makeother\=\@makeother\~\@makeother\!%
	\@makeother\?\@makeother\<\@makeother\>\@makeother\;\@makeother\*%
	\@makeother\|\@makeother\#\@makeother\@%
}

\CF@def\CF@node@content{\expandafter\printatom\expandafter{\csname atom@\number\CF@cnt@atomnumber\endcsname\CF@node@strut}}

\CF@def\chemskipalign{%
	\ifx\CF@bond@outcontentsaved\@empty% sauf si un \chemskipalign a \'et\'e fait \`a l'atome pr\'ec\'edent
		\global\let\CF@bond@outcontentsaved\CF@bond@outcontent% sauvegarder l'atome d'o\`u vient la liaison
	\fi
	\let\CF@node@strut\@empty
}

\CF@def\CF@empty@node{{}}

\CF@def\CF@cycle@inraduiscoeff{0.75}% coeff multiplicateur du rayon des arcs dans les cycles

\CF@def\setcrambond#1#2#3{%
	\def\CF@cram@basewidth{#1}%
	\ifx\@empty#2\@empty\def\CF@cram@dashlength{1pt}\else\def\CF@cram@dashlength{#2}\fi
	\ifx\@empty#3\@empty\def\CF@cram@dashsep{2pt}\else\def\CF@cram@dashsep{#3}\fi}
\setcrambond{}{}{}

\CF@def\setatomsep{\def\CF@atom@sep}% espacement des atomes li\'es
\setatomsep{}

\CF@def\setbondoffset{\def\CF@bond@offset}% offset des liaisons
\setbondoffset{2pt}

\CF@def\setdoublesep{\def\CF@double@sep}
\setdoublesep{2pt}

\CF@def\definesubmol{\CF@definesubmoltrue\CF@def@submol}
\CF@def\redefinesubmol{\CF@definesubmolfalse\CF@def@submol}

\CF@def\CF@def@submol#1{%
	\begingroup
		\def\CF@tmp@str{#1}%
		\catcode`[\@ne\catcode`]\tw@
		\futurelet\CF@toks@a\CF@test@nxttok
}

\CF@def\CF@test@nxttok{%
		\if[\noexpand\CF@toks@a
			\expandafter\expandafter\expandafter\CF@grab@optalias\expandafter\expandafter\expandafter{\expandafter\CF@tmp@str\expandafter}%
		\else
			\CF@swap@fi
			\expandafter\endgroup
			\expandafter\CF@def@submol@i\expandafter{\CF@tmp@str}{}%
		\fi
}

\CF@def\CF@grab@optalias#1#2{%
	\endgroup
	\begingroup
	\everyeof{\@nil}\endlinechar\m@ne
	\expandafter\assign@tonil\expandafter\CF@tmp@str\scantokens{#2}%
	\CF@expand@second{\endgroup\CF@def@submol@i{#1}}\CF@tmp@str
}

\CF@def\CF@def@submol@i#1#2#3{% #1 nom, #2 = code si liaison arrive de droite , #3 = code si liaison arrive de gauche
	\ifcat\relax\expandafter\noexpand\@car#1\@nil% si #1 est une s\'equence de contr\^ole
		\expandafter\ifdefined\@car#1\@nil
			\ifCF@definesubmol
				\immediate\write\CF@unused{Package \CF@package@name\space Warning: the macro \expandafter\string\@car#1\@nil\space is already defined, the previous definition is lost on input line \the\inputlineno.}%
			\fi
		\fi
		\ifx\@empty#2\@empty
			\expandafter\def\@car#1\@nil{\@empty#3}%
		\else
			\expandafter\def\@car#1\@nil{%
				\romannumeral
				\ifdim\CF@current@angle pt>90pt
					\ifdim\CF@current@angle pt<270pt
						\expandafter\expandafter\expandafter\@firstoftwo
					\else
						\expandafter\expandafter\expandafter\@secondoftwo
					\fi
				\else
					\expandafter\@secondoftwo
				\fi
				{\z@#2}{\z@#3}}%
		\fi
	\else
		\ifcsname CF@@#1\endcsname
			\ifCF@definesubmol
				\immediate\write\CF@unused{Package \CF@package@name\space Warning:the submol "#1" is already defined, the previous definition is lost on input line \the\inputlineno.}%
			\fi
		\fi
		\ifx\@empty#2\@empty
			\expandafter\def\csname CF@@#1\endcsname{\@empty#3}% "\@empty" car tout Ã§a sera 1-d\'evelopp\'e lorsque rencontr\'ee
		\else
			\expandafter\def\csname CF@@#1\endcsname{%
				\romannumeral% donnera le d\'eveloppement souhait\'e en 1 coup
				\ifdim\CF@current@angle pt>90pt
					\ifdim\CF@current@angle pt<270pt
						\expandafter\expandafter\expandafter\@firstoftwo
					\else
						\expandafter\expandafter\expandafter\@secondoftwo
					\fi
				\else
					\expandafter\@secondoftwo
				\fi
				{\z@#2}{\z@#3}}%
		\fi
	\fi
}

\CF@def\CF@if@integer#1{%
	\begingroup
		\afterassignment\CF@after@integer
		\CF@cnt@cycle0#1\relax
}

\CF@def\CF@after@integer#1\relax{%
	\endgroup
	\ifx\@empty#1\@empty\expandafter\@firstoftwo\else\expandafter\@secondoftwo\fi
}

\CF@def\CF@swap@fi#1\fi{\fi#1}

\CF@def\CF@gobble@tonil#1\@nil{}

\CF@def\CF@expafterarg@ntimes#1#2#3{%
	\CF@expafterarg@ntimes@i{#1}{#3}%
	\expandafter\CF@swap@arg\expandafter{\CF@tmp@str}{#2}%
}

\CF@def\CF@expafterarg@ntimes@i#1#2{%
	\ifnum#1=\z@
		\def\CF@tmp@str{#2}%
	\else
		\CF@swap@fi
		\expandafter\CF@expafterarg@ntimes@i\expandafter{\number\numexpr#1-1\expandafter}\expandafter{#2}%
	\fi
}

\CF@def\CF@swap@arg#1#2{#2{#1}}

\CF@def\CF@expand@second#1#2{\expandafter\CF@swap@arg\expandafter{#2}{#1}}

\CF@def\CF@swap@char#1#2{#2#1}

\CF@def\CF@expand@afterfirst#1#2{\expandafter\CF@swap@char\expandafter{#2}{#1}}

\CF@def\CF@edef@second#1#2{%
	\edef\CF@tmp@str{#2}%
	\expandafter\CF@swap@char\expandafter{\CF@tmp@str}{#1}%
}

\CF@def\CF@add@tocs#1#2{\expandafter\def\expandafter#1\expandafter{#1#2}}

\CF@def\CF@expadd@tocs#1#2{\expandafter\CF@add@tocs\expandafter#1\expandafter{#2}}

\CF@def\CF@edefadd@tocs#1#2{%
	\edef\CF@tmp@str{#2}%
	\expandafter\CF@add@tocs\expandafter#1\expandafter{\CF@tmp@str}%
}

\CF@def\CF@if@firsttokmatch#1#2{% est ce que #1 et #2 commencent par les m\^emes tokens ?
	\futurelet\CF@toks@a\CF@gobble@tonil#1\relax\@nil
	\futurelet\CF@toks@b\CF@gobble@tonil#2\relax\@nil
	\ifx\CF@toks@a\CF@toks@b\expandafter\@firstoftwo\else\expandafter\@secondoftwo\fi
}

\CF@def\CF@if@firsttokin#1{% teste si le token qui commence #1 appartient aux tokens mis dans #2
	\futurelet\CF@toks@a\CF@gobble@tonil#1\relax\@nil
	\CF@if@firsttokin@i
}

\CF@def\CF@if@firsttokin@i#1{%
	\ifx\@empty#1\@empty
		\expandafter\@secondoftwo
	\else
		\futurelet\CF@toks@b\CF@gobble@tonil#1\relax\@nil
		\ifx\CF@toks@a\CF@toks@b
			\expandafter\expandafter\expandafter\@firstoftwo
		\else
			\CF@swap@fi\CF@swap@fi
			\expandafter\CF@if@firsttokin@i\expandafter{\@gobble#1}%
		\fi
	\fi
}

\CF@def\CF@if@instr#1#2{%
	\def\CF@if@instr@i##1#2##2\@nil{\ifx\@empty##2\@empty\expandafter\@secondoftwo\else\expandafter\@firstoftwo\fi}%
	\CF@if@instr@i#1\@@nil#2\@nil
}

\CF@def\CF@after@space#1 #2\@nil{#2}

\CF@def\CF@seek@node#1#2#3{% cherche un noeud au d\'ebut de #1 l'assigne dans la sc #2 et met le reste dans #3
	\let#2\@empty
	\def#3{#1}%
	\futurelet\CF@toks@a\CF@gobble@tonil#1\relax\@nil
	\ifx\CF@toks@a\@sptoken\expandafter\@firstoftwo\else\expandafter\@secondoftwo\fi
		{\expandafter\CF@seek@node@i\expandafter{\CF@after@space#1\@nil}#2#3}% ignore l'espace qui commence un groupe d'atome
		{\CF@seek@node@i{#1}#2#3}%
}

\CF@def\CF@seek@node@i#1#2#3{%
	\ifx\@empty#1\@empty
		\let#3\@empty
	\else
		\futurelet\CF@toks@a\CF@gobble@tonil#1\relax\@nil
		\ifx\CF@toks@a\@sptoken\expandafter\@firstoftwo\else\expandafter\@secondoftwo\fi
			{\CF@add@tocs#2{ }%
			\CF@swap@fi\expandafter\CF@seek@node@i\expandafter{\CF@after@space#1\@nil}#2#3%
			}%
			{\ifx\CF@toks@a\bgroup\expandafter\@firstoftwo\else\expandafter\@secondoftwo\fi
				{\CF@expadd@tocs#2{\expandafter{\@car#1\@nil}}%
				\CF@swap@fi\expandafter\CF@seek@node@i\expandafter{\@gobble#1}#2#3%
				}%
				{\CF@if@firsttokin@i{-=(*<>!~}%
					{\def#3{#1}}%
					{\CF@expadd@tocs#2{\@car#1\@nil}%
					\CF@swap@fi\expandafter\CF@seek@node@i\expandafter{\@gobble#1}#2#3%
					}%
				}%
			}%
	\fi
}

% on sait que #1 commence par -,=,~,<,>. On analyse cette liaison
% #2 reÃ§oit le type de liaisons (1 pour -, 2 pour =, 3 pour ~)
\CF@def\CF@bond@findnum#1#2{%
	\futurelet\CF@toks@a\CF@gobble@tonil#1\@nil
	\edef#2{%
		\ifx-\CF@toks@a1%
		\else
			\ifx=\CF@toks@a2%
			\else
				\ifx~\CF@toks@a3%
				\else
					\ifx>\CF@toks@a4%
					\else
						\ifx<\CF@toks@a5%
						\else0% si 0 --> il y a une erreur non dÃ»e \`a l'utilisateur
						\fi
					\fi
				\fi
			\fi
		\fi}%
	\ifnum#2>\thr@@% si c'est une liaison de Cram
		\expandafter\futurelet\expandafter\CF@toks@a\expandafter\CF@gobble@tonil\@gobble#1\@nil% chope le caract\`ere suivant
		\ifx:\CF@toks@a
			\edef#2{\number\numexpr#2+2}% si c 'est un ":", signe du pointill\'e, ajoute 2
		\else
			\ifx|\CF@toks@a
				\edef#2{\number\numexpr#2+4}% si c 'est un "|", signe du triangle \'evid\'e, ajouter 4
			\fi
		\fi
	\fi
}

\CF@def\CF@analyse@bondoffset#1,#2\@nil{%
	\def\CF@start@offset{#1}\def\CF@end@offset{#2}%
}

\expandafter\CF@def\expandafter\CF@grab@bondoffset\string#(#1)#2\@nil{%
	\ifx\@empty#1\@empty
	\else
		\CF@if@instr{#1},%
			{\CF@analyse@bondoffset#1\@nil}%
			{\def\CF@start@offset{#1}}%
	\fi
	\def\CF@remain@afterbond{#2}%
}

\CF@def\CF@analyse@bond#1#2{%
	\CF@bond@findnum{#1}#2%
	\expandafter\def\expandafter\CF@remain@afterbond\expandafter{\@gobble#1}%mange le premier signe de la liaison
	\let\CF@doublebond@type\z@
	\ifnum#2=\tw@% si c'est une double liaison, regarde s'il y a un + ou - derri\`ere
		\expandafter\futurelet\expandafter\CF@toks@a\expandafter\CF@gobble@tonil\@gobble#1\@nil
		\ifx^\CF@toks@a
			\let\CF@doublebond@type\@ne
			\expandafter\def\expandafter\CF@remain@afterbond\expandafter{\@gobbletwo#1}% mange le "^"
		\else
			\ifx_\CF@toks@a
				\let\CF@doublebond@type\tw@
				\expandafter\def\expandafter\CF@remain@afterbond\expandafter{\@gobbletwo#1}% mange le "_"
			\fi
		\fi
	\else
		\ifnum#2>5 % si c'est une laision de Cram pointill\'ee ou triangle \'evid\'e
			\expandafter\def\expandafter\CF@remain@afterbond\expandafter{\@gobbletwo#1}% mange un caract\`ere de plus
		\fi
	\fi
	\expandafter\expandafter\expandafter\CF@if@firsttokmatch\expandafter\expandafter\expandafter{\expandafter\CF@remain@afterbond\expandafter}\string##%
		{\expandafter\CF@grab@bondoffset\CF@remain@afterbond\@nil}%
		\relax
	\expandafter\expandafter\expandafter\CF@if@firsttokmatch\expandafter\expandafter\expandafter{\expandafter\CF@remain@afterbond\expandafter}\string @%
		{\expandafter\CF@grab@movearg\CF@remain@afterbond\@nil}%
		\relax
	\expandafter\CF@if@firsttokmatch\expandafter{\CF@remain@afterbond}[%
		{\expandafter\CF@analyse@optarg\CF@remain@afterbond\@nil\CF@remain@afterbond}%
		{\let\CF@current@stringangle\CF@default@stringangle
		\let\CF@current@length\CF@default@length
		\let\CF@current@fromatom\CF@default@fromatom
		\let\CF@current@toatom\CF@default@toatom
		\let\CF@current@tikz\CF@default@tikz
		\let\CF@movebond@name\@empty
		}%
	\ifCF@incycle
		\pgfmathparse{360/\CF@cycle@num+\CF@initcycle@angle}%
		\edef\CF@current@stringangle{::+\pgfmathresult}%
		\def\CF@initcycle@angle{0}%
		\let\CF@current@length\CF@default@length% et on ignore la longueur de liaison sp\'ecifi\'ee
	\fi
	\expandafter\CF@set@bondangle\expandafter{\CF@current@stringangle}\CF@current@angle
}

\CF@def\CF@set@bondangle#1#2{% le code de la direction est contenu dans #1, en sortie, #2 contient l'angle
	\ifx\@empty#1\@empty%
		\let#2\CF@default@angle
	\else
		\if:\expandafter\noexpand\@car#1\@nil
			\if:\expandafter\expandafter\expandafter\noexpand\expandafter\@car\@gobble#1\@nil
				\pgfmathparse{\CF@previous@angle+\expandafter\@gobble\@gobble#1}%
				\let#2\pgfmathresult
			\else
				\expandafter\def\expandafter#2\expandafter{\@gobble#1}
			\fi% puis normalise l'angle entre 0 et 360
			\ifdim\ifdim#2pt<\z@-\fi#2pt>360pt % si |#2|>360
				\pgfmathparse{#2-360*floor(#2/360)}%
				\ifdim\pgfmathresult pt<\z@\pgfmathparse{\pgfmathresult+360}\fi
				\let#2\pgfmathresult
			\else
				\ifdim#2pt<\z@
					\pgfmathparse{#2+360}%
					\let#2\pgfmathresult
				\fi
			\fi
		\else
			\ifnum#1>7
				\pgfmathparse{#1-floor(#1/8)*8}%
				\ifdim\pgfmathresult pt<\z@\pgfmathparse{\pgfmathresult+8}\fi
				\edef#2{\ifcase\expandafter\CF@int@part\pgfmathresult\@nil0\or45\or90\or135\or180\or225\or270\or315\else-1\fi}% angle =-1 --> erreur
			\else
				\edef#2{\ifcase#1 0\or45\or90\or135\or180\or225\or270\or315\else-1\fi}%
			\fi
		\fi
	\fi
}

\CF@def\CF@int@part#1.#2\@nil{#1 }

\CF@def\CF@analyse@movearg#1,#2\@nil#3{%
	\def#3{#1}\def\CF@movebond@coeff{#2}%
}

% Argument limit\'es l\'egitimes ici car #2 (qui est ce qui suit "@{<nom>}" dans l'argument optionnel) ne DOIT
% pas commencer par une accolade.
\expandafter\CF@def\expandafter\CF@grab@movearg\string @#1#2\@nil{%
	\CF@if@instr{#1},%
		{\CF@analyse@movearg#1\@nil\CF@movebond@name}%
		{\def\CF@movebond@name{#1}\def\CF@movebond@coeff{0.5}}%
	\def\CF@remain@optarg{#2}%
}

\CF@def\CF@testempty@andassign#1#2#3{\ifx\@empty#2\@empty\let#1#3\else\def#1{#2}\fi}

\CF@def\CF@sanitize@lastitem#1,\@empty#2\@nil{#1}

\CF@def\CF@parse@optlist#1,#2,#3,#4,#5\@nil{%
	\CF@testempty@andassign\CF@current@stringangle{#1}\CF@default@stringangle
	\CF@testempty@andassign\CF@current@length{#2}\CF@default@length
	\CF@testempty@andassign\CF@current@fromatom{#3}\CF@default@fromatom
	\CF@testempty@andassign\CF@current@toatom{#4}\CF@default@toatom
	\expandafter\CF@testempty@andassign\expandafter\CF@current@tikz\expandafter{\CF@sanitize@lastitem#5,\@empty\@nil}\CF@default@tikz
}%

\CF@def\CF@analyse@optarg[#1]#2\@nil#3{%
	\ifx\@empty#1\@empty
	\else
		\CF@expand@afterfirst{\CF@if@firsttokmatch{#1}}{\string @}%
			{\CF@grab@movearg#1\@nil}%
			{\let\CF@movebond@name\@empty
			\def\CF@remain@optarg{#1}}%
		\expandafter\CF@parse@optlist\CF@remain@optarg,\@empty,\@empty,\@empty,\@empty\@nil
		\def#3{#2}%
	\fi
}

\CF@def\CF@seek@submol{%
	\expandafter\CF@if@firsttokmatch\expandafter{\CF@remain@molecule}!%
		{\expandafter\expandafter\expandafter\def\expandafter\expandafter\expandafter
			\CF@remain@molecule\expandafter\expandafter\expandafter{\expandafter\@gobble\CF@remain@molecule}% enl\`eve le ``!''
		\ifcat\relax\expandafter\expandafter\expandafter\noexpand\expandafter\@car\CF@remain@molecule\@nil
			\CF@expafterarg@ntimes5{\def\CF@insert@submol}{\expandafter\@car\CF@remain@molecule\@nil}%
		\else
			\CF@expafterarg@ntimes3{\def\CF@insert@submol}{\csname CF@@\expandafter\@car\CF@remain@molecule\@nil\endcsname}%
		\fi
		\expandafter\expandafter\expandafter\def\expandafter\expandafter\expandafter\CF@remain@molecule\expandafter\expandafter\expandafter
			{\csname CF@insert@submol\expandafter\expandafter\expandafter\endcsname\csname @gobble\expandafter\endcsname\CF@remain@molecule}%
		\CF@seek@submol
		}%
		\relax
}

\CF@def\CF@insert@emptygroup#1{% ins\`ere {} au d\'ebut de la sc #1
	\expandafter\def\expandafter#1\expandafter{\expandafter{\expandafter}#1}%
}

\CF@def\CF@make@other#1{%
	\ifx\@empty#1\@empty
	\else
		\expandafter\@makeother\@car#1\@nil
		\CF@swap@fi
		\expandafter\CF@make@other\expandafter{\@gobble#1}%
	\fi
}

\CF@def\chemfig{\@testopt\CF@chemfig@i{}}

\CF@def\CF@chemfig@i[#1]{\@testopt{\CF@chemfig@ii[#1]}{}}

\CF@def\CF@chemfig@ii[#1][#2]{%
	\edef\CF@tmp@str{[remember picture,every node/.style={anchor=base,inner sep=0pt,outer sep=0pt,minimum size=0pt\ifx\@empty#2\@empty\else,#2\fi},baseline\ifx\@empty#1\@empty\else,#1\fi]}%
	\expandafter\tikzpicture\CF@tmp@str
	\begingroup
		\let\CF@hook@list\@empty
		\ifx\CF@atom@sep\@empty\def\CF@atom@sep{3em}\fi
		\ifx\CF@cram@basewidth\@empty\def\CF@cram@basewidth{1.5ex}\fi
		\CF@incyclefalse
		\CF@cnt@groupnumber\z@
		\let\CF@last@action\z@% 0=d\'ebut du dessin 1=trac\'e d'un noeud 2=trac\'e d'une liaison
		\let\CF@start@offset\@empty
		\let\CF@end@offset\@empty
		\let\CF@bond@outcontentsaved\@empty
		\def\CF@cycle@anglecorrection{180/\CF@cycle@num}%
		\def\CF@default@angle{0}%
		\def\CF@default@stringangle{:0}% angle pris par d\'efaut si le champ est vide
		\def\CF@default@length{1}%
		\let\CF@default@fromatom\@empty% numero de l'atome d'o\`u partent les liaisons par d\'efaut
		\let\CF@default@toatom\@empty% num\'ero de l'atome o\`u arrivent les laisons par d\'efaut
		\let\CF@default@tikz\@empty
		\everyeof{\@nil}\endlinechar\m@ne
		\CF@sanitize@catcode
		\CF@chemfig@iii
}

\CF@def\CF@chemfig@iii#1{%
	\expandafter\assign@tonil\expandafter\CF@remain@molecule\scantokens{#1}%
	\expandafter\CF@chemfig@iv\expandafter{\CF@remain@molecule}%
	\endtikzpicture
	\let\CF@split@state\z@
}

\CF@def\CF@chemfig@iv#1{% #1 est le code de la mol\'ecule
	\ifnum\CF@last@action=\thr@@
		\ifCF@incycle
			\def\CF@default@angle{0}%
		\else
			\ifnum\CF@cnt@cycle=\z@% si c'est le d\'ebut d'un cycle
				\pgfmathparse{\CF@previous@angle+180+\CF@cycle@anglecorrection}% on met la liaison \`a +180Â° + correction
			\else
				\pgfmathparse{\CF@previous@angle-90+180/\CF@cycle@num}% sinon \`a la bissectrice du sommet du cycle
			\fi
			\let\CF@default@angle\pgfmathresult
		\fi
		\let\CF@default@stringangle\@empty
	\fi
	\let\CF@current@angle\CF@default@angle
	\def\CF@remain@molecule{#1}%
	\CF@seek@submol% alias en premier ?
	\if[\expandafter\expandafter\expandafter\noexpand\expandafter\@car\CF@remain@molecule\@nil
		\expandafter\CF@analyse@optarg\CF@remain@molecule\@nil\CF@remain@molecule
		\expandafter\CF@set@bondangle\expandafter{\CF@current@stringangle}\CF@current@angle
		\let\CF@default@angle\CF@current@angle
		\let\CF@previous@angle\CF@current@angle
		\unless\ifx\@empty\CF@current@stringangle\let\CF@default@angle\CF@current@angle\fi
		\unless\ifx\@empty\CF@current@length\let\CF@default@length\CF@current@length\fi
		\unless\ifx\@empty\CF@current@fromatom\let\CF@default@fromatom\CF@current@fromatom\fi
		\unless\ifx\@empty\CF@current@toatom\let\CF@default@toatom\CF@current@toatom\fi
		\unless\ifx\@empty\CF@current@tikz\let\CF@default@tikz\CF@current@tikz\fi
		\CF@seek@submol
	\fi
	\ifCF@incycle% si on commence un cycle
		\let\CF@current@angle\CF@previous@angle
	\else
		\let\CF@current@angle\CF@default@angle
	\fi
	\edef\CF@default@stringangle{:\CF@default@angle}%
	\let\CF@current@length\CF@default@length
	\let\CF@current@fromatom\CF@default@fromatom
	\let\CF@current@toatom\CF@default@toatom
	\let\CF@current@tikz\CF@default@tikz
	\ifnum\CF@last@action=\z@
		\let\CF@previous@angle\CF@default@angle
		\node(CF@node){};
		\expandafter\CF@if@firsttokin\expandafter{\CF@remain@molecule}{-=(*~?<>}%
			{\CF@insert@emptygroup\CF@remain@molecule}%
			\relax
	\fi
	\CF@chemfig@v
}

\CF@def\CF@chemfig@v{%
	\let\CF@next@action\CF@chemfig@v% \`a prioi, on reboucle
	\ifx\CF@remain@molecule\@empty
		\let\CF@next@action\endgroup
	\else
		\CF@seek@submol
		\expandafter\CF@seek@node\expandafter{\CF@remain@molecule}\CF@current@atomgroup\CF@remain@molecule
		\ifx\@empty\CF@current@atomgroup% pas de noeud pour commencer ?
			\def\CF@bond@outnode{n\CF@last@groupnumber-%
				 \ifx\CF@current@fromatom\@empty
					 \ifdim\CF@current@angle pt<90pt \number\CF@cnt@atomingroup
					 \else\ifdim\CF@current@angle pt>270pt \number\CF@cnt@atomingroup\else1\fi
					 \fi
				 \else\CF@current@fromatom
				 \fi}%
			\expandafter\futurelet\expandafter\CF@toks@a\expandafter\CF@gobble@tonil\CF@remain@molecule\relax\@nil
			\CF@if@firsttokin@i{-=<>~}% la suite est une liaison
				{\ifnum\CF@last@action=\tw@% c'est la deuxi\`eme liaison cons\'ecutive ?
					\CF@insert@emptygroup\CF@remain@molecule% ins\`ere un groupe vide
					\edef\CF@bond@outnode{\CF@bond@outnode}%
				\else
					\ifCF@incycle\advance\CF@cnt@cycle\@ne\fi
					\expandafter\CF@analyse@bond\expandafter{\CF@remain@molecule}\CF@bond@type
					\edef\CF@bond@outnode{\CF@bond@outnode}%
					\let\CF@remain@molecule\CF@remain@afterbond
					\ifCF@incycle
						\ifnum\CF@cnt@cycle=\CF@cycle@num\relax
							\expandafter\expandafter\expandafter\@firstoftwo
						\else
							\expandafter\expandafter\expandafter\@secondoftwo
						\fi
					\else
						\expandafter\@secondoftwo
					\fi
						{\let\CF@next@action\endgroup
						\CF@draw@bond\CF@bond@type{\CF@bond@outnode}{\CF@hook@cycle}\CF@previous@atomgroup\CF@hook@atomgroup
						}%
						{\node[at=(\CF@bond@outnode),shift=(\ifcase\CF@split@state\or180-\or-\fi\CF@current@angle:\CF@current@length*\CF@atom@sep)](CF@node){};
						\let\CF@previous@angle\CF@current@angle
						\let\CF@last@action\tw@
						}%
				\fi
				\ifx\CF@remain@molecule\@empty% plus rien apr\`es la liaison -> ins\`ere un groupe vide
					\CF@insert@emptygroup\CF@remain@molecule
				\fi
				}%
				{\edef\CF@bond@outnode{\CF@bond@outnode}% \'evalue le l'atome de d\'epart de liaison
				\ifx(\CF@toks@a\expandafter\@firstoftwo\else\expandafter\@secondoftwo\fi% une parenth\`ese pour commencer ?
					{\ifnum\CF@last@action=\tw@% il y avait une liaison juste avant ?
						\CF@insert@emptygroup\CF@remain@molecule
					\else
						\expandafter\CF@grab@submol\expandafter{\CF@remain@molecule}%
						\begingroup
							\ifCF@incycle\let\CF@last@action\thr@@\fi% on \'etait dans un cycle
							\CF@incyclefalse
							\aftergroup\CF@chemfig@v
							\def\CF@next@action{\expandafter\CF@chemfig@iv\expandafter{\CF@sub@mol}}%
					\fi
					}%
					{\ifx\CF@remain@molecule\@empty
						\let\CF@next@action\endgroup
					\else% ce qui reste apr\`es le noeud courant n'est pas vide, ne commence pas par "-=~", ni par une parenth\`ese
						\ifx*\CF@toks@a\expandafter\@firstoftwo\else\expandafter\@secondoftwo\fi% un cycle ?
						{\ifnum\CF@last@action=\tw@
							\CF@insert@emptygroup\CF@remain@molecule% ins\`ere un groupe vide
						\else
							\ifCF@incycle\let\CF@last@action\thr@@\fi% on \'etait dans un cycle
							\ifnum\CF@last@action=\thr@@\let\CF@lastcycle@num\CF@cycle@num\fi
							\CF@expafterarg@ntimes2\CF@if@firsttokmatch{\expandafter\@gobble\CF@remain@molecule}*% un 2\`e "*" ?
								{\CF@expafterarg@ntimes2{\def\CF@remain@molecule}{\expandafter\@gobble\CF@remain@molecule}% enl\`eve la 1er \'etoile
								\CF@expafterarg@ntimes2\CF@if@firsttokmatch{\expandafter\@gobble\CF@remain@molecule}[% un crochet ensuite ?
									{\expandafter\CF@cycle@parsepreamblewithoptarg\CF@remain@molecule\@nil% \begingroup inclus
									}%
									{\def\CF@cyclearc@startangle{0}\def\CF@cyclearc@endangle{360}%
									\let\CF@cyclearc@directtikz\@empty
									\expandafter\CF@cycle@parsepreamble\CF@remain@molecule\@nil% \begingroup inclus
									}%
								\CF@cyclearctrue
								}%
								{\expandafter\CF@cycle@parsepreamble\CF@remain@molecule\@nil% \begingroup inclus
								\CF@cyclearcfalse
								}%
							\CF@cnt@cycle\z@
							\edef\CF@hook@cycle{\CF@bond@outnode}%
							\let\CF@hook@atomgroup\CF@previous@atomgroup
							\CF@incycletrue
							\ifnum\CF@last@action=\thr@@
								\pgfmathparse{360/\CF@lastcycle@num-180}% c'est un cycle dans un cycle
							\else
								\pgfmathparse{-180/\CF@cycle@num-90+\CF@cycle@anglecorrection}%
							\fi
							\let\CF@initcycle@angle\pgfmathresult
							\ifCF@cyclearc% on doit tracer l'arc de cercle dans le cycle ?
								\pgfmathparse{\CF@cycle@inraduiscoeff*\CF@current@length*\CF@atom@sep/(2*tan(180/\CF@cycle@num))}%
								\let\CF@cyclearc@radius\pgfmathresult
								\pgfmathparse{\CF@current@angle+\CF@initcycle@angle+180/\CF@cycle@num+90}
								\let\CF@cyclearc@initangle\pgfmathresult
								\pgfmathparse{\CF@current@length*\CF@atom@sep/(2*sin(180/\CF@cycle@num))}%
								\node[at=(\CF@bond@outnode),shift=(\CF@cyclearc@initangle:\pgfmathresult pt)](arccenter){};% le centre de l'arc
								\node[at=(arccenter),shift=(\CF@cyclearc@startangle:\CF@cyclearc@radius pt)](initarc){};% le d\'ebut de l'arc
								\expandafter\draw\expandafter[\CF@cyclearc@directtikz](initarc) arc (\CF@cyclearc@startangle:\CF@cyclearc@endangle:\CF@cyclearc@radius pt);
							\fi
							\aftergroup\CF@chemfig@v
							\def\CF@next@action{\expandafter\CF@chemfig@iv\expandafter{\CF@sub@mol}}%
						\fi
						}%
						{\errmessage{Package \CF@package@name\space Error: something went wrong here: \detokenize\expandafter{\CF@remain@molecule}^^JIf you think it's a bug, please, send a Minimal Example to the author.}}%
					\fi}%
				}%
		\else
			\CF@expand@second{\CF@expand@second{\CF@expand@second\CF@draw@atomgroup\CF@current@angle}\CF@current@toatom}\CF@current@atomgroup
		\fi
	\fi
	\CF@next@action
}

\CF@def\CF@cycle@parsepreamble*#1#2\@nil{%
	\ifnum#1<\thr@@
		\errmessage{Package \CF@package@name\space Error: A cycle must be at least a triangle.^^JThe number following "*" must be 3 or more}%
	\fi
	\def\CF@remain@molecule{#2}%
	\expandafter\CF@grab@submol\expandafter{\CF@remain@molecule}%
	\begingroup
	\def\CF@cycle@num{#1}%
}

\CF@def\CF@cycle@parsepreamblewithoptarg*[#1]#2#3\@nil{%
	\CF@cycle@parseoptarg#1,\@empty,\@empty,\@empty\@nil
	\CF@cycle@parsepreamble*#2#3\@nil
}

\CF@def\CF@cycle@parseoptarg#1,#2,#3\@nil{%
	\ifx\@empty#1\@empty\def\CF@cyclearc@startangle{0}\else\def\CF@cyclearc@startangle{#1}\fi
	\ifx\@empty#2\@empty\def\CF@cyclearc@endangle{360}\else\def\CF@cyclearc@endangle{#2}\fi
	\expandafter\def\expandafter\CF@cyclearc@directtikz\expandafter{\CF@sanitize@lastitem#3,\@empty\@nil}%
}

\CF@def\CF@grab@submol#1{%
	\begingroup
		\catcode`(\@ne\catcode`)\tw@
		\expandafter\expandafter\expandafter
	\endgroup
	\expandafter\CF@grab@submol@i\scantokens{\relax#1}% le \relax sert \`a meubler pour ne pas que l'argument d\'elimit\'e n'enl\`eve les accolades
}

\CF@def\CF@grab@submol@i#1\@nil{%
	\expandafter\assign@tonil\expandafter\CF@remain@molecule\scantokens\expandafter\expandafter\expandafter{\expandafter\@gobble\@gobble#1}%
	\expandafter\assign@tonil\expandafter\CF@sub@mol\scantokens\expandafter\expandafter\expandafter{\expandafter\@car\@gobble#1\@nil}%
}

\CF@def\assign@tonil#1#2\@nil{\def#1{#2}}

\CF@def\CF@ifcar@isupperletter#1{%
	\ifcat\relax\noexpand#1%
		\let\CF@next\@secondoftwo% faux si c'est une sc
	\else
		\ifnum`#1<`A
			\let\CF@next\@secondoftwo
		\else
			\ifnum`#1>`Z
				\let\CF@next\@secondoftwo
			\else
				\let\CF@next\@firstoftwo
			\fi
		\fi
	\fi
	\CF@next
}

% Cr\'e\'e 4 noeuds au dessus et au dessous des noeuds #1 et #2
% \`a une distance de #3 du noeud #1 et #4 du noeud #2
\CF@def\CF@create@normnodes#1#2#3#4{%
	\ifx\@empty#3\@empty\else
		\node[at=(#1),xshift=#3*\CF@norm@x,yshift=#3*\CF@norm@y](#11){};
		\node[at=(#1),xshift=-#3*\CF@norm@x,yshift=-#3*\CF@norm@y](#12){};
	\fi
	\ifx\@empty#4\@empty\else
		\node[at=(#2),xshift=#4*\CF@norm@x,yshift=#4*\CF@norm@y](#21){};
		\node[at=(#2),xshift=-#4*\CF@norm@x,yshift=-#4*\CF@norm@y](#22){};
	\fi
}

\CF@def\CF@compute@nodevect#1#2{%
	\pgfextractx\CF@dim{\pgfpointanchor{#1}{center}}\edef\CF@dimax{\the\CF@dim}%
	\pgfextracty\CF@dim{\pgfpointanchor{#1}{center}}\edef\CF@dimay{\the\CF@dim}%
	\pgfextractx\CF@dim{\pgfpointanchor{#2}{center}}\edef\CF@dimbx{\the\CF@dim}%
	\pgfextracty\CF@dim{\pgfpointanchor{#2}{center}}\edef\CF@dimby{\the\CF@dim}%
	\pgfmathparse{veclen(\CF@dimbx-\CF@dimax,\CF@dimby-\CF@dimay)}\let\CF@len@vector\pgfmathresult
	\pgfmathparse{(\CF@dimay-\CF@dimby)/\CF@len@vector}\let\CF@norm@x\pgfmathresult
	\pgfmathparse{(\CF@dimbx-\CF@dimax)/\CF@len@vector}\let\CF@norm@y\pgfmathresult
}

\CF@def\CF@set@offset#1#2{%
	\ifx#1\@empty
		\edef#1{\ifx#2\CF@empty@node0pt\else\ifx#2\@empty0pt\else\CF@bond@offset\fi\fi}%
	\fi
}

\CF@def\CF@draw@bond#1#2#3#4#5{% #1=type de liaison #2 et #3:nom de noeuds de d\'ebut et fin #4 et #5: contenu des atomes de d\'ebut et fin
	\CF@set@offset\CF@start@offset#4%
	\CF@set@offset\CF@end@offset#5%
	\let\CF@current@bondstyle\CF@bond@style
	\unless\ifx\CF@current@tikz\@empty\CF@expadd@tocs\CF@current@bondstyle{\expandafter,\CF@current@tikz}\fi
	\path(#2)--(#3)coordinate[pos=0](#2@)coordinate[pos=1](#3@);%
	\CF@compute@nodevect{#2@}{#3@}%
	\pgfmathparse{\CF@start@offset/\CF@len@vector}\let\CF@start@coeff\pgfmathresult
	\pgfmathparse{1-\CF@end@offset/\CF@len@vector}\let\CF@end@coeff\pgfmathresult
	\path(#2@)--(#3@)coordinate[pos=\CF@start@coeff](#2@@)coordinate[pos=\CF@end@coeff](#3@@);%
	\unless\ifx\CF@movebond@name\@empty% on doit poser un nÅud sur la liaison
		\path(#2@@)--(#3@@)coordinate[overlay,pos=\CF@movebond@coeff](\CF@movebond@name);
		\let\CF@movebond@name\@empty
	\fi
	\ifcase#1\relax
		\errmessage{Package \CF@package@name\space Error: unknown bond type, this error should not occur^^JIf you think it's a bug, send a Minimal Example to the author}%
	\or% 1 = liaison simple
		\CF@draw@bond@i(#2@@)--(#3@@);
	\or% 2 = liaison double
		\ifCF@incycle
			\ifnum\CF@doublebond@type=\z@
				\let\CF@doublebond@type\@ne
			\fi
			\ifnum\CF@split@state>\z@
				\let\CF@doublebond@type\tw@
			\fi
			\pgfmathparse{\CF@double@sep*tan(180/\CF@cycle@num)}%
			\let\CF@doublebond@lengthcorrection\pgfmathresult
		\fi
		\ifcase\CF@doublebond@type
			\CF@create@normnodes{#2@@}{#3@@}{\CF@double@sep/2}{\CF@double@sep/2}%
			\CF@draw@bond@i(#2@@1)--(#3@@1);
			\CF@draw@bond@i(#2@@2)--(#3@@2);
		\or
			\CF@create@normnodes{#2@@}{#3@@}\CF@double@sep\CF@double@sep
			\CF@draw@bond@i(#2@@)--(#3@@);
			\begingroup% ajuste \'eventuellement les longueurs des liaisons doubles
				\ifCF@incycle
					\ifdim\CF@start@offset=\z@
						\CF@edefadd@tocs\CF@current@bondstyle{,shorten <=\CF@doublebond@lengthcorrection pt}%
					\fi
					\ifdim\CF@end@offset=\z@
						\CF@edefadd@tocs\CF@current@bondstyle{,shorten >=\CF@doublebond@lengthcorrection pt}%
					\fi
				\fi
				\CF@draw@bond@i(#2@@1)--(#3@@1);
			\endgroup
		\or
			\CF@create@normnodes{#2@@}{#3@@}\CF@double@sep\CF@double@sep
			\CF@draw@bond@i(#2@@)--(#3@@);
			\begingroup% ajuste \'eventuellement les longueurs des liaisons doubles
				\ifCF@incycle
					\ifdim\CF@start@offset=\z@
						\CF@edefadd@tocs\CF@current@bondstyle{,shorten \ifnum\CF@split@state=\z@<=-\else>=\fi\CF@doublebond@lengthcorrection pt}%
					\fi
					\ifdim\CF@end@offset=\z@
						\CF@edefadd@tocs\CF@current@bondstyle{,shorten \ifnum\CF@split@state=\z@>=-\else<=\fi\CF@doublebond@lengthcorrection pt}%
					\fi
				\fi
				\CF@draw@bond@i(#2@@2)--(#3@@2);
			\endgroup
		\fi
	\or% 3 = liaison triple
		\CF@create@normnodes{#2@@}{#3@@}\CF@double@sep\CF@double@sep
		\CF@draw@bond@i(#2@@)--(#3@@);
		\CF@draw@bond@i(#2@@1)--(#3@@1);
		\CF@draw@bond@i(#2@@2)--(#3@@2);
	\or% 4 = liaison Cram pleine de #2 vers #3
		\CF@create@normnodes{#2@@}{#3@@}{\CF@cram@basewidth/2}{}%
		\expandafter\filldraw\expandafter[\CF@current@bondstyle,line join=bevel](#2@@1)--(#2@@2)--(#3@@)--(#2@@1);
	\or% 5 = liaison Cram pleine de #3 vers #2
		\CF@create@normnodes{#3@@}{#2@@}{\CF@cram@basewidth/2}{}%
		\expandafter\filldraw\expandafter[\CF@current@bondstyle,line join=bevel](#3@@1)--(#3@@2)--(#2@@)--(#3@@1);
	\or% 6 = liaison Cram pointill\'ee de #2 vers #3
		\scope
			\CF@create@normnodes{#2@@}{#3@@}{\CF@cram@basewidth/2}{}%
			\clip(#2@@1)--(#2@@2)--(#3@@)--(#2@@1);
			\expandafter\draw\expandafter[\CF@current@bondstyle,dash pattern=on \CF@cram@dashlength off \CF@cram@dashsep,line width=\CF@cram@basewidth](#2@@)--(#3@@);
		\endscope
	\or% 7 = liaison Cram pointill\'ee de #3 vers #2
		\scope
			\CF@create@normnodes{#3@@}{#2@@}{\CF@cram@basewidth/2}{}%
			\clip(#3@@1)--(#3@@2)--(#2@@)--(#3@@1);
			\expandafter\draw\expandafter[\CF@current@bondstyle,dash pattern=on \CF@cram@dashlength off \CF@cram@dashsep,line width=\CF@cram@basewidth](#3@@)--(#2@@);
		\endscope
	\or% 8 = liaison Cram triangle \'evid\'e de #2 vers #3
		\CF@create@normnodes{#2@@}{#3@@}{\CF@cram@basewidth/2}{}%
		\expandafter\draw\expandafter[\CF@current@bondstyle,line join=bevel](#2@@1)--(#2@@2)--(#3@@)--(#2@@1);
	\or% 9 = liaison Cram triangle \'evid\'e de #3 vers #1
		\CF@create@normnodes{#3@@}{#2@@}{\CF@cram@basewidth/2}{}%
		\expandafter\draw\expandafter[\CF@current@bondstyle,line join=bevel](#3@@1)--(#3@@2)--(#2@@)--(#3@@1);
	\else
		\errmessage{Package \CF@package@name\space Error: unknown bond type, this error should not occur^^JIf you think it's a bug, send a Minimal Example to the author}%
	\fi
	\let\CF@start@offset\@empty
	\let\CF@end@offset\@empty
}

\CF@def\CF@draw@bond@i{\expandafter\draw\expandafter[\CF@current@bondstyle]}

\CF@def\CF@hook@drawall{% dessine tous les crochets contenus dansla sc \CF@hook@draw
	\unless\ifx\CF@hook@drawlist\@empty
		\expandafter\CF@hook@drawfirst\CF@hook@drawlist\@nil% trace un lien de crochet \`a crochet
		\expandafter\CF@hook@drawall
	\fi
}

\CF@def\CF@hook@drawfirst[#1,#2,#3]#4#5#6#7#8\@nil{%
	\def\CF@hook@drawlist{#8}%
	\begingroup
		\def\CF@current@tikz{#3}%
		\def\CF@hook@startcontent{#6}\def\CF@hook@endcontent{#7}%
		\CF@if@integer{#2}%
			{\CF@draw@bond{#2}{#4}{#5}\CF@hook@startcontent\CF@hook@endcontent}%
			{\CF@bond@findnum{#2}\CF@bond@currentnum
			\CF@draw@bond\CF@bond@currentnum{#4}{#5}\CF@hook@startcontent\CF@hook@endcontent
			}%
	\endgroup
}

\CF@def\CF@extract@atom#1-#2\@nil{#2}% transforme le bound@outnode en nÂ° de l'atome

\CF@def\setnodestyle{\def\CF@node@style}
\setnodestyle{}

\CF@def\setbondstyle{\def\CF@bond@style}
\setbondstyle{}

\expandafter\CF@def\expandafter\CF@gobble@movearg\string @#1#2\@nil#3%
{%
	\expandafter\def\csname atom@\number\CF@cnt@atomnumber\endcsname{#2}%
	\CF@if@instr{#1},%
		{\CF@analyse@movearg#1\@nil#3\let\CF@movebond@coeff\@empty}%
		{\def#3{#1}}%
	\ifx\@empty#2\@empty\let\CF@node@strut\@empty\fi
}%

\CF@def\hflipnext{\let\CF@split@state\@ne}

\CF@def\vflipnext{\let\CF@split@state\tw@}
\let\CF@split@state\z@

\CF@def\CF@draw@atomgroup#1#2#3{% #1=angle d'arriv\'ee de la liaison #2=numero atome sur lequel arrive la liaison #3=groupe d'atomes
	\expandafter\let\expandafter\CF@bond@outcontent% assigne le contenu de l'atome d'o\`u part la liaison
		\csname
			\ifdefined\CF@bond@outnode
				atom@\expandafter\CF@extract@atom\CF@bond@outnode\@nil
			\else
				@empty%
			\fi
		\endcsname
	\global\advance\CF@cnt@groupnumber\@ne
	\let\CF@current@atom\@empty
	\global\let\CF@hook@drawlist\@empty
	\CF@cnt@atomingroup\z@
	\CF@if@firsttokmatch{#3}?{\CF@draw@atomgroup@i{{}#3}}{\CF@draw@atomgroup@i{#3}}%
	\def\CF@current@atomgroup{#3}%
	\CF@remove@movearg\CF@current@atomgroup% enl\`eve les "@{<nom>}"
	\CF@if@instr{#3}?%
		{\CF@remove@hook\CF@current@atomgroup
		\ifx\@empty\CF@current@atomgroup\let\CF@current@atomgroup\CF@empty@node\fi}%
		\relax
	\ifx\@empty#2\@empty%
	\else
		\ifnum#2<\@ne
			\immediate\write\CF@unused{Package \CF@package@name\space Warning: no atom found at position #2, pershaps you mispelled the optional argument of the bond.}%
		\else
			\ifnum#2>\CF@cnt@atomingroup
				\errmessage{Package \CF@package@name\space Error: no atom found at position #2, pershaps you mispelled the optional argument of the bond.}%
			\fi
		\fi
	\fi
	\edef\CF@hook@atomnumber{%
		\ifx\@empty#2\@empty
			\ifdim#1pt>90pt
				\ifdim#1pt<270pt \number\CF@cnt@atomingroup\else1\fi
			\else1%
			\fi
		\else#2%
		\fi}%
	\CF@cnt@atomnumber\CF@hook@atomnumber
	\ifx\CF@current@atomgroup\CF@empty@node
		\let\CF@node@strut\@empty
	\else
		\ifx\@empty\CF@bond@outcontentsaved
			\def\CF@node@strut{\vphantom\CF@bond@outcontent}%
		\else
			\def\CF@node@strut{\vphantom\CF@bond@outcontentsaved}%
		\fi
	\fi
	\edef\CF@opt@string{anchor=\ifnum\CF@last@action=\z@ base\else center\fi,at=(CF@node),\CF@node@style}% premier atome de la mol\'ecule affich\'e
	\loop
		\unless\ifnum\CF@cnt@atomnumber>\CF@cnt@atomingroup
		\expandafter\expandafter\expandafter\futurelet\expandafter\expandafter\expandafter\CF@toks@a\expandafter\expandafter\expandafter
			\CF@gobble@tonil\csname atom@\number\CF@cnt@atomnumber\endcsname\@nil
		\expandafter\ifx\string @\CF@toks@a% l'atome courant commence par un "@"
			\expandafter\expandafter\expandafter\CF@gobble@movearg\csname atom@\number\CF@cnt@atomnumber\endcsname\@nil\CF@moveatom@name
			\expandafter\node\expandafter[\CF@opt@string,overlay](\CF@moveatom@name){\phantom{\CF@node@content}};%
			\let\CF@moveatom@name\@empty
		\fi
		\expandafter\node\expandafter[\CF@opt@string](n\number\CF@cnt@groupnumber-\number\CF@cnt@atomnumber){\CF@node@content};%
		\let\CF@node@strut\@empty
		\advance\CF@cnt@atomnumber\@ne
		\edef\CF@opt@string{anchor=base \ifnum\CF@split@state=\@ne east\else west\fi,at=(n\number\CF@cnt@groupnumber-\number\numexpr\CF@cnt@atomnumber-1.base \ifnum\CF@split@state=\@ne west\else east\fi),\CF@node@style}%
	\repeat
	\CF@cnt@atomnumber\CF@hook@atomnumber
	\ifnum\CF@last@action=\tw@% s'il faut tracer une liaison
		\gdef\CF@cycle@anglecorrection{0}% alors c'est qu'un cycle ne peut pas commencer la mol\'ecule : annulation de la correction d'angle
		\CF@draw@bond\CF@bond@type{\CF@bond@outnode}{n\number\CF@cnt@groupnumber-\number\CF@cnt@atomnumber}\CF@previous@atomgroup\CF@current@atomgroup
	\fi
	\let\CF@last@action\@ne% met la derni\`ere action \`a 1 : affichage d'un noeud
	\loop
		\ifnum\CF@cnt@atomnumber>\@ne
		\advance\CF@cnt@atomnumber\m@ne
		\edef\CF@opt@string{anchor=base \ifnum\CF@split@state=\@ne west\else east\fi,at=(n\number\CF@cnt@groupnumber-\number\numexpr\CF@cnt@atomnumber+1.base \ifnum\CF@split@state=\@ne east\else west\fi),\CF@node@style}%
		\expandafter\expandafter\expandafter\futurelet\expandafter\expandafter\expandafter\CF@toks@a\expandafter\expandafter\expandafter
			\CF@gobble@tonil\csname atom@\number\CF@cnt@atomnumber\endcsname\@nil
		\expandafter\ifx\string @\CF@toks@a% l'atome courant commence par un "@"
			\expandafter\expandafter\expandafter\CF@gobble@movearg\csname atom@\number\CF@cnt@atomnumber\endcsname\@nil\CF@moveatom@name
			\expandafter\node\expandafter[\CF@opt@string,overlay](\CF@moveatom@name){\phantom{\CF@node@content}};%
			\let\CF@moveatom@name\@empty
		\fi
		\expandafter\node\expandafter[\CF@opt@string](n\number\CF@cnt@groupnumber-\number\CF@cnt@atomnumber){\CF@node@content};%
	\repeat
	\CF@hook@drawall
	\edef\CF@last@groupnumber{\number\CF@cnt@groupnumber}%
	\let\CF@previous@atomgroup\CF@current@atomgroup
}

\expandafter\CF@def\expandafter\CF@keep@movearg\string @#1#2\@nil{\expandafter\def\expandafter\CF@current@atom\expandafter{\string @{#1}}}

\CF@def\CF@draw@atomgroup@i#1{% transforme #1 en un groupe d'atomes
	\ifx\@empty#1\@empty
		\expandafter\let\csname atom@\number\CF@cnt@atomingroup\endcsname\CF@current@atom
	\else
		\advance\CF@cnt@atomingroup\@ne
		\futurelet\CF@toks@a\CF@gobble@tonil#1\@nil
		\expandafter\ifx\string @\CF@toks@a\expandafter\@firstoftwo\else\expandafter\@secondoftwo\fi
			{\CF@keep@movearg#1\@nil
			\CF@swap@fi
			\CF@remove@movearg@i#1\@nil\CF@after@movearg
			\expandafter\CF@draw@atomgroup@ii\expandafter{\CF@after@movearg}%
			}%
			{\CF@swap@fi
			\let\CF@current@atom\@empty
			\CF@draw@atomgroup@ii{#1}%
			}%
	\fi
}

\CF@def\CF@draw@atomgroup@ii#1{%
	\ifx\@empty#1\@empty
		\expandafter\let\csname atom@\number\CF@cnt@atomingroup\endcsname\CF@current@atom
	\else
	\futurelet\CF@toks@a\CF@gobble@tonil#1\@nil
	\ifx\bgroup\CF@toks@a\expandafter\@firstoftwo\else\expandafter\@secondoftwo\fi
		{\CF@expadd@tocs\CF@current@atom{\expandafter{\@car#1\@nil}}%
		\expandafter\CF@draw@atomgroup@iii\expandafter{\@gobble#1}%
		}%
		{\ifx\@sptoken\CF@toks@a\expandafter\@firstoftwo\else\expandafter\@secondoftwo\fi
			{\CF@add@tocs\CF@current@atom{ }%
			\expandafter\CF@draw@atomgroup@iii\expandafter{\CF@after@space#1\@nil}%
			}%
			{\CF@expadd@tocs\CF@current@atom{\@car#1\@nil}%
			\expandafter\CF@draw@atomgroup@iii\expandafter{\@gobble#1}%
			}%
		}%
	\fi
}

% enl\`eve tous les "@{nom}" de la sc #1
\CF@def\CF@remove@movearg#1{%
	\CF@expand@afterfirst{\expandafter\CF@if@instr\expandafter{#1}}{\string @}%
		{\expandafter\CF@remove@movearg@i#1\@nil#1%
		\CF@remove@movearg#1}%
		\relax
}

% enl\`eve le premier "@{<nom>}" de l'argument et l'assigne \`a #2
\CF@def\CF@remove@movearg@i#1\@nil#2{%
	\expandafter\def\expandafter\CF@remove@movearg@ii\expandafter##\expandafter1\string @{%
		\expandafter\def\expandafter#2\expandafter{\@gobble##1}% mange le \relax
		\CF@remove@movearg@iii\relax
	}%
	\def\CF@remove@movearg@iii##1\@nil{\CF@expadd@tocs#2{\@gobbletwo##1}}% mange le \relax et le <nom>
	\CF@remove@movearg@ii\relax#1\@nil
}

\CF@def\CF@draw@atomgroup@iii#1{% transforme #1 en un groupe d'atomes
	\ifx\@empty#1\@empty%
		\expandafter\let\csname atom@\number\CF@cnt@atomingroup\endcsname\CF@current@atom
		\let\CF@current@atom\@empty
	\else
		\futurelet\CF@toks@a\CF@gobble@tonil#1\@nil
		\expandafter\ifx\string @\CF@toks@a\expandafter\@firstoftwo\else\expandafter\@secondoftwo\fi
			{\expandafter\let\csname atom@\number\CF@cnt@atomingroup\endcsname\CF@current@atom
			\let\CF@current@atom\@empty
			\CF@swap@fi\CF@draw@atomgroup@i{#1}%
			}%
			{\ifx|\CF@toks@a\expandafter\@firstoftwo\else\expandafter\@secondoftwo\fi
				{\expandafter\let\csname atom@\number\CF@cnt@atomingroup\endcsname\CF@current@atom
				\let\CF@current@atom\@empty
				\CF@swap@fi\expandafter\CF@draw@atomgroup@i\expandafter{\@gobble#1}%
				}%
				{\ifx\@sptoken\CF@toks@a\expandafter\@firstoftwo\else\expandafter\@secondoftwo\fi
					{\CF@add@tocs\CF@current@atom{ }%
					\CF@swap@fi\expandafter\CF@draw@atomgroup@iii\expandafter{\CF@after@space#1\@nil}%
					 }%
					{\ifx\bgroup\CF@toks@a\expandafter\@firstoftwo\else\expandafter\@secondoftwo\fi
						{\CF@expadd@tocs\CF@current@atom{\expandafter{\@car#1\@nil}}%
						\CF@swap@fi\expandafter\CF@draw@atomgroup@iii\expandafter{\@gobble#1}%
						}%
						{\expandafter\CF@ifcar@isupperletter\expandafter{\@car#1\@nil}%
							{\expandafter\let\csname atom@\number\CF@cnt@atomingroup\endcsname\CF@current@atom
							\let\CF@current@atom\@empty
							\CF@swap@fi\CF@draw@atomgroup@i{#1}%
							}%
							{\ifx?\CF@toks@a\expandafter\@firstoftwo\else\expandafter\@secondoftwo\fi
								{\expandafter\CF@if@firsttokmatch\expandafter{\@gobble#1}[% un crochet apr\`es le "?"
									{\expandafter\CF@grab@optarg\@gobble#1\@nil\CF@after@hook}%
									{\expandafter\CF@grab@optarg\expandafter[\expandafter]\@gobble#1\@nil\CF@after@hook}%
									\CF@expand@second{\CF@expand@second\CF@if@instr\CF@hook@list}{\expandafter(\CF@hook@currentname)}% crochet d\'ej\`a d\'efini ?
									{\expandafter\CF@hook@parselist\expandafter{\CF@hook@currentname}% va chercher les caract\'eristiques du crochet sauvegard\'e
									\CF@edefadd@tocs\CF@hook@drawlist{%
										[\CF@hook@currentname,\CF@hook@currentlink,\CF@hook@currenttikz]{\CF@hook@savedcoord}{n\number\CF@cnt@groupnumber-\number\CF@cnt@atomingroup}}%
									\CF@expadd@tocs\CF@hook@drawlist{\expandafter{\CF@hook@savedcontent}}%
									\CF@expadd@tocs\CF@hook@drawlist{\expandafter{\CF@current@atom}}% ajoute les 4 arguments \`a la liste des crochets \`a tracer
									\global\let\CF@hook@drawlist\CF@hook@drawlist
									}%
									{\CF@edefadd@tocs\CF@hook@list{(\CF@hook@currentname)|n\number\CF@cnt@groupnumber-\number\CF@cnt@atomingroup|}%
									\CF@expadd@tocs\CF@hook@list{\CF@current@atom|}%
									\global\let\CF@hook@list\CF@hook@list
									}%
								\CF@swap@fi\expandafter\CF@draw@atomgroup@iii\expandafter{\CF@after@hook}%
								}%
								{\CF@expadd@tocs\CF@current@atom{\@car#1\@nil}%
								\CF@swap@fi\expandafter\CF@draw@atomgroup@iii\expandafter{\@gobble#1}%
								}%
							}%
						}%
					}%
				}%
			}%
	\fi
}

\CF@def\CF@kook@defaultname{a}
\CF@def\CF@hook@defaultlink{-}
\CF@def\CF@hook@defaulttikz{}

\CF@def\CF@hook@parseoptarg#1,#2,#3\@nil{%
	\CF@testempty@andassign\CF@hook@currentname{#1}\CF@kook@defaultname
	\CF@testempty@andassign\CF@hook@currentlink{#2}\CF@hook@defaultlink
	\CF@testempty@andassign\CF@hook@currenttikz{#3}\CF@hook@defaulttikz
}

\CF@def\CF@grab@optarg[#1]#2\@nil#3{%
	\CF@hook@parseoptarg#1,,\@nil
	\def#3{#2}%
}

\CF@def\CF@hook@parselist#1{% #1 est le nom du noeud \`a retrouver
	\def\CF@hook@parselist@i##1(#1)|##2|##3|##4\@nil{%
		\def\CF@hook@savedcoord{##2}\def\CF@hook@savedcontent{##3}%
	}%
	\expandafter\CF@hook@parselist@i\CF@hook@list\@nil
}

\CF@def\CF@remove@hook#1{% enl\`eve tous les crochets (et leurs arguments optionnels) de la sc #1
	\expandafter\CF@if@instr\expandafter{#1}{?[}%
		{\expandafter\expandafter\expandafter\def\expandafter\expandafter\expandafter#1%
			\expandafter\expandafter\expandafter{\expandafter\CF@remove@opthook#1\@nil}%
		\CF@remove@hook#1%
		}%
		{\CF@remove@hook@i#1}%
}

\CF@def\CF@remove@hook@i#1{%
	\expandafter\CF@if@instr\expandafter{#1}?%
		{\expandafter\expandafter\expandafter\def\expandafter\expandafter\expandafter#1%
			\expandafter\expandafter\expandafter{\expandafter\CF@remove@singlehook#1\@nil}%
		\CF@remove@hook@i#1%
		}%
		\relax
}

\CF@def\CF@remove@opthook#1?[#2]#3\@nil{#1#3}

\CF@def\CF@remove@singlehook#1?#2\@nil{#1#2}

\CF@def\setlewis{\@testopt\CF@setlewis{0.3ex}}

\CF@def\CF@setlewis[#1]#2#3#4{%
	\def\CF@lewis@widthdouble{#1}%
	\ifx\@empty#2\@empty\def\CF@lewis@offset{0.4ex}\else\def\CF@lewis@offset{#2}\fi
	\ifx\@empty#3\@empty\def\CF@lewis@length{1.5ex}\else\def\CF@lewis@length{#3}\fi
	\ifx\@empty#4\@empty\def\CF@lewis@style{}\else\def\CF@lewis@style{#4}\fi
}

\setlewis{}{}{}

\CF@def\lewis{\begingroup\@makeother;\@makeother:\CF@lewis@i}

\CF@def\CF@lewis@i#1{\CF@lewis@ii#1\@nil}

\CF@def\CF@lewis@ii#1,#2\@nil{%
	\setbox\CF@lewis@box\hbox{\printatom{#2}}%
	\def\CF@lewis@remainpos{#1}%
	\let\CF@lewis@previouspos\@empty
	\loop
		\unless\ifx\CF@lewis@remainpos\@empty
			\edef\CF@lewis@currentpos{\expandafter\@car\CF@lewis@remainpos\@nil}%
			\edef\CF@lewis@remainpos{\expandafter\@gobble\CF@lewis@remainpos}%
			\pgfmathparse{\wd\CF@lewis@box/2+\ifcase\CF@lewis@currentpos\space1\or1\or0\or-1\or-1\or-1\or0\or1\fi*(\wd\CF@lewis@box/2+\CF@lewis@offset)}%
			\let\CF@lewis@x\pgfmathresult
			\pgfmathparse{\ht\CF@lewis@box/2+\ifcase\CF@lewis@currentpos\space0\or1\or1\or1\or0\or-1\or-1\or-1\fi*(\ht\CF@lewis@box/2\ifnum\CF@lewis@currentpos>4 +\dp\CF@lewis@box\fi+\CF@lewis@offset)}%
			\let\CF@lewis@y\pgfmathresult
			\edef\CF@lewis@xoffset{\ifcase\CF@lewis@currentpos\space
				0\or0.70711\or1\or0.70711\or0\or-0.70711\or-1\or-0.70711\fi}%
			\edef\CF@lewis@yoffset{\ifcase\CF@lewis@currentpos\space
				-1\or-0.70711\or0\or0.70711\or1\or0.70711\or0\or-0.70711\fi}%
			\pgfmathparse{veclen(\CF@lewis@xoffset,\CF@lewis@yoffset)}\let\CF@len@normvec\pgfmathresult
			\edef\CF@lewis@diagmul{\ifcase\CF@lewis@currentpos\space1\or0\or1\or0\or1\or0\or1\or0\fi}% annule l'offset pour les diagonales
			\if.\expandafter\@car\CF@lewis@remainpos\relax\@nil
				\edef\CF@lewis@remainpos{\expandafter\@gobble\CF@lewis@remainpos}%
				\tikz \draw[overlay,fill,black]
					(\CF@lewis@x pt-\CF@lewis@yoffset*\CF@lewis@diagmul*0.1ex,
					\CF@lewis@y pt+\CF@lewis@xoffset*\CF@lewis@diagmul*0.1ex)circle(0.15ex);%
			\else
				\if|\expandafter\@car\CF@lewis@remainpos\relax\@nil
					\edef\CF@lewis@remainpos{\expandafter\@gobble\CF@lewis@remainpos}%
					\expandafter\tikz\expandafter\draw\expandafter[\CF@lewis@style,overlay]%
						(\CF@lewis@x-\CF@lewis@length*\CF@lewis@xoffset/2 pt,\CF@lewis@y-\CF@lewis@length*\CF@lewis@yoffset/2 pt)--
						([xshift=-\CF@lewis@yoffset*\CF@lewis@widthdouble,yshift=\CF@lewis@xoffset*\CF@lewis@widthdouble]\CF@lewis@x-\CF@lewis@xoffset*\CF@lewis@length/2 pt,\CF@lewis@y-\CF@lewis@yoffset*\CF@lewis@length/2 pt)--
						([xshift=-\CF@lewis@yoffset*\CF@lewis@widthdouble,yshift=\CF@lewis@xoffset*\CF@lewis@widthdouble]\CF@lewis@x+\CF@lewis@length*\CF@lewis@xoffset/2 pt,\CF@lewis@y+\CF@lewis@length*\CF@lewis@yoffset/2 pt)--
						(\CF@lewis@x+\CF@lewis@length*\CF@lewis@xoffset/2 pt,\CF@lewis@y+\CF@lewis@length*\CF@lewis@yoffset/2 pt)--cycle;%
				\else
					\if:\expandafter\@car\CF@lewis@remainpos\relax\@nil
						\edef\CF@lewis@remainpos{\expandafter\@gobble\CF@lewis@remainpos}%
						\tikz \draw[overlay,fill,black]
							(\CF@lewis@x pt-\CF@lewis@yoffset*\CF@lewis@diagmul*0.2ex-.2em*\CF@lewis@xoffset/\CF@len@normvec,\CF@lewis@y pt+\CF@lewis@xoffset*\CF@lewis@diagmul*0.2ex-.2em*\CF@lewis@yoffset/\CF@len@normvec)circle(0.15ex)%
							(\CF@lewis@x pt-\CF@lewis@yoffset*\CF@lewis@diagmul*0.2ex+.2em*\CF@lewis@xoffset/\CF@len@normvec,\CF@lewis@y pt+\CF@lewis@xoffset*\CF@lewis@diagmul*0.2ex+.2em*\CF@lewis@yoffset/\CF@len@normvec)circle(0.15ex);%
					\else
						\expandafter\tikz\expandafter\draw\expandafter[\CF@lewis@style,overlay]%
							(\CF@lewis@x-\CF@lewis@length*\CF@lewis@xoffset/2 pt,\CF@lewis@y-\CF@lewis@length*\CF@lewis@yoffset/2 pt)--%
							(\CF@lewis@x+\CF@lewis@length*\CF@lewis@xoffset/2 pt,\CF@lewis@y+\CF@lewis@length*\CF@lewis@yoffset/2 pt);%
					\fi
				\fi
		\fi
	\repeat
	\box\CF@lewis@box
	\endgroup
}

\CF@def\chembelow{%
	\@testopt\CF@chembelow{1.5pt}}

\CF@def\CF@chembelow[#1]#2#3{%
	\setbox\CF@box@boxa\hbox{\printatom{#2}}\setbox\CF@box@boxb\hbox{\printatom{#3}}%
	\vtop{%
		\hbox{\printatom{#2}}%
		\hrule width0pt depth0pt height#1\relax
		\hbox{%
			\hskip\dimexpr(\wd\CF@box@boxa-\wd\CF@box@boxb)/\tw@
			\printatom{#3}%
			\hskip\dimexpr(\wd\CF@box@boxa-\wd\CF@box@boxb)/\tw@
			}%
			\vskip-\dimexpr\ht\CF@box@boxb+\dp\CF@box@boxb+#1\relax
		}%
}

\CF@def\chemabove{%
	\@testopt\CF@chemabove{1.5pt}}

\CF@def\CF@chemabove[#1]#2#3{%
	\setbox\CF@box@boxa\hbox{\printatom{#2}}\setbox\CF@box@boxb\hbox{\printatom{#3}}%
	\vtop{%
		\hbox{\printatom{#2}}%
		\hrule width0pt depth0pt height-\dimexpr#1+\ht\CF@box@boxa+\ht\CF@box@boxb+\dp\CF@box@boxb\relax
		\hbox{%
			\hskip\dimexpr(\wd\CF@box@boxa-\wd\CF@box@boxb)/\tw@
			\printatom{#3}%
			\hskip\dimexpr(\wd\CF@box@boxa-\wd\CF@box@boxb)/\tw@
			}%
		}%
}

%%%%%% les signes et les fl\`eches
\CF@def\chemsign{\@testopt\CF@chemsign{0.5em}}

\CF@def\CF@chemsign[#1]#2{\hbox{\kern#1\relax#2\kern#1}}

\CF@def\setchemrel#1#2#3{%
	\ifx\@empty#1\@empty\def\CF@chemrel@vsep{2pt}\else\def\CF@chemrel@vsep{#1}\fi
	\ifx\@empty#2\@empty\def\CF@chemrel@hsep{0.7em}\else\def\CF@chemrel@hsep{#2}\fi
	\ifx\@empty#3\@empty\def\CF@chemrel@length{4em}\else\def\CF@chemrel@length{#3}\fi
}

\setchemrel{}{}{}

\CF@def\chemrel{%
	\@testopt\CF@chemchemrel@i{}}

\CF@def\CF@chemchemrel@i[#1]{\@testopt{\CF@chemchemrel@ii[#1]}{}}

\CF@def\CF@chemchemrel@ii[#1][#2]#3{%
	\def\CF@chemrel@stuff
		{\leavevmode\kern\CF@chemrel@hsep
		\tikzpicture[every node/.style={anchor=base,inner sep=0pt,outer sep=0pt,minimum size=0pt},baseline]%
			\CF@if@instr{#3}{<>}%
				{\node[yshift=-1pt] at(0,0)(chemrel@start){\vphantom I};\node[yshift=-1pt] at(\CF@chemrel@length,0)(chemrel@end){\vphantom I};%
				\expandafter\draw\expandafter[\CF@remove@equichars#3,\@nil-](chemrel@end)--(chemrel@start);\fill (chemrel@start)--++(4pt,-1.75pt)--+(-1.5pt,1.75pt)--cycle;%
				\node[yshift=1pt] at(0,0)(chemrel@start){\vphantom I};\node[yshift=1pt] at(\CF@chemrel@length,0)(chemrel@end){\vphantom I};%
				\expandafter\draw\expandafter[\CF@remove@equichars#3,\@nil-](chemrel@start)--(chemrel@end);\fill(chemrel@end)--++(-4pt,1.75pt)--+(1.5pt,-1.75pt)--cycle;
				}%
				{\node at(0,0)(chemrel@start){\vphantom I};\node at(\CF@chemrel@length,0)(chemrel@end){\vphantom I};%
				\draw[#3](chemrel@start)--(chemrel@end);%
				}%
		\endtikzpicture
		\kern\CF@chemrel@hsep
		}%
	\ifx\@empty#1\@empty
		\ifx\@empty#2\@empty\CF@chemrel@stuff
		\else\chembelow[\CF@chemrel@vsep]\CF@chemrel@stuff{\hbox{#2}}%
		\fi
	\else
		\ifx\@empty#2\@empty\chemabove[\CF@chemrel@vsep]\CF@chemrel@stuff{\hbox{#1}}%
		\else\chemabove[\CF@chemrel@vsep]{\chembelow[\CF@chemrel@vsep]\CF@chemrel@stuff{\hbox{#2}}}{\hbox{#1}}%
		\fi
	\fi
}

\CF@def\CF@remove@equichars#1<>#2\@nil{#1#2}

\CF@def\chemmove{%
	\@testopt\CF@chemmove{}}

\CF@def\CF@chemmove[#1]#2{%
	\ifx\@empty#2\@empty
		\expandafter\@gobble
	\else
		\expandafter\@firstofone
	\fi
	{\expandafter\tikzpicture\romannumeral\ifx\@empty#1\@empty\expandafter\@firstoftwo\else\expandafter\@secondoftwo\fi
		{\z@[remember picture,overlay]}{\z@[remember picture,overlay,#1]}#2
		\endtikzpicture
	}%
}

\CF@def\chemnameinit#1{%
	\setbox\CF@stuff@box\hbox{#1}%
	\edef\CF@dp@max{\the\dp\CF@stuff@box}%
}
\chemnameinit{}

\CF@def\CF@parse@molname#1\\#2\@nil{%
	\hbox to\CF@wd@stuffbox{\hss#1\hss}%
	\ifx\@empty#2\@empty
	\else
		\CF@swap@fi
		\CF@parse@molname#2\@nil
	\fi
}

\CF@def\chemname{%
	\@testopt\CF@chemname{1.5ex}%
}

\CF@def\CF@chemname[#1]#2#3{%
	\setbox\CF@stuff@box\hbox{#2}%
	\edef\CF@wd@stuffbox{\the\wd\CF@stuff@box}\edef\CF@dp@stuffbox{\the\dp\CF@stuff@box}%
	\leavevmode
	\ifdim\CF@dp@max<\CF@dp@stuffbox\let\CF@dp@max\CF@dp@stuffbox\fi
	\vtop{%
		\box\CF@stuff@box
		\nointerlineskip
		\kern\dimexpr#1+\CF@dp@max-\CF@dp@stuffbox\relax
		\CF@parse@molname#3\\\@nil
	}%
}

\CF@savedcatcode

\endinput

######################################################################
#                             Historique                             #
######################################################################

v0.1        2010/06/23
	- Premi\`ere version publique sur le CTAN
----------------------------------------------------------------------
v0.2        2010/08/31
	- Ajout de la documentation en anglais.
	- Correction de bugs.
	- \printatom est d\'esormais une macro publique.
	- Les espaces sont permis dans les mol\'ecules. Ils seront
	  ignor\'es par d\'efaut puisque les atomes sont compos\'es en
	  mode math par \printatom
	- Une paire de Lewis peut \^etre repr\'esent\'ee ":".
	- Dans les cycles, une correction de la longueur du trait
	  d\'eport\'e des liaisons doubles est fait de telle sorte que si
	  l'on \'ecrit \chemfig{*5(=====)}, on obtient deux polygones
	  r\'eguliers concentriques.
	- La s\'equence de contr\^ole \setnodestyle permet de sp\'ecifier
	  le style des nÅuds dessin\'es par tikz.
----------------------------------------------------------------------
v0.3        2010/11/21
	- Am\'elioration de \definesubmol qui accepte les s\'equences de
	  contr\^ole. On peut aussi choisir un alias dont la substitution
	  est diff\'erente selon l'orientation de la liaison qui lui
	  arrive dessus.
	- Le caract\`ere "|" force la fin d'un atome. Si on \'ecrit
	  "D|ef" alors, chemfig verra deux atomes "D" et "ef".
	- Le caract\`ere "#" est reconnu lorsqu'il suit un caract\`ere de
	  liaison. Il doit \^etre suivi d'un argument entre parenth\`eses
	  qui contient l'offset de d\'ebut et de fin qui s'appliqueront
	  \`a cette liaison.
	- La macro \chemfig admet un argument optionnel qui sera pass\'e
	  \`a l'environnement tikzpicture dans lequel elle est dessin\'ee
	- Mise en place de la repr\'esentation des m\'ecanismes
	  r\'eactionnels avec la synatxe "@{<nom>}" devant un atome o\`u
	  "@{<nom>,<coeff>}" au tout d\'ebut de l'argument d'une liaison.
	  Cette syntaxe permet de placer un nÅud (au sens de tikz) qui
	  deviendra l'extr\'emit\'e des fl\`eches des m\'ecanismes.
	  Le trac\'e des fl\`eches est faite par la macro \chemmove dont
	  l'argument optionnel devient celui de l'environnement
	  tikspicture dans lequel sont faites les fl\`eches.
	- Pour le m\'ecanisme d'alignement vertical via le \vphantom, la
	  commande \chemskipalign permet d'ignorer le groupe d'atomes
	  dans lequel elle est \'ecrite.
	- La commande \chemname permet d'afficher un nom sous une
	  mol\'ecule. la commande \chemnameinit initialise la plus grande
	  profondeur rencontr\'ee.
	- La commande \lewis a \'et\'e modifi\'ee de telle sorte que les
	  dessins des d\'ecorations soient proportionnels \`a la taille
	  de la police.
----------------------------------------------------------------------
v0.3a       2011/01/08
	- Correction d'un bug dans l'argument optionnel de \definesubmol
	  lorsque celui-ci comporte des crochets.
	- Mise \`a jour du manuel en anglais.
	- Ajout de \vflipnext et \hflipnext pour retourner
	  horizontalement ou verticalement la prochaine mol\'ecule.
----------------------------------------------------------------------
v0.4        2011/03/07
	- chemfig est d\'esormais \'ecrit en plain-etex et donc
	  utilisable par d'autres formats que LaTeX.
	- Un peu plus de rigueur avec les catcodes des caract\`eres
	  sp\'eciaux, notamment lorsque la commande \chemfig se trouve
	  dans l'argument de \chemmove, \chemabove, \chembelow, \chemrel.
	  TODO : faut-il \scantoker l'argument de \chemfig pour \^etre
	  d\'efinitivement d\'ebarass\'e de ces histoires de catcode ???
	- Correction d'un bug dans le calcul de l'angle des liaisons
----------------------------------------------------------------------
v0.4a       2011/04/10
	- Correction d'un bug concernant l'argument optionnel en d\'ebut
	  de mol\'ecule.
----------------------------------------------------------------------
v0.4b       2011/04/24
	- l'argument de \chemfig est tok\'enis\'e avec \scantokens ce qui
	  rend caduc tout souci de code de cat\'egorie, \`a part #.
	- la commande \setbondstyle permet de d\'efinir le style des
	  liaisons.
	- correction de l'affichage incorrect des doubles liaisons dans
	  les cycles apr\`es les commandes \hflipnext et \vflipnext
	- correction d'un bug lorsqu'un alias commence une mol\'ecule