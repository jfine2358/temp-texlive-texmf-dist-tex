%%
%% This is file `l3int.sty',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% l3int.dtx  (with options: `package,trace')
%% 
%% 
%% EXPERIMENTAL CODE
%% 
%% Do not distribute this file without also distributing the
%% source files specified above.
%% 
%% Do not distribute a modified version of this file.
%% 
%% 
%% File: l3int.dtx Copyright (C) 1990-2011 LaTeX3 project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the ``expl3 bundle'' (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
\RequirePackage{l3names}
\GetIdInfo$Id: l3int.dtx 2229 2011-04-11 17:37:05Z joseph $
          {L3 Experimental Integer module}
\ProvidesExplPackage
  {\filename}{\filedate}{\fileversion}{\filedescription}
\package_check_loaded_expl:
\cs_set_eq:NN \int_value:w \tex_number:D
\cs_set_eq:NN \int_eval:w \etex_numexpr:D
\cs_set_protected:Npn \int_eval_end: {\tex_relax:D}
\cs_set_eq:NN \if_int_compare:w \tex_ifnum:D
\cs_new_eq:NN \if_num:w             \tex_ifnum:D
\cs_set_eq:NN \if_int_odd:w \tex_ifodd:D
\cs_new_eq:NN \if_case:w          \tex_ifcase:D
\cs_new_eq:NN \int_to_roman:w \tex_romannumeral:D
\cs_new_eq:NN \int_advance:w \tex_advance:D
\cs_set:Npn \int_eval:n #1{
  \int_value:w \int_eval:w #1\int_eval_end:
}
\cs_new_protected_nopar:Npn \int_new:N #1 {
  \chk_if_free_cs:N #1
  \newcount #1
}
\cs_generate_variant:Nn \int_new:N {c}
\cs_new_protected_nopar:Npn \int_set:Nn #1#2{#1 \int_eval:w #2\int_eval_end:
}
\cs_new_protected_nopar:Npn \int_gset:Nn {
 \pref_global:D
   \int_set:Nn }
\cs_generate_variant:Nn\int_set:Nn  {cn}
\cs_generate_variant:Nn\int_gset:Nn {cn}
\cs_new_protected_nopar:Npn \int_set_eq:NN #1#2 {
  \int_set:Nn #1 {#2}
}
\cs_generate_variant:Nn \int_set_eq:NN { c }
\cs_generate_variant:Nn \int_set_eq:NN { Nc }
\cs_generate_variant:Nn \int_set_eq:NN { cc }
\cs_new_protected_nopar:Npn \int_gset_eq:NN #1#2 {
  \int_gset:Nn #1  {#2}
}
\cs_generate_variant:Nn \int_gset_eq:NN { c }
\cs_generate_variant:Nn \int_gset_eq:NN { Nc }
\cs_generate_variant:Nn \int_gset_eq:NN { cc }
\cs_new_protected_nopar:Npn \int_incr:N #1{\int_advance:w#1\c_one
}
\cs_new_protected_nopar:Npn \int_decr:N #1{\int_advance:w#1\c_minus_one
}
\cs_new_protected_nopar:Npn \int_gincr:N {
 \pref_global:D
   \int_incr:N}
\cs_new_protected_nopar:Npn \int_gdecr:N {
 \pref_global:D
   \int_decr:N}
\cs_set_protected_nopar:Npn \int_incr:N #1{\int_add:Nn#1\c_one}
\cs_set_protected_nopar:Npn \int_decr:N #1{\int_add:Nn#1\c_minus_one}
\cs_set_protected_nopar:Npn \int_gincr:N #1{\int_gadd:Nn#1\c_one}
\cs_set_protected_nopar:Npn \int_gdecr:N #1{\int_gadd:Nn#1\c_minus_one}
\cs_generate_variant:Nn \int_incr:N {c}
\cs_generate_variant:Nn \int_decr:N {c}
\cs_generate_variant:Nn \int_gincr:N {c}
\cs_generate_variant:Nn \int_gdecr:N {c}
\cs_new_protected_nopar:Npn \int_zero:N  #1 {#1=\c_zero}
\cs_generate_variant:Nn \int_zero:N {c}
\cs_new_protected_nopar:Npn \int_gzero:N #1 {\pref_global:D #1=\c_zero}
\cs_generate_variant:Nn \int_gzero:N {c}
\cs_new_protected_nopar:Npn \int_add:Nn #1#2{
    \int_advance:w #1 by \int_eval:w #2\int_eval_end:
}
\cs_new_nopar:Npn \int_sub:Nn #1#2{
    \int_advance:w #1-\int_eval:w #2\int_eval_end:
}
\cs_new_protected_nopar:Npn \int_gadd:Nn {
 \pref_global:D
   \int_add:Nn }
\cs_new_protected_nopar:Npn \int_gsub:Nn {
 \pref_global:D
   \int_sub:Nn }
\cs_generate_variant:Nn \int_add:Nn  {cn}
\cs_generate_variant:Nn \int_gadd:Nn {cn}
\cs_generate_variant:Nn \int_sub:Nn  {cn}
\cs_generate_variant:Nn \int_gsub:Nn {cn}
\cs_new_eq:NN \int_use:N \tex_the:D
\cs_new_nopar:Npn \int_use:c #1{\int_use:N \cs:w#1\cs_end:}
\cs_new_eq:NN  \int_show:N  \kernel_register_show:N
\cs_new_eq:NN  \int_show:c  \kernel_register_show:c
\cs_new_nopar:Npn \int_to_arabic:n #1{ \int_eval:n{#1}}
\cs_new_protected_nopar:Npn \int_roman_lcuc_mapping:Nnn #1#2#3{
  \cs_set_nopar:cpn {int_to_lc_roman_#1:}{#2}
  \cs_set_nopar:cpn {int_to_uc_roman_#1:}{#3}
}
\int_roman_lcuc_mapping:Nnn i i I
\int_roman_lcuc_mapping:Nnn v v V
\int_roman_lcuc_mapping:Nnn x x X
\int_roman_lcuc_mapping:Nnn l l L
\int_roman_lcuc_mapping:Nnn c c C
\int_roman_lcuc_mapping:Nnn d d D
\int_roman_lcuc_mapping:Nnn m m M
\int_roman_lcuc_mapping:Nnn Q \use_none:nn \use_none:nn
\cs_new_nopar:Npn \int_to_roman:n #1 {
  \exp_after:wN \int_to_roman_lcuc:NN \exp_after:wN l
    \int_to_roman:w \int_eval:n {#1} Q
}
\cs_new_nopar:Npn \int_to_Roman:n #1 {
  \exp_after:wN \int_to_roman_lcuc:NN \exp_after:wN u
    \int_to_roman:w \int_eval:n {#1} Q
}
\cs_new_nopar:Npn \int_to_roman_lcuc:NN #1#2{
  \use:c {int_to_#1c_roman_#2:}
  \int_to_roman_lcuc:NN #1
}
\cs_new_nopar:Npn \int_convert_to_symbols:nnn #1#2#3 {
  \int_compare:nNnTF {#1} > {#2}
    {
      \exp_args:Nf \int_convert_to_symbols:nnn
        { \int_div_truncate:nn { #1 - 1 } {#2} } {#2} {#3}
      \exp_args:Nf \prg_case_int:nnn
        { \int_eval:n { 1 + \int_mod:nn { #1 - 1 } {#2} } }
        {#3} { }
    }
    { \exp_args:Nf \prg_case_int:nnn { \int_eval:n {#1} } {#3} { } }
}
\cs_set_nopar:Npn \int_convert_number_with_rule:nnN #1#2#3{
  \int_compare:nNnTF {#1}>{#2}
  {
    \exp_args:Nf \int_convert_number_with_rule:nnN
      { \int_div_truncate:nn {#1-1}{#2} }{#2}
      #3
    \exp_args:Nf #3 { \int_eval:n{1+\int_mod:nn {#1-1}{#2}} }
  }
  { \exp_args:Nf #3{ \int_eval:n{#1} } }
}
\cs_new_nopar:Npn \int_to_alph:n #1 {
  \int_convert_to_symbols:nnn {#1} { 26 }
    {
      {  1 } { a }
      {  2 } { b }
      {  3 } { c }
      {  4 } { d }
      {  5 } { e }
      {  6 } { f }
      {  7 } { g }
      {  8 } { h }
      {  9 } { i }
      { 10 } { j }
      { 11 } { k }
      { 12 } { l }
      { 13 } { m }
      { 14 } { n }
      { 15 } { o }
      { 16 } { p }
      { 17 } { q }
      { 18 } { r }
      { 19 } { s }
      { 20 } { t }
      { 21 } { u }
      { 22 } { v }
      { 23 } { w }
      { 24 } { x }
      { 25 } { y }
      { 26 } { z }
    }
}
\cs_new_nopar:Npn \int_to_Alph:n #1 {
  \int_convert_to_symbols:nnn {#1} { 26 }
    {
      {  1 } { A }
      {  2 } { B }
      {  3 } { C }
      {  4 } { D }
      {  5 } { E }
      {  6 } { F }
      {  7 } { G }
      {  8 } { H }
      {  9 } { I }
      { 10 } { J }
      { 11 } { K }
      { 12 } { L }
      { 13 } { M }
      { 14 } { N }
      { 15 } { O }
      { 16 } { P }
      { 17 } { Q }
      { 18 } { R }
      { 19 } { S }
      { 20 } { T }
      { 21 } { U }
      { 22 } { V }
      { 23 } { W }
      { 24 } { X }
      { 25 } { Y }
      { 26 } { Z }
    }
}
\cs_new_nopar:Npn \int_to_symbol:n #1{
  \mode_if_math:TF
  {
    \int_convert_number_with_rule:nnN {#1}{9}
      \int_symbol_math_conversion_rule:n
  }
  {
    \int_convert_number_with_rule:nnN {#1}{9}
      \int_symbol_text_conversion_rule:n
  }
}
\cs_new_nopar:Npn \int_symbol_math_conversion_rule:n #1 {
  \if_case:w #1
    \or: *
    \or: \dagger
    \or: \ddagger
    \or: \mathsection
    \or: \mathparagraph
    \or: \|
    \or: **
    \or: \dagger\dagger
    \or: \ddagger\ddagger
  \fi:
}
\cs_new_nopar:Npn \int_symbol_text_conversion_rule:n #1 {
  \if_case:w #1
    \or: \textasteriskcentered
    \or: \textdagger
    \or: \textdaggerdbl
    \or: \textsection
    \or: \textparagraph
    \or: \textbardbl
    \or: \textasteriskcentered\textasteriskcentered
    \or: \textdagger\textdagger
    \or: \textdaggerdbl\textdaggerdbl
  \fi:
}
\int_new:N \l_tmpa_int
\int_new:N \l_tmpb_int
\int_new:N \l_tmpc_int
\int_new:N \g_tmpa_int
\int_new:N \g_tmpb_int
\cs_set_nopar:Npn \int_pre_eval_one_arg:Nn #1#2{
  \exp_args:Nf#1{\int_eval:n{#2}}}
\cs_set_nopar:Npn \int_pre_eval_two_args:Nnn #1#2#3{
  \exp_args:Nff#1{\int_eval:n{#2}}{\int_eval:n{#3}}
}
\cs_new_nopar:Npn \int_from_roman:n #1 {
  \tl_if_blank:nF {#1}
    {
      \tex_expandafter:D \int_from_roman_end:w
        \tex_number:D \etex_numexpr:D
          \int_from_roman_aux:NN #1 Q \q_stop
    }
}
\cs_new_nopar:Npn \int_from_roman_aux:NN #1#2 {
  \str_if_eq:nnTF {#1} { Q }
    {#1#2}
    {
      \str_if_eq:nnTF {#2} { Q }
        {
          \cs_if_exist:cF { c_int_from_roman_ #1 _int }
            { \int_from_roman_clean_up:w }
          +
          \use:c { c_int_from_roman_ #1 _int }
          #2
        }
        {
          \cs_if_exist:cF { c_int_from_roman_ #1 _int }
            { \int_from_roman_clean_up:w }
          \cs_if_exist:cF { c_int_from_roman_ #2 _int }
            { \int_from_roman_clean_up:w }
          \int_compare:nNnTF
            { \use:c { c_int_from_roman_ #1 _int } }
            <
            { \use:c { c_int_from_roman_ #2 _int  } }
            {
              + \use:c { c_int_from_roman_ #2 _int }
              - \use:c { c_int_from_roman_ #1 _int }
              \int_from_roman_aux:NN
            }
            {
              + \use:c { c_int_from_roman_ #1 _int }
              \int_from_roman_aux:NN #2
            }
        }
    }
}
\cs_new_nopar:Npn \int_from_roman_end:w #1 Q #2 \q_stop {
  \tl_if_empty:nTF {#2} {#1} {#2}
}
\cs_new_nopar:Npn \int_from_roman_clean_up:w #1 Q { + 0 Q -1 }
\cs_new:Npn \int_convert_from_base_ten:nn #1#2 {
  \int_compare:nNnTF {#1} < { 0 }
    {
      -
      \exp_args:Nnf \int_convert_from_base_ten_aux:nnn
        { } { \int_eval:n { 0 - ( #1 ) } } {#2}
    }
    {
      \exp_args:Nnf \int_convert_from_base_ten_aux:nnn
        { } { \int_eval:n {#1} } {#2}
    }
}
\cs_new:Npn \int_convert_from_base_ten_aux:nnn #1#2#3 {
  \int_compare:nNnTF {#2} < {#3}
    {
      \int_convert_number_to_letter:n {#2}
      #1
    }
    {
      \exp_args:Nff \int_convert_from_base_ten_aux:nnn
        {
          \int_convert_number_to_letter:n
            { \int_mod:nn {#2} {#3} }
          #1
        }
        { \int_div_truncate:nn {#2} {#3} }
        {#3}
    }
}
\cs_new:Npn \int_convert_number_to_letter:n #1 {
  \prg_case_int:nnn { #1 - 9 }
    {
      {  1 } { A }
      {  2 } { B }
      {  3 } { C }
      {  4 } { D }
      {  5 } { E }
      {  6 } { F }
      {  7 } { G }
      {  8 } { H }
      {  9 } { I }
      { 10 } { J }
      { 11 } { K }
      { 12 } { L }
      { 13 } { M }
      { 14 } { N }
      { 15 } { O }
      { 16 } { P }
      { 17 } { Q }
      { 18 } { R }
      { 19 } { S }
      { 20 } { T }
      { 21 } { U }
      { 22 } { V }
      { 23 } { W }
      { 24 } { X }
      { 25 } { Y }
      { 26 } { Z }
    }
    {#1}
}
\cs_new:Npn \int_convert_to_base_ten:nn #1#2 {
  \int_eval:n
    {
      \int_get_sign:n {#1}
      \exp_args:Nf \int_convert_to_base_ten_aux:nn
        { \int_get_digits:n {#1} } {#2}
    }
}
\cs_new:Npn \int_convert_to_base_ten_aux:nn #1#2 {
  \int_convert_to_base_ten_aux:nnN { 0 } { #2 } #1 \q_nil
}
\cs_new:Npn \int_convert_to_base_ten_aux:nnN #1#2#3 {
  \quark_if_nil:NTF #3
    {#1}
    {
      \exp_args:Nf \int_convert_to_base_ten_aux:nnN
        { \int_eval:n { #1 * #2 + \int_convert_to_base_ten_aux:N #3 } }
        {#2}
    }
}
\cs_new:Npn \int_convert_to_base_ten_aux:N #1 {
  \int_compare:nNnTF { `#1 } < { 58 }
    {#1}
    {
      \int_eval:n
        { `#1 - \int_compare:nNnTF { `#1 } < { 91 } { 55 } { 87 } }
    }
}
\cs_new:Npn \int_get_sign_and_digits:n #1 {
  \int_get_sign_and_digits_aux:nNNN {#1}
    \c_true_bool \c_true_bool \c_true_bool
}
\cs_new:Npn \int_get_sign:n #1 {
  \int_get_sign_and_digits_aux:nNNN {#1}
    \c_true_bool \c_true_bool \c_false_bool
}
\cs_new:Npn \int_get_digits:n #1 {
  \int_get_sign_and_digits_aux:nNNN {#1}
    \c_true_bool \c_false_bool \c_true_bool
}
\cs_new:Npn \int_get_sign_and_digits_aux:nNNN #1#2#3#4 {
  \tl_if_head_eq_charcode:fNTF {#1} -
    {
      \bool_if:NTF #2
        {
          \int_get_sign_and_digits_aux:oNNN
            { \use_none:n #1 } \c_false_bool #3#4
        }
        {
          \int_get_sign_and_digits_aux:oNNN
            { \use_none:n #1 } \c_true_bool #3#4
        }
    }
    {
      \tl_if_head_eq_charcode:fNTF {#1} +
        { \int_get_sign_and_digits_aux:oNNN { \use_none:n #1 } #2#3#4 }
        {
          \bool_if:NT #3 { \bool_if:NF #2 - }
          \bool_if:NT #4 {#1}
        }
    }
}
\cs_generate_variant:Nn \int_get_sign_and_digits_aux:nNNN { o }
\cs_new:Npn \int_from_binary:n #1 {
  \int_convert_to_base_ten:nn {#1} { 2 }
}
\cs_new:Npn \int_from_hexadecimal:n #1 {
  \int_convert_to_base_ten:nn {#1} { 16 }
}
\cs_new:Npn \int_from_octal:n #1 {
  \int_convert_to_base_ten:nn {#1} { 8 }
}
\cs_new:Npn \int_to_binary:n #1 {
  \int_convert_from_base_ten:nn {#1} { 2 }
}
\cs_new:Npn \int_to_hexadecimal:n #1 {
  \int_convert_from_base_ten:nn {#1} { 16 }
}
\cs_new:Npn \int_to_octal:n #1 {
  \int_convert_from_base_ten:nn {#1} { 8 }
}
\cs_new:Npn \int_from_alph:n #1 {
  \int_eval:n
    {
      \int_get_sign:n {#1}
      \exp_args:Nf \int_from_alph_aux:n
        { \int_get_digits:n {#1} }
    }
}
\cs_new:Npn \int_from_alph_aux:n #1 {
  \int_from_alph_aux:nN { 0 } #1 \q_nil
}
\cs_new:Npn \int_from_alph_aux:nN #1#2 {
  \quark_if_nil:NTF #2
    {#1}
    {
      \exp_args:Nf \int_from_alph_aux:nN
        { \int_eval:n { #1 * 26 + \int_from_alph_aux:N #2 } }
    }
}
\cs_new:Npn \int_from_alph_aux:N #1 {
  \int_eval:n
    { `#1 - \int_compare:nNnTF { `#1 } < { 91 } { 64 } { 96 } }
}
\prg_set_conditional:Npnn \int_compare:n #1{p,TF,T,F}{
  \exp_after:wN \int_compare_auxi:w \int_value:w
    \int_eval:w #1\q_stop
}
\cs_set:Npn \int_compare_auxi:w #1#2\q_stop{
   \exp_after:wN   \int_compare_auxii:w \tex_romannumeral:D
   \if:w #1- \else: -\fi: #1#2 \q_mark #1#2 \q_stop
}
\cs_set:Npn \int_compare_auxii:w #1#2#3\q_mark{
   \use:c{
     int_compare_
     #1  \if_meaning:w =#2 =  \fi:
     :w}
}
\cs_set:cpn {int_compare_=:w} #1=#2\q_stop{
  \if_int_compare:w #1=\int_eval:w #2 \int_eval_end:
    \prg_return_true: \else: \prg_return_false: \fi:
}
\cs_set:cpn {int_compare_==:w} #1==#2\q_stop{
  \if_int_compare:w #1=\int_eval:w #2 \int_eval_end:
  \prg_return_true: \else: \prg_return_false: \fi:
}
\cs_set:cpn {int_compare_!=:w} #1!=#2\q_stop{
  \if_int_compare:w #1=\int_eval:w #2 \int_eval_end:
  \prg_return_false: \else: \prg_return_true: \fi:
}
\cs_set:cpn {int_compare_<:w} #1<#2\q_stop{
  \if_int_compare:w #1<\int_eval:w #2 \int_eval_end:
  \prg_return_true: \else: \prg_return_false: \fi:
}
\cs_set:cpn {int_compare_>:w} #1>#2\q_stop{
  \if_int_compare:w #1>\int_eval:w #2 \int_eval_end:
  \prg_return_true: \else: \prg_return_false: \fi:
}
\cs_set:cpn {int_compare_<=:w} #1<=#2\q_stop{
  \if_int_compare:w #1>\int_eval:w #2 \int_eval_end:
  \prg_return_false: \else: \prg_return_true: \fi:
}
\cs_set:cpn {int_compare_>=:w} #1>=#2\q_stop{
  \if_int_compare:w #1<\int_eval:w #2 \int_eval_end:
  \prg_return_false: \else: \prg_return_true: \fi:
}
\prg_set_conditional:Npnn \int_compare:nNn #1#2#3{p}{
  \if_int_compare:w \int_eval:w #1 #2 \int_eval:w #3
  \int_eval_end:
  \prg_return_true: \else: \prg_return_false: \fi:
}
\cs_set_nopar:Npn \int_compare:nNnT #1#2#3 {
  \tex_ifnum:D \etex_numexpr:D #1 #2 \etex_numexpr:D #3 \scan_stop:
    \tex_expandafter:D \use:n
  \tex_else:D
    \tex_expandafter:D \use_none:n
  \tex_fi:D
}
\cs_set_nopar:Npn \int_compare:nNnF #1#2#3 {
  \tex_ifnum:D \etex_numexpr:D #1 #2 \etex_numexpr:D #3 \scan_stop:
    \tex_expandafter:D \use_none:n
  \tex_else:D
    \tex_expandafter:D \use:n
  \tex_fi:D
}
\cs_set_nopar:Npn \int_compare:nNnTF #1#2#3 {
  \tex_ifnum:D \etex_numexpr:D #1 #2 \etex_numexpr:D #3 \scan_stop:
    \tex_expandafter:D \use_i:nn
  \tex_else:D
    \tex_expandafter:D \use_ii:nn
  \tex_fi:D
}
\cs_set:Npn \int_abs:n #1{
  \int_value:w
  \if_int_compare:w \int_eval:w #1<\c_zero
    -
  \fi:
  \int_eval:w #1\int_eval_end:
}
\cs_set:Npn \int_max:nn #1#2{
  \int_value:w \int_eval:w
    \if_int_compare:w
      \int_eval:w #1>\int_eval:w #2\int_eval_end:
      #1
    \else:
      #2
    \fi:
  \int_eval_end:
}
\cs_set:Npn \int_min:nn #1#2{
  \int_value:w \int_eval:w
    \if_int_compare:w
      \int_eval:w #1<\int_eval:w #2\int_eval_end:
      #1
    \else:
      #2
    \fi:
  \int_eval_end:
}
\cs_set:Npn \int_div_truncate:nn #1#2 {
  \int_value:w \int_eval:w
    \if_int_compare:w \int_eval:w #1 = \c_zero
      0
    \else:
      (#1
      \if_int_compare:w \int_eval:w #1 < \c_zero
        \if_int_compare:w \int_eval:w #2 < \c_zero
          -( #2 +
        \else:
          +( #2 -
        \fi:
      \else:
        \if_int_compare:w \int_eval:w #2 < \c_zero
          +( #2 +
        \else:
          -( #2 -
        \fi:
      \fi:
      1)/2)
    \fi:
    /(#2)
  \int_eval_end:
}
\cs_set:Npn \int_div_round:nn #1#2 {\int_eval:n{(#1)/(#2)}}
\cs_set:Npn \int_mod:nn #1#2 {
  \int_value:w
    \int_eval:w
    #1 - \int_div_truncate:nn {#1}{#2} * (#2)
    \int_eval_end:
}
\prg_set_conditional:Npnn \int_if_odd:n #1 {p,TF,T,F} {
  \if_int_odd:w \int_eval:w #1\int_eval_end:
    \prg_return_true: \else: \prg_return_false: \fi:
}
\prg_set_conditional:Npnn \int_if_even:n #1 {p,TF,T,F} {
  \if_int_odd:w \int_eval:w #1\int_eval_end:
    \prg_return_false: \else: \prg_return_true: \fi:
}
\cs_set:Npn \int_while_do:nn #1#2{
  \int_compare:nT {#1}{#2 \int_while_do:nn {#1}{#2}}
}
\cs_set:Npn \int_until_do:nn #1#2{
  \int_compare:nF {#1}{#2 \int_until_do:nn {#1}{#2}}
}
\cs_set:Npn \int_do_while:nn #1#2{
  #2 \int_compare:nT {#1}{\int_do_while:nNnn {#1}{#2}}
}
\cs_set:Npn \int_do_until:nn #1#2{
  #2 \int_compare:nF {#1}{\int_do_until:nn {#1}{#2}}
}
\cs_set:Npn \int_while_do:nNnn #1#2#3#4{
  \int_compare:nNnT {#1}#2{#3}{#4 \int_while_do:nNnn {#1}#2{#3}{#4}}
}
\cs_set:Npn \int_until_do:nNnn #1#2#3#4{
  \int_compare:nNnF {#1}#2{#3}{#4 \int_until_do:nNnn {#1}#2{#3}{#4}}
}
\cs_set:Npn \int_do_while:nNnn #1#2#3#4{
  #4 \int_compare:nNnT {#1}#2{#3}{\int_do_while:nNnn {#1}#2{#3}{#4}}
}
\cs_set:Npn \int_do_until:nNnn #1#2#3#4{
  #4 \int_compare:nNnF {#1}#2{#3}{\int_do_until:nNnn {#1}#2{#3}{#4}}
}
\cs_new_protected_nopar:Npn \int_const:Nn #1#2 {
  \int_compare:nTF { #2 > \c_minus_one }
    {
      \int_compare:nTF { #2 > \c_max_register_int }
        {
          \int_new:N #1
          \int_gset:Nn #1 {#2}
        }
        {
          \chk_if_free_cs:N #1
          \tex_global:D \tex_mathchardef:D #1 =
            \etex_numexpr:D #2 \scan_stop:
        }
    }
    {
      \int_new:N #1
      \int_gset:Nn #1 {#2}
    }
}
\cs_generate_variant:Nn \int_const:Nn { c }
 %% \tex_countdef:D \c_minus_one = 10 \scan_stop:
 %% \c_minus_one = -1 \scan_stop:        %% in l3basics
\int_const:Nn \c_one    {1}
\int_const:Nn \c_two    {2}
\int_const:Nn \c_three  {3}
\int_const:Nn \c_four   {4}
\int_const:Nn \c_five   {5}
\int_const:Nn \c_eight  {8}
\int_const:Nn \c_nine   {9}
\int_const:Nn \c_ten      {10}
\int_const:Nn \c_eleven   {11}
\int_const:Nn \c_thirteen {13}
\int_const:Nn \c_fourteen {14}
\int_const:Nn \c_fifteen  {15}
 %% \tex_chardef:D \c_sixteen    = 16\scan_stop: %% in l3basics
\int_const:Nn \c_thirty_two {32}
\int_const:Nn \c_hundred_one          {101}
\int_const:Nn \c_twohundred_fifty_five{255}
\int_const:Nn \c_twohundred_fifty_six {256}
\int_const:Nn \c_thousand             {1000}
\int_const:Nn \c_ten_thousand         {10000}
\int_const:Nn \c_ten_thousand_one     {10001}
\int_const:Nn \c_ten_thousand_two     {10002}
\int_const:Nn \c_ten_thousand_three   {10003}
\int_const:Nn \c_ten_thousand_four    {10004}
\int_const:Nn \c_twenty_thousand      {20000}
\int_const:Nn \c_max_int {2147483647}
\int_const:cn { c_int_from_roman_i_int } { 1 }
\int_const:cn { c_int_from_roman_v_int } { 5 }
\int_const:cn { c_int_from_roman_x_int } { 10 }
\int_const:cn { c_int_from_roman_l_int } { 50 }
\int_const:cn { c_int_from_roman_c_int } { 100 }
\int_const:cn { c_int_from_roman_d_int } { 500 }
\int_const:cn { c_int_from_roman_m_int } { 1000 }
\int_const:cn { c_int_from_roman_I_int } { 1 }
\int_const:cn { c_int_from_roman_V_int } { 5 }
\int_const:cn { c_int_from_roman_X_int } { 10 }
\int_const:cn { c_int_from_roman_L_int } { 50 }
\int_const:cn { c_int_from_roman_C_int } { 100 }
\int_const:cn { c_int_from_roman_D_int } { 500 }
\int_const:cn { c_int_from_roman_M_int } { 1000 }
\int_new:N \g_tl_inline_level_int
\int_new:N\g_prg_inline_level_int
\cs_set_eq:NN \intexpr_value:w \int_value:w
\cs_set_eq:NN \intexpr_eval:w \int_eval:w
\cs_set_eq:NN \intexpr_eval_end: \int_eval_end:
\cs_set_eq:NN \if_intexpr_compare:w \if_int_compare:w
\cs_set_eq:NN \if_intexpr_odd:w \if_int_odd:w
\cs_set_eq:NN \if_intexpr_case:w \if_case:w
\cs_set_eq:NN \intexpr_eval:n \int_eval:n

\cs_set_eq:NN \intexpr_compare_p:n \int_compare_p:n
\cs_set_eq:NN \intexpr_compare:nTF \int_compare:nTF
\cs_set_eq:NN \intexpr_compare:nT  \int_compare:nT
\cs_set_eq:NN \intexpr_compare:nF  \int_compare:nF

\cs_set_eq:NN \intexpr_compare_p:nNn \int_compare_p:nNn
\cs_set_eq:NN \intexpr_compare:nNnTF \int_compare:nNnTF
\cs_set_eq:NN \intexpr_compare:nNnT  \int_compare:nNnT
\cs_set_eq:NN \intexpr_compare:nNnF  \int_compare:nNnF

\cs_set_eq:NN \intexpr_abs:n  \int_abs:n
\cs_set_eq:NN \intexpr_max:nn \int_max:nn
\cs_set_eq:NN \intexpr_min:nn \int_min:nn

\cs_set_eq:NN \intexpr_div_truncate:nn \int_div_truncate:nn
\cs_set_eq:NN \intexpr_div_round:nn    \int_div_round:nn
\cs_set_eq:NN \intexpr_mod:nn          \int_mod:nn

\cs_set_eq:NN \intexpr_if_odd_p:n \int_if_odd_p:n
\cs_set_eq:NN \intexpr_if_odd:nTF \int_if_odd:nTF
\cs_set_eq:NN \intexpr_if_odd:nT  \int_if_odd:nT
\cs_set_eq:NN \intexpr_if_odd:nF  \int_if_odd:nF

\cs_set_eq:NN \intexpr_if_even_p:n \int_if_even_p:n
\cs_set_eq:NN \intexpr_if_even:nTF \int_if_even:nTF
\cs_set_eq:NN \intexpr_if_even:nT  \int_if_even:nT
\cs_set_eq:NN \intexpr_if_even:nF  \int_if_even:nF

\cs_set_eq:NN \intexpr_while_do:nn \int_while_do:nn
\cs_set_eq:NN \intexpr_until_do:nn \int_until_do:nn
\cs_set_eq:NN \intexpr_do_while:nn \int_do_while:nn
\cs_set_eq:NN \intexpr_do_until:nn \int_do_until:nn

\cs_set_eq:NN \intexpr_while_do:nNnn \int_while_do:nNnn
\cs_set_eq:NN \intexpr_until_do:nNnn \int_until_do:nNnn
\cs_set_eq:NN \intexpr_do_while:nNnn \int_do_while:nNnn
\cs_set_eq:NN \intexpr_do_until:nNnn \int_do_until:nNnn
%% 
%%
%% End of file `l3int.sty'.
