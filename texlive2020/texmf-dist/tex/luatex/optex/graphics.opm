%% This is part of OpTeX project, see http://petr.olsak.net/optex

\_codedecl \inspic {Graphics <2020-03-18>} % preloaded in format

   \_doc -----------------------------
   `\inspic` accepts old syntax `\inspic <filename><space>`
   or new syntax `\inspic{<filename>}`. So, we need to define
   two auxiliary macros `\_inspicA` and `\_inspicB`.

   You can include more `\pdfximage` parameters (like `page=`)
   in the `\_picparams` macro.

   All `\inspic` macros are surrounded in `\hbox` in order user can
   write `\moveright\inspic ...` or something similar.
   \_cod \_fin -----------------------

\_def\_inspic{\_hbox\_bgroup\_isnextchar\_bgroup\_inspicB\_inspicA}
\_def\_inspicA #1 {\_inspicB {#1}}
\_def\_inspicB #1{%
   \_pdfximage \_ifdim\_picwidth=0pt  \_else width\_picwidth\_fi 
               \_ifdim\_picheight=0pt \_else height\_picheight\_fi 
               \_picparams {\_the\_picdir#1}%
   \_pdfrefximage\_pdflastximage\_egroup}

\_def\_picparams{}

\_public \inspic ;

   \_doc -----------------------------
   Inkscape is able to save a picture to `*.pdf` file and labels for the ficture
   to `*.pdf_tex` file. The second file is in \LaTeX/ format and it is intended to read 
   immediately it after `*.pdf` in included in order to place labels of this ficture in
   the same font as document is printed. 
   We need to read this \LaTeX/ file by plain \TeX/ macros when `\inkinspic` is used. 
   These macros are stored in the `\_inkdefs` toknes list and it is used
   localy in the group. The solution is borrowed from OPmac trick 0032. 
   \_cod -----------------------------

\_def\_inkinspic{\_hbox\_bgroup\_isnextchar\_bgroup\_inkinspicB\_inkinspicA}
\_def\_inkinspicA #1 {\_inkinspicB {#1}}
\_def\_inkinspicB #1{%
  \_ifdim\_picwidth=0pt \_setbox0=\_hbox{\_inspic{#1}}\_picwidth=\_wd0 \_fi
  \_the\_inkdefs
  \_opinput {\_the\_picdir #1_tex}% file with labels
  \_egroup}

\_newtoks\_inkdefs  \_inkdefs={% 
  \_def\makeatletter#1\makeatother{}% 
  \_def\includegraphics[#1]#2{\_inkscanpage#1,page=,\_end \_inspic{#2}\_hss}% 
  \_def\_inkscanpage#1page=#2,#3\_end{\_ifx,#2,\_else\_def\_picparams{page#2}\_fi}% 
  \_def\put(#1,#2)#3{\_nointerlineskip\_vbox to0pt{\_vss\_hbox to0pt{\_kern#1\_picwidth 
      \_pdfsave\_hbox to0pt{#3}\_pdfrestore\_hss}\_kern#2\_picwidth}}% 
  \_def\begin#1{\_csname _begin#1\_endcsname}%
  \_def\_beginpicture(#1,#2){\_vbox\_bgroup
      \_hbox to\_picwidth{}\_kern#2\_picwidth \_def\end##1{\_egroup}}%
  \_def\_begintabular[#1]#2#3\end#4{%
      \_vtop{\_def\\{\_cr}\_tabiteml{}\_tabitemr{}\_table{#2}{#3}}}%
  \_def\color[#1]#2{\_scancolor #2,}% 
  \_def\_scancolor#1,#2,#3,{\_pdfliteral{#1 #2 #3 rg}}% 
  \_def\makebox(#1)[#2]#3{\_hbox to0pt{\_csname _mbx:#2\_endcsname{#3}}}% 
  \_sdef{_mbx:lb}#1{#1\_hss}\_sdef{_mbx:rb}#1{\_hss#1}\_sdef{_mbx:b}#1{\_hss#1\_hss}% 
  \_sdef{_mbx:lt}#1{#1\_hss}\_sdef{_mbx:rt}#1{\_hss#1}\_sdef{_mbx:t}#1{\_hss#1\_hss}% 
  \_def\rotatebox#1#2{\_pdfrotate{#1}#2}%
  \_def\lineheight#1{}%
  \_def\setlength#1#2{}%
}
\_public \inkinspic ;

   \_doc ----------------------------
   `\pdfscale` and `\pdfrotate` macros are implemented by `\pdfsetmatrix`
   primitive. or rotating we need to knos values of sin, cos function.
   We use Lua code for this.
   \_cod ----------------------------

\_def\_pdfscale#1#2{\_pdfsetmatrix{#1 0 0 #2}}

\_def\_gonfunc#1#2{%
   \_directlua{tex.print(string.format('\_pcent.4f',math.#1(3.14159265*(#2)/180)))}%
}
\_def\_sin{\_gonfunc{sin}}
\_def\_cos{\_gonfunc{cos}}

\_def\_pdfrotate#1{\_pdfsetmatrix{\_cos{#1} \_sin{#1} \_sin{(#1)-180} \_cos{#1}}}

\_public \pdfscale \pdfrotate ;

   \_doc -----------------------------
   The `\transformbox` is copied from OPmac trick 0046. The `\rotbox` is a
   combination of `\rotsimple` from OPmac trick 0101 and `\transformbox`.
   Note, that `\rotbox{-90}` puts the rotated text to the height of the outer 
   box (depth is zero) because code from `\rotsimple` is precessed. 
   But `\rotbox{-90.0}` puts the rotated text to
   the depth of the outer box (height is zero) because `\transformbox` is
   processed. 
   \_cod -----------------------------

\_def\_multiplyMxV #1 #2 #3 #4 {% matrix * (vvalX, vvalY) 
   \_tmpdim = #1\_vvalX \_advance\_tmpdim by #3\_vvalY 
   \_vvalY  = #4\_vvalY \_advance\_vvalY  by #2\_vvalX 
   \_vvalX = \_tmpdim 
} 
\_def\_multiplyMxM #1 #2 #3 #4 {% currmatrix := currmatrix * matrix 
   \_vvalX=#1pt \_vvalY=#2pt \_ea\_multiplyMxV \_currmatrix 
   \_edef\_tmpb{\_ea\_ignorept\_the\_vvalX\_space \_ea\_ignorept\_the\_vvalY}% 
   \_vvalX=#3pt \_vvalY=#4pt \_ea\_multiplyMxV \_currmatrix 
   \_edef\_currmatrix{\_tmpb\_space 
      \_ea\_ignorept\_the\_vvalX\_space \_ea\_ignorept\_the\_vvalY\_space}% 
} 
\_def\_transformbox#1#2{\_hbox{\_setbox0=\_hbox{{#2}}%
   \_dimendef\_vvalX 11 \_dimendef\_vvalY 12 % we use these variables
   \_dimendef\_newHt 13 \_dimendef\_newDp 14 % only in this group
   \_dimendef\_newLt 15 \_dimendef\_newRt 16 
   \_preptransform{#1}% 
   \_kern-\_newLt \_vrule height\_newHt depth\_newDp width0pt 
   \_setbox0=\_hbox{\_box0}\_ht0=0pt \_dp0=0pt 
   \_pdfsave#1\_rlap{\_box0}\_pdfrestore \_kern\_newRt}% 
} 
\_def\_preptransform #1{\_def\_currmatrix{1 0 0 1 }% 
   \_def\_pdfsetmatrix##1{\_edef\_tmpb{##1 }\_ea\_multiplyMxM \_tmpb\_unskip}%
   \_let\pdfsetmatrix=\_pdfsetmatrix #1% 
   \_setnewHtDp 0pt  \_ht0  \_setnewHtDp 0pt  -\_dp0 
   \_setnewHtDp \_wd0 \_ht0  \_setnewHtDp \_wd0 -\_dp0 
   \_protected\_def \_pdfsetmatrix {\_pdfextension setmatrix}%
   \_let\pdfsetmatrix=\_pdfsetmatrix
} 
\_def\_setnewHtDp #1 #2 {% 
   \_vvalX=#1\_relax \_vvalY=#2\_relax \_ea\_multiplyMxV \_currmatrix 
   \_ifdim\_vvalX<\_newLt \_newLt=\_vvalX \_fi \_ifdim\_vvalX>\_newRt \_newRt=\_vvalX \_fi 
   \_ifdim\_vvalY>\_newHt \_newHt=\_vvalY \_fi \_ifdim-\_vvalY>\_newDp \_newDp=-\_vvalY \_fi 
} 

\_def\_rotbox#1#2{%
   \_isequal{90}{#1}\_iftrue \_rotboxA{#1}{\_kern\_ht0 \_tmpdim=\_dp0}{\_vfill}{#2}%
   \_else \_isequal{-90}{#1}\_iftrue \_rotboxA{#1}{\_kern\_dp0 \_tmpdim=\_ht0}{}{#2}%
   \_else \_transformbox{\_pdfrotate{#1}}{#2}%
   \_fi \_fi
}
\_def\_rotboxA #1#2#3#4{\_hbox{\_setbox0=\hbox{{#4}}#2%
   \_vbox to\_wd0{#3\_wd0=0pt \_dp0=0pt \_ht0=0pt
                  \_pdfsave\_pdfrotate{#1}\_box0\_pdfrestore\vfil}%
   \_kern\_tmpdim
}}
\_public \transformbox \rotbox ;

   \_doc ---------------------------
   The `\_scantwodimens` scans two objects with the syntactic rule <dimen>
   and returns `{<number>}{<number>}` in sp unit.

   The `\puttext <down> <right>{<text>}` puts the <text> to desired place:
   From current point moves <down> and <right>, puts the <text> and returns
   back. The cuuren tpoint is unchanged after this macro ends.
   
   The  `\putpic <down> <right> <width> <height> {<image-file>}`
   does `\puttext` with the image scaled to desired <width> and <height>.
   If <with> or <height> is zero, natural dimension is used.
   The `\nospec` is a shortcut to such natural dimension.
   \_cod ---------------------------

\_def\_scantwodimens{%
   \_directlua{tex.print(string.format('{\_pcent d}{\_pcent d}',
               token.scan_dimen(),token.scan_dimen{}))}%
}

\_def\_puttext{\_ea\_ea\_ea\_puttextA\_scantwodimens}
\_def\_puttextA#1#2#3{\_setbox0=\_hbox{{#3}}\_dimen1=#1sp \_dimen2=#2sp \_puttextB}
\_def\_puttextB{%
   \_ifvmode 
      \_ifdim\_prevdepth>0pt \_vskip-\_prevdepth \_relax \_fi 
      \_nointerlineskip 
   \_fi
   \_wd0=0pt \_ht0=0pt \_dp0=0pt
   \_vbox to0pt{\_kern\_dimen1 \_hbox to0pt{\_kern\_dimen2 \_box0\_hss}\_vss}}

\_def\_putpic{\_ea\_ea\_ea\_putpicA\_scantwodimens}
\_def\_putpicA#1#2{\_dimen1=#1sp \_dimen2=#2sp \_ea\_ea\_ea\_putpicB\_scantwodimens}
\_def\_putpicB#1#2#3{\_setbox0=\_hbox{\_picwidth=#1sp \_picheight=#2sp \_inspic{#3}}\_puttextB}

\_newbox\_bgbox
\_def\_backgroundpic#1{%
   \_setbox\_bgbox=\_hbox{\_picwidth=\_pdfpagewidth \_picheight=\_pdfpageheight \_inspic{#1}}%
   \_pgbackground={\_copy\_bgbox}
}
\_def\nospec{0pt}
\_public \puttext \putpic \backgroundpic ;

\_endcode % -------------------------------------

