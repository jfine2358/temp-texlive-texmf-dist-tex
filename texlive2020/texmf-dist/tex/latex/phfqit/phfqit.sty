%%
%% This is file `phfqit.sty',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% phfqit.dtx  (with options: `package')
%% 
%% This is a generated file.
%% 
%% Copyright (C) 2016 by Philippe Faist, philippe.faist@bluewin.ch
%% 
%% This file may be distributed and/or modified under the conditions of
%% the LaTeX Project Public License, either version 1.3 of this license
%% or (at your option) any later version.  The latest version of this
%% license is in:
%% 
%%    http://www.latex-project.org/lppl.txt
%% 
%% and version 1.3 or later is part of all distributions of LaTeX version
%% 2005/12/01 or later.
%% 
\NeedsTeXFormat{LaTeX2e}[2005/12/01]
\ProvidesPackage{phfqit}
    [2017/08/16 v2.0 phfqit package]
\RequirePackage{calc}
\RequirePackage{etoolbox}
\RequirePackage{amsmath}
\RequirePackage{dsfont}
\RequirePackage{mathrsfs}
\RequirePackage{mathtools}
\RequirePackage{xparse}
\RequirePackage{xkeyval}
\RequirePackage{kvoptions}
\newcommand{\Hs}{\mathscr{H}}
\newcommand{\Ident}{\mathds{1}}
\def\IdentProc{%
  \phfqit@parsesizearg\phfqit@IdentProc@maybeA%
}
\newcommand\phfqit@IdentProc@maybeA[1][]{%
  \def\phfqit@IdentProc@val@A{#1}%
  \phfqit@IdentProc@maybeB%
}
\newcommand\phfqit@IdentProc@maybeB[1][]{%
  \def\phfqit@IdentProc@val@B{#1}%
  \phfqit@IdentProc@arg%
}
\def\phfqit@IdentProc@arg#1{%
  \def\phfqit@IdentProc@val@arg{#1}%
  \edef\@tmp@args{%
    {\expandonce{\phfqit@IdentProc@val@A}}%
    {\expandonce{\phfqit@IdentProc@val@B}}%
    {\expandonce{\phfqit@IdentProc@val@arg}}%
  }%
  \expandafter\phfqit@IdentProc@do\@tmp@args%
}
\def\phfqit@IdentProc@do#1#2#3{%
  \operatorname{id}_{#1\notblank{#2}{\to #2}{}}%
  \notblank{#3}{\expandafter\phfqitParens\phfqit@val@sizearg{#3}}{}%
}
\def\ee^#1{e^{#1}} % we could imagine that in inlines, we replace this by exp()...
\DeclareMathOperator{\tr}{tr}
\DeclareMathOperator{\supp}{supp}
\DeclareMathOperator{\rank}{rank}
\DeclareMathOperator{\linspan}{span}
\DeclareMathOperator{\spec}{spec}
\DeclareMathOperator{\diag}{diag}
\let\phfqit@Re\Re
\DeclareMathOperator{\phfqit@Realpart}{Re}%
\let\phfqit@Im\Im
\DeclareMathOperator{\phfqit@Imagpart}{Im}%
\DeclareMathOperator{\poly}{poly}
\newcommand\bit[1]{\texttt{#1}}
\newcommand\bitstring[1]{\phfqit@bitstring{#1}}
\def\phfqit@bitstring#1{%
  \begingroup%
  \setlength{\phfqit@len@bit}{\maxof{\widthof{\bit{0}}}{\widthof{\bit{1}}}}%
  \phfqitBitstringFormat{\phfqit@bitstring@#1\phfqit@END}%
  \endgroup%
}
\def\phfqit@bitstring@#1#2\phfqit@END{%
  \makebox[\phfqit@len@bit][c]{\phfqitBitstringFormatBit{#1}}%
  \if\relax\detokenize\expandafter{#2}\relax%
  \else%
    \phfqitBitstringSep\phfqit@bitstring@#2\phfqit@END%
  \fi%
}
\newlength\phfqit@len@bit
\newcommand\phfqitBitstringSep{\hspace{0.3ex}}
\newcommand\phfqitBitstringFormat[1]{\ensuremath{\underline{\overline{#1}}}}
\def\phfqitBitstringFormatBit{\bit}
\DeclareRobustCommand\gate[1]{\ifmmode\textsc{\lowercase{#1}}%
  \else{\rmfamily\textsc{\lowercase{#1}}}\fi}
\newcommand{\AND}{\gate{And}}
\newcommand{\XOR}{\gate{Xor}}
\newcommand{\CNOT}{\gate{C-Not}}
\newcommand{\NOT}{\gate{Not}}
\newcommand{\NOOP}{\gate{No-Op}}
\def\uu(#1){\phfqit@fmtLieAlgebra{u}(#1)}
\def\UU(#1){\phfqit@fmtGroup{U}(#1)}
\def\su(#1){\phfqit@fmtLieAlgebra{su}(#1)}
\def\SU(#1){\phfqit@fmtGroup{SU}(#1)}
\def\so(#1){\phfqit@fmtLieAlgebra{so}(#1)}
\def\SO(#1){\phfqit@fmtGroup{SO}(#1)}
\def\SN(#1){\mathrm{S}_{#1}}
\def\phfqit@fmtLieAlgebra#1{\mathrm{#1}}
\def\phfqit@fmtGroup#1{\mathrm{#1}}
\DeclarePairedDelimiterX\ket[1]{\lvert}{\rangle}{{#1}}
\DeclarePairedDelimiterX\bra[1]{\langle}{\rvert}{{#1}}
\DeclarePairedDelimiterX\braket[2]{\langle}{\rangle}{%
  {#1}\hspace*{0.2ex}\delimsize\vert\hspace*{0.2ex}{#2}%
}
\DeclarePairedDelimiterX\ketbra[2]{\lvert}{\rvert}{%
  {#1}\delimsize\rangle\hspace*{-0.25ex}\delimsize\langle{#2}%
}
\DeclarePairedDelimiterX\proj[1]{\lvert}{\rvert}{%
  {#1}\delimsize\rangle\hspace*{-0.25ex}\delimsize\langle{#1}%
}
\DeclarePairedDelimiterX\matrixel[3]{\langle}{\rangle}{%
  {#1}\hspace*{0.2ex}\delimsize\vert\hspace*{0.2ex}{#2}%
  \hspace*{0.2ex}\delimsize\vert\hspace*{0.2ex}{#3}%
}
\DeclarePairedDelimiterX\dmatrixel[2]{\langle}{\rangle}{%
  {#1}\hspace*{0.2ex}\delimsize\vert\hspace*{0.2ex}{#2}%
  \hspace*{0.2ex}\delimsize\vert\hspace*{0.2ex}{#1}%
}
\DeclarePairedDelimiterX\innerprod[2]{\langle}{\rangle}{%
  {#1},\hspace*{0.2ex}{#2}%
}
\DeclarePairedDelimiterX\abs[1]{\lvert}{\rvert}{{#1}}
\DeclarePairedDelimiterX\avg[1]{\langle}{\rangle}{{#1}}
\DeclarePairedDelimiterX\norm[1]{\lVert}{\rVert}{{#1}}
\def\phfqit@insideinterval#1#2{{#1\mathclose{},\mathopen{}#2}}
\DeclarePairedDelimiterX\intervalc[2]{[}{]}{\phfqit@insideinterval{#1}{#2}}
\DeclarePairedDelimiterX\intervalo[2]{]}{[}{\phfqit@insideinterval{#1}{#2}}
\DeclarePairedDelimiterX\intervalco[2]{[}{[}{\phfqit@insideinterval{#1}{#2}}
\DeclarePairedDelimiterX\intervaloc[2]{]}{]}{\phfqit@insideinterval{#1}{#2}}
\def\phfqit@parsesizearg#1{%
  \begingroup%
  \mathcode`\`="0060\relax%
  \gdef\phfqit@val@sizearg{}%
  \def\phfqit@tmp@contwithsize{\phfqit@parsesizearg@withsize{#1}}%
  \@ifnextchar`{\phfqit@tmp@contwithsize}{\endgroup#1}%
}
\def\phfqit@parsesizearg@withsize#1`#2{%
  \def\phfqit@tmp@x{#2}%
  \def\phfqit@tmp@star{*}%
  \ifx\phfqit@tmp@x\phfqit@tmp@star%
    \gdef\phfqit@val@sizearg{*}%
    \def\phfqit@tmp@cont{\endgroup#1}%
    \expandafter\phfqit@tmp@cont%
  \else%
    \gdef\phfqit@val@sizearg{[#2]}%
    \def\phfqit@tmp@cont{\endgroup#1}%
    \expandafter\phfqit@tmp@cont%
  \fi%
}
\DeclarePairedDelimiterX\phfqitParens[1]{(}{)}{#1}
\DeclarePairedDelimiterX\phfqitSquareBrackets[1]{[}{]}{#1}
\DeclarePairedDelimiterX\phfqitCurlyBrackets[1]{\{}{\}}{#1}
\newcommand\QitObject[1]{%
  \begingroup%
    \preto\QitObjectDone{\endgroup}%
    \QitObjectInit%
    \csname QitObj@reg@#1@initdefs\endcsname%
%%\message{DEBUG: \detokenize{\QitObject{#1}}}%
    \def\QitObj@args{}%
    \def\qitobjParseDone{\QitObj@proceedToRender{#1}}%
    \def\qitobjDone{\QitObjectDone}%
    \csname QitObj@reg@#1@parse\endcsname%
}
\def\DefineQitObject#1#2#3{%
  \DefineTunedQitObject{#1}{#2}{#3}{}{}%
}%
\def\DefineTunedQitObject#1#2#3#4#5{%
  \csdef{#1}{\QitObject{#1}#4}%
  \expandafter\robustify\csname #1\endcsname%
  \cslet{QitObj@reg@#1@parse}#2%
  \cslet{QitObj@reg@#1@render}#3%
  \csdef{QitObj@reg@#1@initdefs}{#5}%
}
\def\qitobjAddArg#1{%
  \appto\QitObj@args{{#1}}%
}
\def\qitobjAddArgx#1{%
  \expandafter\qitobjAddArg\expandafter{#1}%
}
\def\qitobjParseDone{}
\def\qitobjDone{}
\def\QitObjectDone{}
\def\QitObjectInit{}
\def\QitObj@proceedToRender#1{%
%%\message{DEBUG: Rendering #1|\detokenize\expandafter{\QitObj@args}|}%
  \expandafter\def\expandafter\x\expandafter{%
    \csname QitObj@reg@#1@render\endcsname}%
  \expandafter\x\QitObj@args%
}
\def\HbaseParse#1#2{%
  \qitobjAddArg{#1}%
  \qitobjAddArg{#2}%
  \phfqit@parsesizearg\HbaseParse@%
}
\newcommand\HbaseParse@[1][]{%
  \qitobjAddArgx{\phfqit@val@sizearg}%
  \qitobjAddArg{#1}%
  \HbaseParse@@%
}
\newcommand\HbaseParse@@[2][]{%
  \qitobjAddArg{#1}%
  \qitobjAddArg{#2}%
  \HbaseParse@@@%
}
\newcommand\HbaseParse@@@[1][]{%
  \qitobjAddArg{#1}%
  \qitobjParseDone%
}
\def\HbaseRender#1#2#3#4#5#6#7{%
%%\message{DEBUG: HbaseRender\detokenize{{#1}{#2}{#3}{#4}{#5}{#6}{#7}}}%
  \HbaseRenderSym{#1}_{\HbaseRenderSub{#2}}^{\HbaseRenderSup{#5}}
  \notblank{#4#6#7}{%
    \HbaseRenderContents{#3}{#6}{#7}%
    \HbaseRenderTail{#4}%
  }{}%
  \qitobjDone%
}
\def\HbaseRenderSym#1{#1}%
\def\HbaseRenderSub#1{#1}%
\def\HbaseRenderSup#1{#1}%
\def\HbaseRenderTail#1{_{#1}}%
\newtoks\Hbase@tmp@toks
\def\Hbase@addtoks#1\@Hbase@END@ADD@TOKS{%
  \Hbase@tmp@toks=\expandafter{\the\Hbase@tmp@toks#1}}%
\def\HbaseRenderContents#1#2#3{%
    \Hbase@tmp@toks={#2}%
    \notblank{#3}{%
      \Hbase@addtoks\mathclose{}\,\delimsize\vert\,\mathopen{}%
          #3%
          \@Hbase@END@ADD@TOKS%
    }{}%
    \edef\tmp@args{\unexpanded{#1}{\the\Hbase@tmp@toks}}%
    \expandafter\HbaseRenderContentsInnerParens\tmp@args%
}
\def\HbaseRenderContentsInnerParens{\phfqitParens}
\DefineQitObject{Hbase}{\HbaseParse}{\HbaseRender}
\def\HfnbaseParse#1#2#3{%
  \qitobjAddArg{#1}% H-sym
  \qitobjAddArg{#2}% sub
  \phfqit@parsesizearg{\HfnbaseParse@{#3}}%
}
\NewDocumentCommand{\HfnbaseParse@}{mr()}{%
  \qitobjAddArgx{\phfqit@val@sizearg}% size-arg
  \qitobjAddArg{}% state
  \qitobjAddArg{#1}% epsilon
  \qitobjAddArg{#2}% system--main arg
  \qitobjAddArg{}% cond system
%%\message{DEBUG: Hfnbase args are |\detokenize\expandafter{\QitObj@args}|}%
  \qitobjParseDone%
}
\DefineQitObject{Hfnbase}{\HfnbaseParse}{\HbaseRender}
\def\DbaseParse#1{%
  \qitobjAddArg{#1}% D-sym
  \def\DbaseParse@val@sub{}%
  \def\DbaseParse@val@sup{}%
  \DbaseParse@%
}
\def\DbaseParse@{%
  \@ifnextchar_{\DbaseParse@parsesub}{\DbaseParse@@}%
}
\def\DbaseParse@@{%
  \@ifnextchar^{\DbaseParse@parsesup}{\DbaseParse@@@}%
}
\def\DbaseParse@parsesub_#1{%
  \appto\DbaseParse@val@sub{#1}%
  \DbaseParse@% return to maybe parsing other sub/superscripts
}
\def\DbaseParse@parsesup^#1{%
  \appto\DbaseParse@val@sup{#1}%
  \DbaseParse@% return to maybe parsing other sub/superscripts
}
\def\DbaseParse@@@{%
  \qitobjAddArgx\DbaseParse@val@sub%
  \qitobjAddArgx\DbaseParse@val@sup%
  \phfqit@parsesizearg\DbaseParse@rest%
}
\def\DbaseParse@rest#1#2{%
  \qitobjAddArgx\phfqit@val@sizearg%
  \qitobjAddArg{#1}% rho
  \qitobjAddArg{#2}% Gamma
  \qitobjParseDone%
}
\def\DbaseRender#1#2#3#4#5#6{%
%%\message{DEBUG: DbaseRender\detokenize{{#1}{#2}{#3}{#4}{#5}{#6}}}%
  \DbaseRenderSym{#1}_{\DbaseRenderSub{#2}}^{\DbaseRenderSup{#3}}
  \notblank{#5#6}{%
    \DbaseRenderContents{#4}{#5}{#6}%
  }{}%
  \qitobjDone%
}
\def\DbaseRenderSym#1{#1}%
\def\DbaseRenderSub#1{#1}%
\def\DbaseRenderSup#1{#1}%
\newtoks\Dbase@tmp@toks
\def\Dbase@addtoks#1\@Dbase@END@ADD@TOKS{%
  \Dbase@tmp@toks=\expandafter{\the\Dbase@tmp@toks#1}}%
\def\DbaseRenderContents#1#2#3{%
    \Dbase@tmp@toks={#2}%
    \notblank{#3}{%
      \Dbase@addtoks\mathclose{}\,\delimsize\Vert\,\mathopen{}%
          #3%
          \@Dbase@END@ADD@TOKS%
    }{}%
    \edef\tmp@args{\unexpanded{#1}{\the\Dbase@tmp@toks}}%
    \expandafter\DbaseRenderContentsInnerParens\tmp@args%
}
\def\DbaseRenderContentsInnerParens{\phfqitParens}
\DefineQitObject{Dbase}{\DbaseParse}{\DbaseRender}
\def\DCohbaseParse#1{%
  \qitobjAddArg{#1}% D-sym
  \DCohbaseParse@%
}
\newcommand\DCohbaseParse@[1][]{%
  \qitobjAddArg{#1}% epsilon
  \phfqit@parsesizearg\DCohbaseParse@rest%
}
\def\DCohbaseParse@rest#1#2#3#4#5{%
  % rho, X, X', \Gamma_X, \Gamma_{X'}
  \qitobjAddArgx\phfqit@val@sizearg%
  \DCohbaseParse@parserhosub#1\DCohbaseParse@ENDSTATE{#2}{#3}%
  \qitobjAddArg{#2}%
  \qitobjAddArg{#3}%
  \qitobjAddArg{#4}%
  \qitobjAddArg{#5}%
  \qitobjParseDone%
}
\def\DCohbaseParse@parserhosub{%
  \@ifnextchar*\DCohbaseParse@parserhosub@nosub%
  \DCohbaseParse@parserhosub@wsub%
}
\def\DCohbaseParse@parserhosub@nosub*#1\DCohbaseParse@ENDSTATE#2#3{%
  \qitobjAddArg{#1}% rho
}
\def\DCohbaseParse@parserhosub@wsub#1\DCohbaseParse@ENDSTATE#2#3{%
  \qitobjAddArg{#1_{\begingroup\let\emptysystem\relax%
      \DCohbaseStateSubscripts{#2}{#3}\endgroup}}% all this for "rho" arg
}
\def\DCohbaseStateSubscripts#1#2{%
  #2#1%
}
\def\DCohbaseRender#1#2#3#4#5#6#7#8{%
  %
%%\message{DEBUG: DCohbaseRender here, args are |\detokenize{{#1}{#2}{#3}{#4}{#5}{#6}{#7}{#8}|.}}
  %
  \DCohbaseRenderSym{#1}%
  _{\DCohbaseRenderSystems{#5}{#6}}%
  ^{\DCohbaseRenderSup{#2}}%
  \notblank{#4#7#8}{%
    \DCohbaseRenderContents{#3}{#4}{#7}{#8}%
  }{}%
  \qitobjDone%
}
\def\DCohbaseRenderSym#1{#1}%
\def\DCohbaseRenderSystems#1#2{#1\to #2}%
\def\DCohbaseRenderSup#1{#1}%
\newtoks\DCohbase@tmp@toks
\def\DCohbase@addtoks#1\@DCohbase@END@ADD@TOKS{%
  \DCohbase@tmp@toks=\expandafter{\the\DCohbase@tmp@toks#1}}%
\def\DCohbaseRenderContents#1#2#3#4{%
    \DCohbase@tmp@toks={#2}%
    \notblank{#3#4}{%
      \DCohbase@addtoks\mathclose{}\,\delimsize\Vert\,\mathopen{}%
          #3\mathclose{},\mathopen{}#4\@DCohbase@END@ADD@TOKS%
    }{}%
    \edef\tmp@args{\unexpanded{#1}{\the\DCohbase@tmp@toks}}%
    \expandafter\DCohbaseRenderContentsInnerParens\tmp@args%
}
\def\DCohbaseRenderContentsInnerParens{\phfqitParens}
\DefineQitObject{DCohbase}{\DCohbaseParse}{\DCohbaseRender}
\def\HSym{H}
\newcommand\DSym{D}
\newcommand\DCSym{\bar\DSym}
\def\emptysystem{\ensuremath{\emptyset}}
\def\DCohxRefSystemName#1{R_{#1}}
\def\DCohxStateSubscripts#1#2{#2\DCohxRefSystemName{#1}}
\let\@HHbase\Hbase
\let\@DDbase\Dbase
\let\HHSym\HSym
\let\DDSym\DSym
\SetupKeyvalOptions{
   family=phfqit,
   prefix=phfqit@opt@
}
\DeclareStringOption[stdset]{qitobjdef}
\DeclareBoolOption[true]{newReIm}
\ProcessKeyvalOptions*
\ifphfqit@opt@newReIm
  \renewcommand{\Re}{\phfqit@Realpart}
  \renewcommand{\Im}{\phfqit@Imagpart}
\fi
\def\phfqit@tmp@str@none{none}
\def\phfqit@tmp@str@stdset{stdset}
\ifx\phfqit@opt@qitobjdef\phfqit@tmp@str@none%
\else\ifx\phfqit@opt@qitobjdef\phfqit@tmp@str@stdset%
\def\HH{\Hbase{\HSym}{}}
\def\Hzero{\Hbase{\HSym}{\mathrm{max},0}}
\def\Hmin{\Hbase{\HSym}{\mathrm{min}}}
\def\Hmaxf{\Hbase{\HSym}{\mathrm{max}}}
\def\Hfn{\Hfnbase{\HSym}{}{}}
\let\Hfunc\Hfn% backwards compatibility
\def\DD{\Dbase{\DSym}}
\newcommand\Dminz[1][]{\Dbase{\DSym}_{\mathrm{min,0}}^{#1}}
\newcommand\Dminf[1][]{\Dbase{\DSym}_{\mathrm{min}}^{#1}}
\newcommand\Dmax[1][]{\Dbase{\DSym}_{\mathrm{max}}^{#1}}
\newcommand\Dr[1][]{\Dbase{\DSym}_{\mathrm{r}}^{#1}}
\newcommand\DHyp[1][\eta]{\Dbase{\DSym}_{\mathrm{H}}^{#1}}
\DefineTunedQitObject{DCoh}{\DCohbaseParse}{\DCohbaseRender}{{\DCSym}}{}
\DefineTunedQitObject{DCohx}{\DCohbaseParse}{\DCohbaseRender}%
{{\DCSym}}{%
  \let\DCohbaseStateSubscripts\DCohxStateSubscripts%
}
\else
\PackageError{phfqit}{Invalid value `\phfqit@opt@qitobjdef' specified for
  package option `qitobjdef'.  Please specify one of `stdset' (the default) or
  `none'}{You specified an invalid value to the `qitobjdef' package option of
  the `phfqit' package.}
\fi
\fi
\endinput
%%
%% End of file `phfqit.sty'.
