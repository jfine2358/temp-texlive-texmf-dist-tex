%%
%% This is file `l3regex.sty',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% l3regex.dtx  (with options: `package')
%% 
%% EXPERIMENTAL CODE
%% 
%% Do not distribute this file without also distributing the
%% source files specified above.
%% 
%% Do not distribute a modified version of this file.
%% 
%% File: l3regex.dtx Copyright (C) 2011-2012 The LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the "l3experimental bundle" (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX3 Project.
%%
%% -----------------------------------------------------------------------
\RequirePackage{expl3}
\GetIdInfo$Id: l3regex.dtx 3488 2012-03-03 19:49:03Z bruno $
  {L3 Experimental Regular Expressions}
\ProvidesExplPackage
  {\ExplFileName}{\ExplFileDate}{\ExplFileVersion}{\ExplFileDescription}
\RequirePackage{l3tl-build, l3tl-analysis, l3flag, l3str}
\cs_generate_variant:Nn \tl_to_str:n { V }
\cs_new:Npn \regex_tmp:w { }
\tl_new:N   \l_regex_internal_a_tl
\tl_new:N   \l_regex_internal_b_tl
\int_new:N  \l_regex_internal_a_int
\int_new:N  \l_regex_internal_b_int
\int_new:N  \l_regex_internal_c_int
\bool_new:N \l_regex_internal_bool
\seq_new:N  \l_regex_internal_seq
\tl_new:N   \g_regex_internal_tl
\tl_const:Nn \c_regex_no_match_regex
  {
    \regex_branch:n
      { \regex_class:NnnnN \c_true_bool { } { 1 } { 0 } \c_true_bool }
  }
\int_new:N \l_regex_balance_int
\cs_new_protected:Npn \regex_break_true:w
   #1 \regex_break_point:TF #2 #3 {#2}
\cs_new_protected:Npn \regex_break_point:TF #1 #2 { #2 }
\cs_new_protected:Npn \regex_item_reverse:n #1
  {
    #1
    \regex_break_point:TF { } \regex_break_true:w
  }
\cs_new_protected:Npn \regex_item_caseful_equal:n #1
  {
    \if_num:w #1 = \l_regex_current_char_int
      \exp_after:wN \regex_break_true:w
    \fi:
  }
\cs_new_protected:Npn \regex_item_caseful_range:nn #1 #2
  {
    \reverse_if:N \if_num:w #1 > \l_regex_current_char_int
      \reverse_if:N \if_num:w #2 < \l_regex_current_char_int
        \exp_after:wN \exp_after:wN \exp_after:wN \regex_break_true:w
      \fi:
    \fi:
  }
\cs_new_protected:Npn \regex_item_caseless_equal:n #1
  {
    \if_num:w #1 = \l_regex_current_char_int
      \exp_after:wN \regex_break_true:w
    \fi:
    \if_num:w \l_regex_case_changed_char_int = \c_max_int
      \regex_compute_case_changed_char:
    \fi:
    \if_num:w #1 = \l_regex_case_changed_char_int
      \exp_after:wN \regex_break_true:w
    \fi:
  }
\cs_new_protected:Npn \regex_item_caseless_range:nn #1 #2
  {
    \reverse_if:N \if_num:w #1 > \l_regex_current_char_int
      \reverse_if:N \if_num:w #2 < \l_regex_current_char_int
        \exp_after:wN \exp_after:wN \exp_after:wN \regex_break_true:w
      \fi:
    \fi:
    \if_num:w \l_regex_case_changed_char_int = \c_max_int
      \regex_compute_case_changed_char:
    \fi:
    \reverse_if:N \if_num:w #1 > \l_regex_case_changed_char_int
      \reverse_if:N \if_num:w #2 < \l_regex_case_changed_char_int
        \exp_after:wN \exp_after:wN \exp_after:wN \regex_break_true:w
      \fi:
    \fi:
  }
\cs_new_protected_nopar:Npn \regex_compute_case_changed_char:
  {
    \int_set_eq:NN \l_regex_case_changed_char_int \l_regex_current_char_int
    \if_num:w \l_regex_current_char_int < \c_ninety_one
      \if_num:w \l_regex_current_char_int < \c_sixty_five
      \else:
        \int_add:Nn \l_regex_case_changed_char_int { \c_thirty_two }
      \fi:
    \else:
      \if_num:w \l_regex_current_char_int < \c_one_hundred_twenty_three
        \if_num:w \l_regex_current_char_int < \c_ninety_seven
        \else:
          \int_sub:Nn \l_regex_case_changed_char_int { \c_thirty_two }
        \fi:
      \fi:
    \fi:
  }
\cs_new_eq:NN \regex_item_equal:n ?
\cs_new_eq:NN \regex_item_range:nn ?
\cs_new_protected:Npn \regex_item_catcode_aux:
  {
    "
    \if_case:w \l_regex_current_catcode_int
         1       \or: 4       \or: 10      \or: 40
    \or: 100     \or:         \or: 1000    \or: 4000
    \or: 10000   \or:         \or: 100000  \or: 400000
    \or: 1000000 \or: 4000000 \else: 1*\c_zero
    \fi:
  }
\cs_new_protected:Npn \regex_item_catcode:nT #1
  {
    \if_int_odd:w \int_eval:w #1 / \regex_item_catcode_aux: \int_eval_end:
      \exp_after:wN \use:n
    \else:
      \exp_after:wN \use_none:n
    \fi:
  }
\cs_new_protected:Npn \regex_item_catcode_reverse:nT #1#2
  { \regex_item_catcode:nT {#1} { \regex_item_reverse:n {#2} } }
\cs_new_protected:Npn \regex_item_exact:nn #1#2
  {
    \if_num:w #1 = \l_regex_current_catcode_int
      \if_num:w #2 = \l_regex_current_char_int
        \exp_after:wN \exp_after:wN \exp_after:wN \regex_break_true:w
      \fi:
    \fi:
  }
\cs_new_protected:Npn \regex_item_exact_cs:c #1
  {
    \int_compare:nNnTF \l_regex_current_catcode_int = \c_zero
      {
        \str_if_eq:xxTF
          {
            \exp_after:wN \exp_after:wN \exp_after:wN \cs_to_str:N
            \tex_the:D \tex_toks:D \l_regex_current_pos_int
          }
          { #1 }
          { \regex_break_true:w } { }
      }
      { }
  }
\cs_new_protected:Npn \regex_item_cs:n #1
  {
    \int_compare:nNnT \l_regex_current_catcode_int = \c_zero
      {
        \group_begin:
          \regex_single_match:
          \regex_disable_submatches:
          \regex_build_for_cs:n {#1}
          \bool_set_eq:NN \l_regex_saved_success_bool \g_regex_success_bool
          \exp_args:Nx \regex_match:n
            {
              \exp_after:wN \exp_after:wN
              \exp_after:wN \cs_to_str:N
              \tex_the:D \tex_toks:D \l_regex_current_pos_int
            }
          \if_meaning:w \c_true_bool \g_regex_success_bool
            \group_insert_after:N \regex_break_true:w
          \fi:
          \bool_gset_eq:NN \g_regex_success_bool \l_regex_saved_success_bool
        \group_end:
      }
  }
\cs_new_protected_nopar:Npn \regex_prop_d:
  { \regex_item_caseful_range:nn \c_forty_eight { 57 } } % 0--9
\cs_new_protected_nopar:Npn \regex_prop_h:
  {
    \regex_item_caseful_equal:n \c_thirty_two % space
    \regex_item_caseful_equal:n \c_nine       % tab
  }
\cs_new_protected_nopar:Npn \regex_prop_s:
  {
    \regex_item_caseful_equal:n \c_thirty_two % space
    \regex_item_caseful_equal:n \c_nine       % tab
    \regex_item_caseful_equal:n \c_ten        % lf
    \regex_item_caseful_equal:n \c_twelve     % ff
    \regex_item_caseful_equal:n \c_thirteen   % cr
  }
\cs_new_protected_nopar:Npn \regex_prop_v:
  { \regex_item_caseful_range:nn \c_ten \c_thirteen } % lf, vtab, ff, cr
\cs_new_protected_nopar:Npn \regex_prop_w:
  {
    \regex_item_caseful_range:nn \c_ninety_seven { 122 } % a--z
    \regex_item_caseful_range:nn \c_sixty_five   {  90 } % A--Z
    \regex_item_caseful_range:nn \c_forty_eight  {  57 } % 0--9
    \regex_item_caseful_equal:n  { 95 } % _
  }
\cs_new_protected_nopar:Npn \regex_prop_N:
  { \regex_item_reverse:n { \regex_item_caseful_equal:n \c_ten } }
\cs_new_protected_nopar:Npn \regex_posix_alnum:
  { \regex_posix_alpha: \regex_posix_digit: }
\cs_new_protected_nopar:Npn \regex_posix_alpha:
  { \regex_posix_lower: \regex_posix_upper: }
\cs_new_protected_nopar:Npn \regex_posix_ascii:
  { \regex_item_caseful_range:nn \c_zero \c_one_hundred_twenty_seven }
\cs_new_eq:NN \regex_posix_blank: \regex_prop_h:
\cs_new_protected_nopar:Npn \regex_posix_cntrl:
  {
    \regex_item_caseful_range:nn \c_zero { 31 }
    \regex_item_caseful_equal:n \c_one_hundred_twenty_seven
  }
\cs_new_eq:NN \regex_posix_digit: \regex_prop_d:
\cs_new_protected_nopar:Npn \regex_posix_graph:
  { \regex_item_caseful_range:nn { 33 } { 126 } }
\cs_new_protected_nopar:Npn \regex_posix_lower:
  { \regex_item_caseful_range:nn \c_ninety_seven { 122 } }
\cs_new_protected_nopar:Npn \regex_posix_print:
  { \regex_item_caseful_range:nn \c_thirty_two { 126 } }
\cs_new_protected_nopar:Npn \regex_posix_punct:
  {
    \regex_item_caseful_range:nn { 33 } { 47 }
    \regex_item_caseful_range:nn { 58 } { 64 }
    \regex_item_caseful_range:nn { 91 } { 96 }
    \regex_item_caseful_range:nn { 123 } { 126 }
  }
\cs_new_protected_nopar:Npn \regex_posix_space:
  {
    \regex_item_caseful_equal:n \c_thirty_two
    \regex_item_caseful_range:nn \c_nine \c_thirteen
  }
\cs_new_protected_nopar:Npn \regex_posix_upper:
  { \regex_item_caseful_range:nn \c_sixty_five { 90 } }
\cs_new_eq:NN \regex_posix_word: \regex_prop_w:
\cs_new_protected_nopar:Npn \regex_posix_xdigit:
  {
    \regex_posix_digit:
    \regex_item_caseful_range:nn \c_sixty_five { 70 }
    \regex_item_caseful_range:nn \c_ninety_seven { 102 }
  }
\cs_new_protected:Npn \regex_escape_use:nnnn #1#2#3#4
  {
    \tl_set_build:Nw \l_regex_internal_a_tl
      \cs_set_nopar:Npn \regex_escape_unescaped:N ##1 { #1 }
      \cs_set_nopar:Npn \regex_escape_escaped:N ##1 { #2 }
      \cs_set_nopar:Npn \regex_escape_raw:N ##1 { #3 }
      \int_set:Nn \tex_escapechar:D { 92 }
      \str_gset_other:Nn \g_regex_internal_tl { #4 }
      \tl_set:Nx \l_regex_internal_b_tl
        {
          \exp_after:wN \regex_escape_loop:N \g_regex_internal_tl
          { break } \prg_break_point:n { }
        }
      \tl_build_one:o \l_regex_internal_b_tl
    \tl_build_end:
    \l_regex_internal_a_tl
  }
\cs_new:Npn \regex_escape_loop:N #1
  {
    \cs_if_exist_use:cF { regex_escape_\token_to_str:N #1:w }
      { \regex_escape_unescaped:N #1 }
    \regex_escape_loop:N
  }
\cs_new_nopar:cpn { regex_escape_ \c_backslash_str :w }
    \regex_escape_loop:N #1
  {
    \cs_if_exist_use:cF { regex_escape_/\token_to_str:N #1:w }
      { \regex_escape_escaped:N #1 }
    \regex_escape_loop:N
  }
\cs_new_eq:NN \regex_escape_unescaped:N ?
\cs_new_eq:NN \regex_escape_escaped:N   ?
\cs_new_eq:NN \regex_escape_raw:N       ?
\cs_new_eq:NN \regex_escape_break:w \prg_map_break:
\cs_new_nopar:cpn { regex_escape_/break:w }
  {
    \if_false: { \fi: }
    \msg_kernel_error:nn { regex } { trailing-backslash }
    \exp_after:wN \use_none:n \exp_after:wN { \if_false: } \fi:
  }
\cs_new_nopar:cpn { regex_escape_~:w } { }
\cs_new_nopar:cpx { regex_escape_/a:w }
  { \exp_not:N \regex_escape_raw:N \iow_char:N \^^G }
\cs_new_nopar:cpx { regex_escape_/t:w }
  { \exp_not:N \regex_escape_raw:N \iow_char:N \^^I }
\cs_new_nopar:cpx { regex_escape_/n:w }
  { \exp_not:N \regex_escape_raw:N \iow_char:N \^^J }
\cs_new_nopar:cpx { regex_escape_/f:w }
  { \exp_not:N \regex_escape_raw:N \iow_char:N \^^L }
\cs_new_nopar:cpx { regex_escape_/r:w }
  { \exp_not:N \regex_escape_raw:N \iow_char:N \^^M }
\cs_new_nopar:cpx { regex_escape_/e:w }
  { \exp_not:N \regex_escape_raw:N \iow_char:N \^^[ }
\cs_new:cpn { regex_escape_/x:w } \regex_escape_loop:N
  {
    \exp_after:wN \regex_escape_x_end:w
    \int_value:w "0 \regex_escape_x_test:N
  }
\cs_new:Npn \regex_escape_x_end:w #1 ;
  {
    \int_compare:nNnTF {#1} < \c_two_hundred_fifty_six
      {
        \exp_last_unbraced:Nf \regex_escape_raw:N
          { \str_output_byte:n {#1} }
      }
      { \regex_escape_x_large:n {#1} }
  }
\group_begin:
  \char_set_catcode_other:n { 0 }
  \cs_new:Npn \regex_escape_x_large:n #1
    {
      \if_false: { \fi: }
      \tl_build_one:o \l_regex_internal_b_tl
      \int_compare:nNnTF {#1} > \c_max_char_int
        {
          \msg_kernel_error:nnx { regex } { x-overflow } {#1}
          \tl_set:Nx \l_regex_internal_b_tl
            { \if_false: } \fi: \regex_escape_loop:N
        }
        {
          \char_set_lccode:nn { \c_zero } {#1}
          \tl_to_lowercase:n
            {
              \tl_set:Nx \l_regex_internal_b_tl
                { \if_false: } \fi:
                \regex_escape_raw:N ^^@
                \regex_escape_loop:N
            }
        }
    }
\group_end:
\cs_new:Npn \regex_escape_x_test:N #1
  {
    \str_if_eq:xxTF {#1} { break } { ; }
      {
        \if_charcode:w \c_space_token #1
          \exp_after:wN \regex_escape_x_test:N
        \else:
          \exp_after:wN \regex_escape_x_test_ii:N
          \exp_after:wN #1
        \fi:
      }
  }
\cs_new:Npn \regex_escape_x_test_ii:N #1
  {
    \if_charcode:w \c_lbrace_str #1
      \exp_after:wN \regex_escape_x_loop:N
    \else:
      \str_aux_hexadecimal_use:NTF #1
        { \exp_after:wN \regex_escape_x_ii:N }
        { ; \exp_after:wN \regex_escape_loop:N \exp_after:wN #1 }
    \fi:
  }
\cs_new:Npn \regex_escape_x_ii:N #1
  {
    \str_if_eq:xxTF {#1} { break } { ; }
      {
        \str_aux_hexadecimal_use:NTF #1
          { ; \regex_escape_loop:N }
          { ; \regex_escape_loop:N #1 }
      }
  }
\cs_new:Npn \regex_escape_x_loop:N #1
  {
    \str_aux_hexadecimal_use:NTF #1
      { \regex_escape_x_loop:N }
      {
        \token_if_eq_charcode:NNTF \c_space_token #1
          { \regex_escape_x_loop:N }
          {
            ;
            \exp_after:wN \token_if_eq_charcode:NNTF \c_rbrace_str #1
              { \regex_escape_loop:N }
              {
                \if_false: { \fi: }
                \tl_build_one:o \l_regex_internal_b_tl
                \msg_kernel_error:nn { regex } { x-missing-rbrace } {#1}
                \tl_set:Nx \l_regex_internal_b_tl
                  { \if_false: } \fi: \regex_escape_loop:N #1
              }
          }
      }
  }
\prg_new_conditional:Npnn \regex_char_if_special:N #1 { TF }
  {
    \if_num:w `#1 < \c_ninety_one
      \if_num:w `#1 < \c_fifty_eight
        \if_num:w `#1 < \c_forty_eight
          \if_num:w `#1 < \c_thirty_two
            \prg_return_false: \else: \prg_return_true: \fi:
        \else: \prg_return_false: \fi:
      \else:
        \if_num:w `#1 < \c_sixty_five
          \prg_return_true: \else: \prg_return_false: \fi:
      \fi:
    \else:
      \if_num:w `#1 < \c_one_hundred_twenty_three
        \if_num:w `#1 < \c_ninety_seven
          \prg_return_true: \else: \prg_return_false: \fi:
      \else:
        \if_num:w `#1 < \c_one_hundred_twenty_seven
          \prg_return_true: \else: \prg_return_false: \fi:
      \fi:
    \fi:
  }
\prg_new_conditional:Npnn \regex_char_if_alphanumeric:N #1 { TF }
  {
    \if_num:w `#1 < \c_ninety_one
      \if_num:w `#1 < \c_fifty_eight
        \if_num:w `#1 < \c_forty_eight
          \prg_return_false: \else: \prg_return_true: \fi:
      \else:
        \if_num:w `#1 < \c_sixty_five
          \prg_return_false: \else: \prg_return_true: \fi:
      \fi:
    \else:
      \if_num:w `#1 < \c_one_hundred_twenty_three
        \if_num:w `#1 < \c_ninety_seven
          \prg_return_false: \else: \prg_return_true: \fi:
      \else:
        \prg_return_false:
      \fi:
    \fi:
  }
\int_new:N \l_regex_group_level_int
\int_new:N \l_regex_mode_int
\int_new:N \l_regex_catcodes_int
\int_new:N \l_regex_default_catcodes_int
\bool_new:N \l_regex_catcodes_bool
\int_const:Nn \c_regex_catcode_C_int { "1 }
\int_const:Nn \c_regex_catcode_B_int { "4 }
\int_const:Nn \c_regex_catcode_E_int { "10 }
\int_const:Nn \c_regex_catcode_M_int { "40 }
\int_const:Nn \c_regex_catcode_T_int { "100 }
\int_const:Nn \c_regex_catcode_P_int { "1000 }
\int_const:Nn \c_regex_catcode_U_int { "4000 }
\int_const:Nn \c_regex_catcode_D_int { "10000 }
\int_const:Nn \c_regex_catcode_S_int { "100000 }
\int_const:Nn \c_regex_catcode_L_int { "400000 }
\int_const:Nn \c_regex_catcode_O_int { "1000000 }
\int_const:Nn \c_regex_catcode_A_int { "4000000 }
\int_const:Nn \c_regex_all_catcodes_int { "5515155 }
\cs_new_eq:NN \l_regex_internal_regex \c_regex_no_match_regex
\seq_new:N \l_regex_show_prefix_seq
\int_new:N \l_regex_show_lines_int
\cs_new_protected:Npn \regex_get_digits:NTFw #1#2#3#4#5
  {
    \regex_if_raw_digit:NNTF #4 #5
      { #1 = #5 \regex_get_digits_loop:nw {#2} }
      { #3 #4 #5 }
  }
\cs_new:Npn \regex_get_digits_loop:nw #1#2#3
  {
    \regex_if_raw_digit:NNTF #2 #3
      { #3 \regex_get_digits_loop:nw {#1} }
      { \scan_stop: #1 #2 #3 }
  }
\prg_new_conditional:Npnn \regex_if_raw_digit:NN #1#2 { TF }
  {
    \if_meaning:w \regex_compile_raw:N #1
      \if_int_compare:w \c_one < 1 #2 \exp_stop_f:
        \prg_return_true:
      \else:
        \prg_return_false:
      \fi:
    \else:
      \prg_return_false:
    \fi:
  }
\cs_new_nopar:Npn \regex_if_in_class:TF
  {
    \if_int_odd:w \l_regex_mode_int
      \exp_after:wN \use_i:nn
    \else:
      \exp_after:wN \use_ii:nn
    \fi:
  }
\cs_new_nopar:Npn \regex_if_in_cs:TF
  {
    \if_int_odd:w \l_regex_mode_int
      \exp_after:wN \use_ii:nn
    \else:
      \if_int_compare:w \l_regex_mode_int < \c_zero
        \exp_after:wN \exp_after:wN \exp_after:wN \use_i:nn
      \else:
        \exp_after:wN \exp_after:wN \exp_after:wN \use_ii:nn
      \fi:
    \fi:
  }
\cs_new_nopar:Npn \regex_if_in_class_or_catcode:TF
  {
    \if_int_odd:w \l_regex_mode_int
      \exp_after:wN \use_i:nn
    \else:
      \if_int_compare:w \l_regex_mode_int > \c_zero
        \exp_after:wN \exp_after:wN \exp_after:wN \use_i:nn
      \else:
        \exp_after:wN \exp_after:wN \exp_after:wN \use_ii:nn
      \fi:
    \fi:
  }
\cs_new_nopar:Npn \regex_if_within_catcode:TF
  {
    \if_int_compare:w \l_regex_mode_int > \c_zero
      \exp_after:wN \use_i:nn
    \else:
      \exp_after:wN \use_ii:nn
    \fi:
  }
\cs_new_protected:Npn \regex_chk_c_allowed:T
  {
    \if_num:w \l_regex_mode_int = \c_zero
      \exp_after:wN \use:n
    \else:
      \if_num:w \l_regex_mode_int = \c_three
        \exp_after:wN \exp_after:wN \exp_after:wN \use:n
      \else:
        \msg_kernel_error:nn { regex } { c-bad-mode }
        \exp_after:wN \exp_after:wN \exp_after:wN \use_none:n
      \fi:
    \fi:
  }
\cs_new_protected:Npn \regex_mode_quit_c:
  {
    \if_num:w \l_regex_mode_int = \c_two
      \l_regex_mode_int = \c_zero
    \else:
      \if_num:w \l_regex_mode_int = \c_six
        \l_regex_mode_int = \c_three
      \fi:
    \fi:
  }
\cs_new_protected_nopar:Npn \regex_compile:w
  {
    \tl_set_build_x:Nw \l_regex_internal_regex
      \int_zero:N \l_regex_group_level_int
      \int_set_eq:NN \l_regex_default_catcodes_int \c_regex_all_catcodes_int
      \int_set_eq:NN \l_regex_catcodes_int \l_regex_default_catcodes_int
      \cs_set_nopar:Npn \regex_item_equal:n  { \regex_item_caseful_equal:n }
      \cs_set_nopar:Npn \regex_item_range:nn { \regex_item_caseful_range:nn }
      \tl_build_one:n { \regex_branch:n { \if_false: } \fi: }
  }
\cs_new_protected_nopar:Npn \regex_compile_end:
  {
      \regex_if_in_class:TF
        {
          \msg_kernel_error:nn { regex } { missing-rbrack }
          \use:c { regex_compile_]: }
          \prg_do_nothing: \prg_do_nothing:
        }
        { }
      \if_num:w \l_regex_group_level_int > \c_zero
        \msg_kernel_error:nnx { regex } { missing-rparen }
          { \int_use:N \l_regex_group_level_int }
        \prg_replicate:nn
          { \l_regex_group_level_int }
          {
              \tl_build_one:n
                {
                  \if_false: { \fi: }
                  \if_false: { \fi: } { 1 } { 0 } \c_true_bool
                }
            \tl_build_end:
            \tl_build_one:o \l_regex_internal_regex
          }
      \fi:
      \tl_build_one:n { \if_false: { \fi: } }
    \tl_build_end:
  }
\cs_new_protected:Npn \regex_compile:n #1
  {
    \regex_compile:w
      \int_set:Nn \tex_escapechar:D { 92 }
      \int_set_eq:NN \l_regex_mode_int \c_zero
      \regex_escape_use:nnnn
        {
          \regex_char_if_special:NTF ##1
            \regex_compile_special:N \regex_compile_raw:N ##1
        }
        {
          \regex_char_if_alphanumeric:NTF ##1
            \regex_compile_escaped:N \regex_compile_raw:N ##1
        }
        { \regex_compile_raw:N ##1 }
        { #1 }
      \prg_do_nothing: \prg_do_nothing:
      \prg_do_nothing: \prg_do_nothing:
      \int_compare:nNnT \l_regex_mode_int < \c_zero
        {
          \msg_kernel_error:nn { regex } { c-missing-rbrace }
          \regex_compile_end:
          \regex_compile_one:x
            { \regex_item_cs:n { \exp_not:o \l_regex_internal_regex } }
          \prg_do_nothing: \prg_do_nothing:
          \prg_do_nothing: \prg_do_nothing:
        }
    \regex_compile_end:
  }
\cs_new_protected:Npn \regex_compile_special:N #1
  {
    \cs_if_exist_use:cF { regex_compile_#1: }
      { \regex_compile_raw:N #1 }
  }
\cs_new_protected:Npn \regex_compile_escaped:N #1
  {
    \cs_if_exist_use:cF { regex_compile_/#1: }
      { \regex_compile_raw:N #1 }
  }
\cs_new_protected:Npn \regex_compile_one:x #1
  {
    \regex_mode_quit_c:
    \regex_if_in_class:TF { }
      {
        \tl_build_one:n
          { \regex_class:NnnnN \c_true_bool { \if_false: } \fi: }
      }
    \tl_build_one:x
      {
        \if_num:w \l_regex_catcodes_int < \c_regex_all_catcodes_int
          \regex_item_catcode:nT { \int_use:N \l_regex_catcodes_int }
            { \exp_not:N \exp_not:n {#1} }
        \else:
          \exp_not:N \exp_not:n {#1}
        \fi:
      }
    \int_set_eq:NN \l_regex_catcodes_int \l_regex_default_catcodes_int
    \regex_if_in_class:TF { } { \regex_compile_quantifier:w }
  }
\cs_new_protected:Npn \regex_compile_abort_tokens:n #1
  {
    \use:x
      {
        \exp_args:No \tl_map_function:nN { \tl_to_str:n {#1} }
          \regex_compile_raw:N
      }
  }
\cs_generate_variant:Nn \regex_compile_abort_tokens:n { x }
\cs_new_protected:Npn \regex_compile_quantifier:w #1#2
  {
    \token_if_eq_meaning:NNTF #1 \regex_compile_special:N
      {
        \cs_if_exist_use:cF { regex_compile_quantifier_#2:w }
          { \regex_compile_quantifier_none: #1 #2 }
      }
      { \regex_compile_quantifier_none: #1 #2 }
  }
\cs_new_protected:Npn \regex_compile_quantifier_none:
  { \tl_build_one:n { \if_false: { \fi: } { 1 } { 0 } \c_false_bool } }
\cs_new_protected:Npn \regex_compile_quantifier_abort:xNN #1#2#3
  {
    \regex_compile_quantifier_none:
    \msg_kernel_warning:nnxx { regex } { invalid-quantifier } {#1} {#3}
    \regex_compile_abort_tokens:x {#1}
    #2 #3
  }
\cs_new_protected:Npn \regex_compile_quantifier_lazyness:nnNN #1#2#3#4
  {
    \str_if_eq:nnTF { #3 #4 } { \regex_compile_special:N ? }
      { \tl_build_one:n { \if_false: { \fi: } { #1 } { #2 } \c_true_bool } }
      {
        \tl_build_one:n { \if_false: { \fi: } { #1 } { #2 } \c_false_bool }
        #3 #4
      }
  }
\cs_new_protected_nopar:cpn { regex_compile_quantifier_?:w }
  { \regex_compile_quantifier_lazyness:nnNN { 0 } { 1 } }
\cs_new_protected_nopar:cpn { regex_compile_quantifier_*:w }
  { \regex_compile_quantifier_lazyness:nnNN { 0 } { -1 } }
\cs_new_protected_nopar:cpn { regex_compile_quantifier_+:w }
  { \regex_compile_quantifier_lazyness:nnNN { 1 } { -1 } }
\cs_new_protected:cpn { regex_compile_quantifier_ \c_lbrace_str :w }
  {
    \regex_get_digits:NTFw \l_regex_internal_a_int
      { \regex_compile_quantifier_braced_i:w }
      { \regex_compile_quantifier_abort:xNN { \c_lbrace_str } }
  }
\cs_new_protected:Npn \regex_compile_quantifier_braced_i:w #1#2
  {
    \prg_case_str:xxn { #1 #2 }
      {
        { \regex_compile_special:N \c_rbrace_str }
          {
            \exp_args:No \regex_compile_quantifier_lazyness:nnNN
              { \int_use:N \l_regex_internal_a_int } { 0 }
          }
        { \regex_compile_special:N , }
          {
            \regex_get_digits:NTFw \l_regex_internal_b_int
              { \regex_compile_quantifier_braced_iii:w }
              { \regex_compile_quantifier_braced_ii:w }
          }
      }
      {
        \regex_compile_quantifier_abort:xNN
          { \c_lbrace_str \int_use:N \l_regex_internal_a_int }
        #1 #2
      }
  }
\cs_new_protected:Npn \regex_compile_quantifier_braced_ii:w #1#2
  {
    \str_if_eq:xxTF
      { #1 #2 } { \regex_compile_special:N \c_rbrace_str }
      {
        \exp_args:No \regex_compile_quantifier_lazyness:nnNN
          { \int_use:N \l_regex_internal_a_int } { -1 }
      }
      {
        \regex_compile_quantifier_abort:xNN
          { \c_lbrace_str \int_use:N \l_regex_internal_a_int , }
        #1 #2
      }
  }
\cs_new_protected:Npn \regex_compile_quantifier_braced_iii:w #1#2
  {
    \str_if_eq:xxTF
      { #1 #2 } { \regex_compile_special:N \c_rbrace_str }
      {
        \if_num:w \l_regex_internal_a_int > \l_regex_internal_b_int
          \msg_kernel_error:nnxx { regex } { backwards-quantifier }
            { \int_use:N \l_regex_internal_a_int }
            { \int_use:N \l_regex_internal_b_int }
          \int_zero:N \l_regex_internal_b_int
        \else:
          \int_sub:Nn \l_regex_internal_b_int \l_regex_internal_a_int
        \fi:
        \exp_args:Noo \regex_compile_quantifier_lazyness:nnNN
          { \int_use:N \l_regex_internal_a_int }
          { \int_use:N \l_regex_internal_b_int }
      }
      {
        \regex_compile_quantifier_abort:xNN
          {
            \c_lbrace_str
            \int_use:N \l_regex_internal_a_int ,
            \int_use:N \l_regex_internal_b_int
          }
        #1 #2
      }
  }
\cs_new_protected:Npn \regex_compile_raw_error:N #1
  {
    \msg_kernel_error:nnx { regex } { bad-escape } {#1}
    \regex_compile_raw:N #1
  }
\cs_new_protected:Npn \regex_compile_raw:N #1#2#3
  {
    \regex_if_in_class:TF
      {
        \str_if_eq:nnTF {#2#3} { \regex_compile_special:N - }
          { \regex_compile_range:Nw #1 }
          {
            \regex_compile_one:x
              { \regex_item_equal:n { \int_value:w `#1 ~ } }
            #2 #3
          }
      }
      {
        \regex_compile_one:x
          { \regex_item_equal:n { \int_value:w `#1 ~ } }
        #2 #3
      }
  }
\prg_new_protected_conditional:Npnn \regex_if_end_range:NN #1#2 { TF }
  {
    \if_meaning:w \regex_compile_raw:N #1
      \prg_return_true:
    \else:
      \if_meaning:w \regex_compile_special:N #1
        \if_charcode:w ] #2
          \prg_return_false:
        \else:
          \prg_return_true:
        \fi:
      \else:
        \prg_return_false:
      \fi:
    \fi:
  }
\cs_new_protected:Npn \regex_compile_range:Nw #1#2#3
  {
    \regex_if_end_range:NNTF #2 #3
      {
        \if_num:w `#1 > `#3 \exp_stop_f:
          \msg_kernel_error:nnxx { regex } { range-backwards } {#1} {#3}
        \else:
          \tl_build_one:x
            {
              \if_num:w `#1 = `#3 \exp_stop_f:
                \regex_item_equal:n
              \else:
                \regex_item_range:nn { \int_value:w `#1 ~ }
              \fi:
              { \int_value:w `#3 ~ }
            }
        \fi:
      }
      {
        \msg_kernel_warning:nnxx { regex } { range-missing-end }
          {#1} { \c_backslash_str #3 }
        \tl_build_one:x
          {
            \regex_item_equal:n { \int_value:w `#1 ~ }
            \regex_item_equal:n { \int_value:w `- ~ }
          }
        #2#3
      }
  }
\cs_new_protected_nopar:cpx { regex_compile_.: }
  {
    \exp_not:N \regex_if_in_class:TF
      { \regex_compile_raw:N . }
      { \regex_compile_one:x \exp_not:c { regex_prop_.: } }
  }
\cs_new_protected_nopar:cpn { regex_prop_.: }
  {
    \if_num:w \l_regex_current_char_int > - \c_two
      \exp_after:wN \regex_break_true:w
    \fi:
  }
\cs_set_protected:Npn \regex_tmp:w #1#2
  {
    \cs_new_protected_nopar:cpx { regex_compile_/#1: }
      { \regex_compile_one:x \exp_not:c { regex_prop_#1: } }
    \cs_new_protected_nopar:cpx { regex_compile_/#2: }
      {
        \regex_compile_one:x
          { \regex_item_reverse:n \exp_not:c { regex_prop_#1: } }
      }
  }
\regex_tmp:w d D
\regex_tmp:w h H
\regex_tmp:w s S
\regex_tmp:w v V
\regex_tmp:w w W
\cs_new_protected_nopar:cpn { regex_compile_/N: }
  { \regex_compile_one:x \regex_prop_N: }
\cs_new_protected:Npn \regex_compile_anchor:NF #1#2
  {
    \regex_if_in_class_or_catcode:TF {#2}
      {
        \tl_build_one:n
          { \regex_assertion:Nn \c_true_bool { \regex_anchor:N #1 } }
      }
  }
\cs_set_protected:Npn \regex_tmp:w #1#2
  {
    \cs_new_protected_nopar:cpn { regex_compile_/#1: }
      { \regex_compile_anchor:NF #2 { \regex_compile_raw_error:N #1 } }
  }
\regex_tmp:w A \l_regex_min_pos_int
\regex_tmp:w G \l_regex_start_pos_int
\regex_tmp:w Z \l_regex_max_pos_int
\regex_tmp:w z \l_regex_max_pos_int
\cs_set_protected:Npn \regex_tmp:w #1#2
  {
    \cs_new_protected_nopar:cpn { regex_compile_#1: }
      { \regex_compile_anchor:NF #2 { \regex_compile_raw:N #1 } }
  }
\exp_args:Nx \regex_tmp:w { \iow_char:N \^ } \l_regex_min_pos_int
\exp_args:Nx \regex_tmp:w { \iow_char:N \$ } \l_regex_max_pos_int
\cs_new_protected_nopar:cpn { regex_compile_/b: }
  {
    \regex_if_in_class_or_catcode:TF
      { \regex_compile_raw_error:N b }
      {
        \tl_build_one:n
          { \regex_assertion:Nn \c_true_bool { \regex_b_test: } }
      }
  }
\cs_new_protected_nopar:cpn { regex_compile_/B: }
  {
    \regex_if_in_class_or_catcode:TF
      { \regex_compile_raw_error:N B }
      {
        \tl_build_one:n
          { \regex_assertion:Nn \c_false_bool { \regex_b_test: } }
      }
  }
\cs_new_protected:cpn { regex_compile_]: }
  {
    \regex_if_in_class:TF
      {
        \if_num:w \l_regex_mode_int > \c_sixteen
          \tl_build_one:n { \if_false: { \fi: } }
        \fi:
        \tex_advance:D \l_regex_mode_int - \c_fifteen
        \tex_divide:D \l_regex_mode_int \c_thirteen
        \if_int_odd:w \l_regex_mode_int \else:
          \exp_after:wN \regex_compile_quantifier:w
        \fi:
      }
      { \regex_compile_raw:N ] }
  }
\cs_new_protected_nopar:cpn { regex_compile_[: }
  {
    \regex_if_in_class:TF
      { \regex_compile_class_posix_test:w }
      {
        \regex_if_within_catcode:TF
          {
            \exp_after:wN \regex_compile_class_catcode:w
              \int_use:N \l_regex_catcodes_int ;
          }
          { \regex_compile_class_normal:w }
      }
  }
\cs_new_protected_nopar:Npn \regex_compile_class_normal:w
  {
    \regex_compile_class:TFNN
      { \regex_class:NnnnN \c_true_bool }
      { \regex_class:NnnnN \c_false_bool }
  }
\cs_new_protected:Npn \regex_compile_class_catcode:w #1;
  {
    \if_int_compare:w \l_regex_mode_int = \c_two
      \tl_build_one:n
        { \regex_class:NnnnN \c_true_bool { \if_false: } \fi: }
    \fi:
    \int_set_eq:NN \l_regex_catcodes_int \l_regex_default_catcodes_int
    \regex_compile_class:TFNN
      { \regex_item_catcode:nT {#1} }
      { \regex_item_catcode_reverse:nT {#1} }
  }
\cs_new_protected:Npn \regex_compile_class:TFNN #1#2#3#4
  {
    \l_regex_mode_int = \int_value:w \l_regex_mode_int 3 \exp_stop_f:
    \str_if_eq:nnTF { #3 #4 } { \regex_compile_special:N ^ }
      {
        \tl_build_one:n { #2 { \if_false: } \fi: }
        \regex_compile_class_ii:NN
      }
      {
        \tl_build_one:n { #1 { \if_false: } \fi: }
        \regex_compile_class_ii:NN #3 #4
      }
  }
\cs_new_protected:Npn \regex_compile_class_ii:NN #1#2
  {
    \token_if_eq_charcode:NNTF #2 ]
      { \regex_compile_raw:N #2 }
      { #1 #2 }
  }
\cs_new_protected:Npn \regex_compile_class_posix_test:w #1#2
  {
    \token_if_eq_meaning:NNT \regex_compile_special:N #1
      {
        \prg_case_str:nnn { #2 }
          {
            : { \regex_compile_class_posix:NNNNw }
            = { \msg_kernel_warning:nnx { regex } { posix-unsupported } { = } }
            . { \msg_kernel_warning:nnx { regex } { posix-unsupported } { . } }
          }
          { }
      }
    \regex_compile_raw:N [ #1 #2
  }
\cs_new_protected:Npn \regex_compile_class_posix:NNNNw #1#2#3#4#5#6
  {
    \str_if_eq:nnTF { #5 #6 } { \regex_compile_special:N ^ }
      {
        \bool_set_false:N \l_regex_internal_bool
        \tl_set:Nx \l_regex_internal_a_tl { \if_false: } \fi:
          \regex_compile_class_posix_loop:w
      }
      {
        \bool_set_true:N \l_regex_internal_bool
        \tl_set:Nx \l_regex_internal_a_tl { \if_false: } \fi:
          \regex_compile_class_posix_loop:w #5 #6
      }
  }
\cs_new:Npn \regex_compile_class_posix_loop:w #1#2
  {
    \token_if_eq_meaning:NNTF \regex_compile_raw:N #1
      { #2 \regex_compile_class_posix_loop:w }
      { \if_false: { \fi: } \regex_compile_class_posix_end:w #1 #2 }
  }
\cs_new_protected:Npn \regex_compile_class_posix_end:w #1#2#3#4
  {
    \str_if_eq:nnTF { #1 #2 #3 #4 }
      { \regex_compile_special:N : \regex_compile_special:N ] }
      {
        \cs_if_exist:cTF { regex_posix_ \l_regex_internal_a_tl : }
          {
            \regex_compile_one:x
              {
                \bool_if:NF \l_regex_internal_bool \regex_item_reverse:n
                \exp_not:c { regex_posix_ \l_regex_internal_a_tl : }
              }
          }
          {
            \msg_kernel_warning:nnx { regex } { posix-unknown }
              { \l_regex_internal_a_tl }
            \regex_compile_abort_tokens:x
              {
                [: \bool_if:NF \l_regex_internal_bool { ^ }
                \l_regex_internal_a_tl :]
              }
          }
      }
      {
        \msg_kernel_error:nnxx { regex } { posix-missing-close }
          { [: \l_regex_internal_a_tl } { #2 #4 }
        \regex_compile_abort_tokens:x { [: \l_regex_internal_a_tl }
        #1 #2 #3 #4
      }
  }
\cs_new_protected:Npn \regex_compile_group_begin:N #1
  {
    \tl_build_one:n { #1 { \if_false: } \fi: }
    \regex_mode_quit_c:
    \tl_set_build:Nw \l_regex_internal_regex
      \int_set_eq:NN \l_regex_default_catcodes_int \l_regex_catcodes_int
      \int_incr:N \l_regex_group_level_int
      \tl_build_one:n { \regex_branch:n { \if_false: } \fi: }
  }
\cs_new_protected:Npn \regex_compile_group_end:
  {
    \if_num:w \l_regex_group_level_int > \c_zero
        \tl_build_one:n { \if_false: { \fi: } }
      \tl_build_end:
      \int_set_eq:NN \l_regex_catcodes_int \l_regex_default_catcodes_int
      \tl_build_one:o \l_regex_internal_regex
      \exp_after:wN \regex_compile_quantifier:w
    \else:
      \msg_kernel_warning:nn { regex } { extra-rparen }
      \exp_after:wN \regex_compile_raw:N \exp_after:wN )
    \fi:
  }
\cs_new_protected_nopar:cpn { regex_compile_(: }
  {
    \regex_if_in_class:TF { \regex_compile_raw:N ( }
      { \regex_compile_lparen:w }
  }
\cs_new_protected:Npn \regex_compile_lparen:w #1#2#3#4
  {
    \str_if_eq:nnTF { #1 #2 } { \regex_compile_special:N ? }
      {
        \cs_if_exist_use:cF
          { regex_compile_special_group_\token_to_str:N #4 :w }
          {
            \msg_kernel_warning:nnx { regex } { special-group-unknown }
              { (? \token_to_str:N #4 }
            \regex_compile_group_begin:N \regex_group:nnnN
              \regex_compile_raw:N ? #3 #4
          }
      }
      {
        \regex_compile_group_begin:N \regex_group:nnnN
          #1 #2 #3 #4
      }
  }
\cs_new_protected_nopar:cpn { regex_compile_|: }
  {
    \regex_if_in_class:TF { \regex_compile_raw:N | }
      {
        \tl_build_one:n
          { \if_false: { \fi: } \regex_branch:n { \if_false: } \fi: }
      }
  }
\cs_new_protected_nopar:cpn { regex_compile_): }
  {
    \regex_if_in_class:TF { \regex_compile_raw:N ) }
      { \regex_compile_group_end: }
  }
\cs_new_protected_nopar:cpn { regex_compile_special_group_::w }
  { \regex_compile_group_begin:N \regex_group_no_capture:nnnN }
\cs_new_protected_nopar:cpn { regex_compile_special_group_|:w }
  { \regex_compile_group_begin:N \regex_group_resetting:nnnN }
\cs_new_protected:Npn \regex_compile_special_group_i:w #1#2
  {
    \str_if_eq:nnTF { #1 #2 } { \regex_compile_special:N ) }
      {
        \cs_set_nopar:Npn \regex_item_equal:n  { \regex_item_caseless_equal:n }
        \cs_set_nopar:Npn \regex_item_range:nn { \regex_item_caseless_range:nn }
      }
      {
        \msg_kernel_warning:nnx { regex } { unknown-option } { (?i #2 }
        \regex_compile_raw:N (
        \regex_compile_raw:N ?
        \regex_compile_raw:N i
        #1 #2
      }
  }
\cs_new_protected_nopar:cpn { regex_compile_special_group_-:w } #1#2#3#4
  {
    \str_if_eq:nnTF { #1 #2 #3 #4 }
      { \regex_compile_raw:N i \regex_compile_special:N ) }
      {
        \cs_set_nopar:Npn \regex_item_equal:n  { \regex_item_caseful_equal:n }
        \cs_set_nopar:Npn \regex_item_range:nn { \regex_item_caseful_range:nn }
      }
      {
        \msg_kernel_warning:nnx { regex } { unknown-option } { (?-#2#4 }
        \regex_compile_raw:N (
        \regex_compile_raw:N ?
        \regex_compile_raw:N -
        #1 #2 #3 #4
      }
  }
\cs_new_protected:cpn { regex_compile_/c: }
  { \regex_chk_c_allowed:T { \regex_compile_c_test:NN } }
\cs_new_protected:Npn \regex_compile_c_test:NN #1#2
  {
    \token_if_eq_meaning:NNTF #1 \regex_compile_raw:N
      {
        \int_if_exist:cTF { c_regex_catcode_#2_int }
          {
            \int_set_eq:Nc \l_regex_catcodes_int { c_regex_catcode_#2_int }
            \l_regex_mode_int
              = \if_case:w \l_regex_mode_int \c_two \else: \c_six \fi:
          }
      }
      { \cs_if_exist_use:cF { regex_compile_c_#2:w } }
          {
            \msg_kernel_error:nnx { regex } { c-missing-category } {#2}
            #1 #2
          }
  }
\cs_new_protected:cpn { regex_compile_c_[:w } #1#2
  {
    \l_regex_mode_int
      = \if_case:w \l_regex_mode_int \c_two \else: \c_six \fi:
    \int_zero:N \l_regex_catcodes_int
    \str_if_eq:nnTF { #1 #2 } { \regex_compile_special:N ^ }
      {
        \bool_set_false:N \l_regex_catcodes_bool
        \regex_compile_c_lbrack_loop:NN
      }
      {
        \bool_set_true:N \l_regex_catcodes_bool
        \regex_compile_c_lbrack_loop:NN
        #1 #2
      }
  }
\cs_new_protected:Npn \regex_compile_c_lbrack_loop:NN #1#2
  {
    \token_if_eq_meaning:NNTF #1 \regex_compile_raw:N
      {
        \int_if_exist:cTF { c_regex_catcode_#2_int }
          {
            \exp_args:Nc \regex_compile_c_lbrack_add:N
              { c_regex_catcode_#2_int }
            \regex_compile_c_lbrack_loop:NN
          }
      }
      {
        \token_if_eq_charcode:NNTF #2 ]
          { \regex_compile_c_lbrack_end: }
      }
          {
            \msg_kernel_error:nnx { regex } { c-missing-rbrack } {#2}
            \regex_compile_c_lbrack_end:
            #1 #2
          }
  }
\cs_new_protected:Npn \regex_compile_c_lbrack_add:N #1
  {
    \if_int_odd:w \int_eval:w \l_regex_catcodes_int / #1 \int_eval_end:
    \else:
      \tex_advance:D \l_regex_catcodes_int #1
    \fi:
  }
\cs_new_protected_nopar:Npn \regex_compile_c_lbrack_end:
  {
    \if_meaning:w \c_false_bool \l_regex_catcodes_bool
      \int_set:Nn \l_regex_catcodes_int
        { \c_regex_all_catcodes_int - \l_regex_catcodes_int }
    \fi:
  }
\cs_new_protected_nopar:cpn { regex_compile_c_ \c_lbrace_str :w }
  {
    \regex_compile:w
      \regex_disable_submatches:
      \l_regex_mode_int
        = - \if_case:w \l_regex_mode_int \c_two \else: \c_six \fi:
  }
\cs_new_protected:cpn { regex_compile_ \c_rbrace_str : }
  {
    \regex_if_in_cs:TF
      {
        \regex_compile_end:
        \regex_compile_one:x
          { \regex_item_cs:n { \exp_not:o \l_regex_internal_regex } }
      }
      { \exp_after:wN \regex_compile_raw:N \c_rbrace_str }
  }
\cs_new_protected:cpn { regex_compile_/u: } #1#2
  {
    \regex_if_in_class_or_catcode:TF
      { \regex_compile_raw_error:N u #1 #2 }
      {
        \str_if_eq:xxTF {#1#2} { \regex_compile_special:N \c_lbrace_str }
          {
            \tl_set:Nx \l_regex_internal_a_tl { \if_false: } \fi:
            \regex_compile_u_loop:NN
          }
          {
            \msg_kernel_error:nn { regex } { u-missing-lbrace }
            \regex_compile_raw:N u #1 #2
          }
      }
  }
\cs_new:Npn \regex_compile_u_loop:NN #1#2
  {
    \token_if_eq_meaning:NNTF #1 \regex_compile_raw:N
      { #2 \regex_compile_u_loop:NN }
      {
        \token_if_eq_meaning:NNTF #1 \regex_compile_special:N
          {
            \exp_after:wN \token_if_eq_charcode:NNTF \c_rbrace_str #2
              { \if_false: { \fi: } \regex_compile_u_end: }
              { #2 \regex_compile_u_loop:NN }
          }
          {
            \if_false: { \fi: }
            \msg_kernel_error:nnx { regex } { u-missing-rbrace } {#2}
            \regex_compile_u_end:
            #1 #2
          }
      }
  }
\cs_new_protected:Npn \regex_compile_u_end:
  {
    \tl_set:Nv \l_regex_internal_a_tl { \l_regex_internal_a_tl }
    \if_num:w \l_regex_mode_int = \c_zero
      \regex_compile_u_not_cs:
    \else:
      \regex_compile_u_in_cs:
    \fi:
  }
\cs_new_protected:Npn \regex_compile_u_in_cs:
  {
    \exp_args:NNo \str_gset_other:Nn \g_regex_internal_tl
      { \l_regex_internal_a_tl }
    \tl_build_one:x
      {
        \tl_map_function:NN \g_regex_internal_tl
          \regex_compile_u_in_cs_aux:n
      }
  }
\cs_new:Npn \regex_compile_u_in_cs_aux:n #1
  {
    \regex_class:NnnnN \c_true_bool
      { \regex_item_caseful_equal:n { \int_value:w `#1 } }
      { 1 } { 0 } \c_false_bool
  }
\cs_new_protected:Npn \regex_compile_u_not_cs:
  {
    \exp_args:No \tl_analysis_map_inline:nn { \l_regex_internal_a_tl }
      {
        \tl_build_one:n
          {
            \regex_class:NnnnN \c_true_bool
              {
                \if_num:w "##2 = \c_zero
                  \regex_item_exact_cs:c { \exp_after:wN \cs_to_str:N ##1 }
                \else:
                  \regex_item_exact:nn { \int_value:w "##2 } { ##3 }
                \fi:
              }
              { 1 } { 0 } \c_false_bool
          }
      }
  }
\cs_new_protected_nopar:cpn { regex_compile_/K: }
  {
    \int_compare:nNnTF \l_regex_mode_int = \c_zero
      { \tl_build_one:n { \regex_command_K: } }
      { \regex_compile_raw_error:N K }
  }
\cs_new_protected:Npn \regex_show_aux:Nx #1#2
  {
    \tl_set_build:Nw \l_regex_internal_a_tl
      \cs_set_protected_nopar:Npn \regex_branch:n
        {
          \seq_pop_right:NN \l_regex_show_prefix_seq \l_regex_internal_a_tl
          \regex_show_one:n { +-branch }
          \seq_put_right:No \l_regex_show_prefix_seq \l_regex_internal_a_tl
          \use:n
        }
      \cs_set_protected_nopar:Npn \regex_group:nnnN
        { \regex_show_group_aux:nnnnN { } }
      \cs_set_protected_nopar:Npn \regex_group_no_capture:nnnN
        { \regex_show_group_aux:nnnnN { ~(no~capture) } }
      \cs_set_protected_nopar:Npn \regex_group_resetting:nnnN
        { \regex_show_group_aux:nnnnN { ~(resetting) } }
      \cs_set_eq:NN \regex_class:NnnnN \regex_show_class:NnnnN
      \cs_set_protected_nopar:Npn \regex_command_K:
        { \regex_show_one:n { reset~match~start~(\iow_char:N\\K) } }
      \cs_set_protected:Npn \regex_assertion:Nn ##1##2
        { \regex_show_one:n { \bool_if:NF ##1 { negative~ } assertion:~##2 } }
      \cs_set_nopar:Npn \regex_b_test: { word~boundary }
      \cs_set_eq:NN \regex_anchor:N \regex_show_anchor_to_str:N
      \cs_set_protected:Npn \regex_item_caseful_equal:n ##1
        { \regex_show_one:n { char~code~\int_eval:n{##1} } }
      \cs_set_protected:Npn \regex_item_caseful_range:nn ##1##2
        { \regex_show_one:n { range~[\int_eval:n{##1}, \int_eval:n{##2}] } }
      \cs_set_protected:Npn \regex_item_caseless_equal:n ##1
        { \regex_show_one:n { char~code~\int_eval:n{##1}~(caseless) } }
      \cs_set_protected:Npn \regex_item_caseless_range:nn ##1##2
        {
          \regex_show_one:n
            { Range~[\int_eval:n{##1}, \int_eval:n{##2}]~(caseless) }
        }
      \cs_set_protected:Npn \regex_item_catcode:nT
        { \regex_show_item_catcode:NnT \c_true_bool }
      \cs_set_protected:Npn \regex_item_catcode_reverse:nT
        { \regex_show_item_catcode:NnT \c_false_bool }
      \cs_set_protected:Npn \regex_item_reverse:n
        { \regex_show_scope:nn { Reversed~match } }
      \cs_set_protected:Npn \regex_item_exact:nn ##1##2
        { \regex_show_one:n { char~##2,~catcode~##1 } }
      \cs_set_protected:Npn \regex_item_exact_cs:c ##1
        { \regex_show_one:n { control~sequence~\iow_char:N\\##1 } }
      \cs_set_protected:Npn \regex_item_cs:n
        { \regex_show_scope:nn { control~sequence } }
      \cs_set:cpn { regex_prop_.: } { \regex_show_one:n { any~token } }
      \seq_clear:N \l_regex_show_prefix_seq
      \regex_show_push:n { ~ }
      #1
    \tl_build_end:
    \msg_aux_show:x { > Compiled~regex~#2: \l_regex_internal_a_tl }
  }
\cs_new_protected:Npn \regex_show_one:n #1
  {
    \int_incr:N \l_regex_show_lines_int
    \tl_build_one:x
      { \iow_newline: \seq_use:N \l_regex_show_prefix_seq #1 }
  }
\cs_new_protected:Npn \regex_show_push:n #1
  { \seq_put_right:Nx \l_regex_show_prefix_seq { #1 ~ } }
\cs_new_protected:Npn \regex_show_pop:
  { \seq_pop_right:NN \l_regex_show_prefix_seq \l_regex_internal_a_tl }
\cs_new_protected:Npn \regex_show_scope:nn #1#2
  {
    \regex_show_one:n {#1}
    \regex_show_push:n { ~ }
    #2
    \regex_show_pop:
  }
\cs_new_protected:Npn \regex_show_group_aux:nnnnN #1#2#3#4#5
  {
    \regex_show_one:n { ,-group~begin #1 }
    \regex_show_push:n { | }
    \use_ii:nn #2
    \regex_show_pop:
    \regex_show_one:n
      { `-group~end \regex_msg_repeated:nnN {#3} {#4} #5 }
  }
\cs_set:Npn \regex_show_class:NnnnN #1#2#3#4#5
  {
    \tl_set_build:Nw \l_regex_internal_a_tl
      \int_zero:N \l_regex_show_lines_int
      \regex_show_push:n {~}
      #2
      \exp_last_unbraced:Nf
    \prg_case_int:nnn { \l_regex_show_lines_int }
      {
        {0}
          {
            \tl_build_end:
            \regex_show_one:n { \bool_if:NTF #1 { Fail } { Pass } }
          }
        {1}
          {
            \tl_build_end:
            \bool_if:NTF #1
              {
                #2
                \tl_build_one:n { \regex_msg_repeated:nnN {#3} {#4} #5 }
              }
              {
                \regex_show_one:n
                  { Don't~match~\regex_msg_repeated:nnN {#3} {#4} #5 }
                \tl_build_one:o \l_regex_internal_a_tl
              }
          }
      }
      {
        \tl_build_end:
        \regex_show_one:n
          {
            \bool_if:NTF #1 { M } { Don't~m } atch
            \regex_msg_repeated:nnN {#3} {#4} #5
          }
        \tl_build_one:o \l_regex_internal_a_tl
      }
  }
\cs_new:Npn \regex_show_anchor_to_str:N #1
  {
    anchor~at~
    \prg_case_str:nnn { #1 }
      {
        { \l_regex_min_pos_int   } { start~(\iow_char:N\\A) }
        { \l_regex_start_pos_int } { start~of~match~(\iow_char:N\\G) }
        { \l_regex_max_pos_int   } { end~(\iow_char:N\\Z) }
      }
      { <error:~'#1'~not~recognized> }
  }
\cs_new_protected:Npn \regex_show_item_catcode:NnT #1#2
  {
    \seq_set_split:Nnn \l_regex_internal_seq { } { CBEMTPUDSLOA }
    \seq_set_filter:NNn \l_regex_internal_seq \l_regex_internal_seq
      { \int_if_odd_p:n { #2 / \int_use:c { c_regex_catcode_##1_int } } }
    \regex_show_scope:nn
      {
        categories~\seq_use:N \l_regex_internal_seq, ~
        \bool_if:NF #1 { negative~ } class
      }
  }
\int_new:N  \l_regex_min_state_int
\int_new:N  \l_regex_max_state_int
\int_new:N  \l_regex_left_state_int
\int_new:N  \l_regex_right_state_int
\seq_new:N  \l_regex_left_state_seq
\seq_new:N  \l_regex_right_state_seq
\int_new:N  \l_regex_capturing_group_int
\cs_new_protected:Npn \regex_build:n #1
  {
    \regex_compile:n {#1}
    \regex_build:N \l_regex_internal_regex
  }
\cs_new_protected:Npn \regex_build:N #1
  {
    \int_set:Nn \tex_escapechar:D { 92 }
    \int_zero:N \l_regex_capturing_group_int
    \int_set_eq:NN \l_regex_max_state_int \l_regex_min_state_int
    \regex_build_new_state:
    \regex_build_new_state:
    \regex_toks_put_right:Nn \l_regex_left_state_int
      { \regex_action_start_wildcard: }
    \regex_group:nnnN {#1} { 1 } { 0 } \c_false_bool
    \regex_toks_put_right:Nn \l_regex_right_state_int
      { \regex_action_success: }
  }
\cs_new_protected:Npn \regex_build_for_cs:n #1
  {
    \int_set_eq:NN \l_regex_max_state_int \l_regex_min_state_int
    \regex_build_new_state:
    \regex_build_new_state:
    \regex_push_lr_states:
    #1
    \regex_pop_lr_states:
    \regex_toks_put_right:Nn \l_regex_right_state_int
      {
        \if_num:w \l_regex_current_pos_int = \l_regex_max_pos_int
          \exp_after:wN \regex_action_success:
        \fi:
      }
  }
\cs_new_protected_nopar:Npn \regex_push_lr_states:
  {
    \seq_push:No \l_regex_left_state_seq
      { \int_use:N \l_regex_left_state_int }
    \seq_push:No \l_regex_right_state_seq
      { \int_use:N \l_regex_right_state_int }
  }
\cs_new_protected_nopar:Npn \regex_pop_lr_states:
  {
    \seq_pop:NN \l_regex_left_state_seq  \l_regex_internal_a_tl
    \int_set:Nn \l_regex_left_state_int  \l_regex_internal_a_tl
    \seq_pop:NN \l_regex_right_state_seq \l_regex_internal_a_tl
    \int_set:Nn \l_regex_right_state_int \l_regex_internal_a_tl
  }
\cs_new_protected:Npn \regex_toks_put_left:Nx #1#2
  {
    \cs_set_nopar:Npx \regex_tmp:w { #2 }
    \tex_toks:D #1 \exp_after:wN \exp_after:wN \exp_after:wN
      { \exp_after:wN \regex_tmp:w \tex_the:D \tex_toks:D #1 }
  }
\cs_new_protected:Npn \regex_toks_put_right:Nx #1#2
  {
    \cs_set_nopar:Npx \regex_tmp:w {#2}
    \tex_toks:D #1 \exp_after:wN
      { \tex_the:D \tex_toks:D \exp_after:wN #1 \regex_tmp:w }
  }
\cs_new_protected:Npn \regex_toks_put_right:Nn #1#2
  { \tex_toks:D #1 \exp_after:wN { \tex_the:D \tex_toks:D #1 #2 } }
\cs_new_protected:Npn \regex_build_transition_left:NNN #1#2#3
  { \regex_toks_put_left:Nx  #2 { #1 { \int_eval:n { #3 - #2 } } } }
\cs_new_protected:Npn \regex_build_transition_right:nNn #1#2#3
  { \regex_toks_put_right:Nx #2 { #1 { \int_eval:n { #3 - #2 } } } }
\cs_new_protected_nopar:Npn \regex_build_new_state:
  {
    \tex_toks:D \l_regex_max_state_int { }
    \int_set_eq:NN \l_regex_left_state_int \l_regex_right_state_int
    \int_set_eq:NN \l_regex_right_state_int \l_regex_max_state_int
    \int_incr:N \l_regex_max_state_int
  }
\cs_new_protected:Npn \regex_build_transitions_lazyness:NNNNN #1#2#3#4#5
  {
    \regex_build_new_state:
    \regex_toks_put_right:Nx \l_regex_left_state_int
      {
        \if_meaning:w \c_true_bool #1
          #2 { \int_eval:n { #3 - \l_regex_left_state_int } }
          #4 { \int_eval:n { #5 - \l_regex_left_state_int } }
        \else:
          #4 { \int_eval:n { #5 - \l_regex_left_state_int } }
          #2 { \int_eval:n { #3 - \l_regex_left_state_int } }
        \fi:
      }
  }
\cs_new_protected:Npn \regex_class:NnnnN #1#2#3#4#5
  {
    \cs_set_nopar:Npx \regex_tests_action_cost:n ##1
      {
        \exp_not:n { \exp_not:n {#2} }
        \bool_if:NTF #1
          { \regex_break_point:TF { \regex_action_cost:n {##1} } { } }
          { \regex_break_point:TF { } { \regex_action_cost:n {##1} } }
      }
    \if_case:w - #4 \exp_stop_f:
           \regex_class_repeat:n   {#3}
    \or:   \regex_class_repeat:nN  {#3}      #5
    \else: \regex_class_repeat:nnN {#3} {#4} #5
    \fi:
  }
\cs_new:Npn \regex_tests_action_cost:n { \regex_action_cost:n }
\cs_new_protected:Npn \regex_class_repeat:n #1
  {
    \prg_replicate:nn {#1}
      {
        \regex_build_new_state:
        \regex_build_transition_right:nNn \regex_tests_action_cost:n
          \l_regex_left_state_int \l_regex_right_state_int
      }
  }
\cs_new_protected:Npn \regex_class_repeat:nN #1#2
  {
    \if_num:w #1 = \c_zero
      \regex_build_transitions_lazyness:NNNNN #2
        \regex_action_free:n       \l_regex_right_state_int
        \regex_tests_action_cost:n \l_regex_left_state_int
    \else:
      \regex_class_repeat:n {#1}
      \int_set_eq:NN \l_regex_internal_a_int \l_regex_left_state_int
      \regex_build_transitions_lazyness:NNNNN #2
        \regex_action_free:n \l_regex_right_state_int
        \regex_action_free:n \l_regex_internal_a_int
    \fi:
  }
\cs_new_protected:Npn \regex_class_repeat:nnN #1#2#3
  {
    \regex_class_repeat:n {#1}
    \int_set:Nn \l_regex_internal_a_int
      { \l_regex_max_state_int + #2 - \c_one }
    \prg_replicate:nn { #2 }
      {
        \regex_build_transitions_lazyness:NNNNN #3
          \regex_action_free:n       \l_regex_internal_a_int
          \regex_tests_action_cost:n \l_regex_right_state_int
      }
  }
\cs_new_protected:Npn \regex_group_aux:nnnnN #1#2#3#4#5
  {
      \if_num:w #3 = \c_zero
        \regex_build_new_state:
        \regex_build_transition_right:nNn \regex_action_free_group:n
          \l_regex_left_state_int \l_regex_right_state_int
      \fi:
      \regex_build_new_state:
      \regex_push_lr_states:
      #2
      \regex_pop_lr_states:
      \if_case:w - #4 \exp_stop_f:
             \regex_group_repeat:nn   {#1} {#3}
      \or:   \regex_group_repeat:nnN  {#1} {#3}      #5
      \else: \regex_group_repeat:nnnN {#1} {#3} {#4} #5
      \fi:
  }
\cs_new_protected:Npn \regex_group:nnnN #1
  {
    \exp_args:No \regex_group_aux:nnnnN
      { \int_use:N \l_regex_capturing_group_int }
      {
        \int_incr:N \l_regex_capturing_group_int
        #1
      }
  }
\cs_new_protected_nopar:Npn \regex_group_no_capture:nnnN
  { \regex_group_aux:nnnnN { -1 } }
\cs_new_protected:Npn \regex_group_resetting:nnnN #1
  {
    \regex_group_aux:nnnnN { -1 }
      {
        \exp_args:Noo \regex_group_resetting_loop:nnNn
          { \int_use:N \l_regex_capturing_group_int }
          { \int_use:N \l_regex_capturing_group_int }
          #1
          { ?? \prg_map_break:n } { }
        \prg_break_point:n { }
      }
  }
\cs_new_protected:Npn \regex_group_resetting_loop:nnNn #1#2#3#4
  {
    \use_none:nn #3 { \int_set:Nn \l_regex_capturing_group_int {#1} }
    \int_set:Nn \l_regex_capturing_group_int {#2}
    #3 {#4}
    \exp_args:Nf \regex_group_resetting_loop:nnNn
      { \int_max:nn {#1} { \l_regex_capturing_group_int } }
      {#2}
  }
\cs_new_protected:Npn \regex_branch:n #1
  {
    \regex_build_new_state:
    \seq_get:NN \l_regex_left_state_seq \l_regex_internal_a_tl
    \int_set:Nn \l_regex_left_state_int \l_regex_internal_a_tl
    \regex_build_transition_right:nNn \regex_action_free:n
      \l_regex_left_state_int \l_regex_right_state_int
    #1
    \seq_get:NN \l_regex_right_state_seq \l_regex_internal_a_tl
    \regex_build_transition_right:nNn \regex_action_free:n
      \l_regex_right_state_int \l_regex_internal_a_tl
  }
\cs_new_protected:Npn \regex_group_repeat:nn #1#2
  {
    \if_num:w #2 = \c_zero
      \int_set:Nn \l_regex_max_state_int
        { \l_regex_left_state_int - \c_one }
      \regex_build_new_state:
    \else:
      \regex_group_repeat_aux:n {#2}
      \regex_group_submatches:nNN {#1}
        \l_regex_internal_a_int \l_regex_right_state_int
      \regex_build_new_state:
    \fi:
  }
\cs_new_protected:Npn \regex_group_submatches:nNN #1#2#3
  {
    \if_num:w #1 > \c_minus_one
      \regex_toks_put_left:Nx #2 { \regex_action_submatch:n { #1 < } }
      \regex_toks_put_left:Nx #3 { \regex_action_submatch:n { #1 > } }
    \fi:
  }
\cs_new_protected:Npn \regex_group_repeat_aux:n #1
  {
    \regex_build_transition_right:nNn \regex_action_free:n
      \l_regex_right_state_int \l_regex_max_state_int
    \int_set_eq:NN \l_regex_internal_a_int \l_regex_left_state_int
    \int_set_eq:NN \l_regex_internal_b_int \l_regex_max_state_int
    \if_num:w \int_eval:w #1 > \c_one
      \int_set:Nn \l_regex_internal_c_int
        {
          ( #1 - \c_one )
          * ( \l_regex_internal_b_int - \l_regex_internal_a_int )
        }
      \tex_advance:D \l_regex_right_state_int \l_regex_internal_c_int
      \tex_advance:D \l_regex_max_state_int   \l_regex_internal_c_int
      \prg_replicate:nn \l_regex_internal_c_int
        {
          \tex_toks:D \l_regex_internal_b_int
            = \tex_toks:D \l_regex_internal_a_int
          \tex_advance:D \l_regex_internal_a_int \c_one
          \tex_advance:D \l_regex_internal_b_int \c_one
        }
    \fi:
  }
\cs_new_protected:Npn \regex_group_repeat:nnN #1#2#3
  {
    \if_num:w #2 = \c_zero
      \regex_group_submatches:nNN {#1}
        \l_regex_left_state_int \l_regex_right_state_int
      \int_set:Nn \l_regex_internal_a_int
        { \l_regex_left_state_int - \c_one }
      \regex_build_transition_right:nNn \regex_action_free:n
        \l_regex_right_state_int \l_regex_internal_a_int
      \regex_build_new_state:
      \if_meaning:w \c_true_bool #3
        \regex_build_transition_left:NNN \regex_action_free:n
          \l_regex_internal_a_int \l_regex_right_state_int
      \else:
        \regex_build_transition_right:nNn \regex_action_free:n
          \l_regex_internal_a_int \l_regex_right_state_int
      \fi:
    \else:
      \regex_group_repeat_aux:n {#2}
      \regex_group_submatches:nNN {#1}
        \l_regex_internal_a_int \l_regex_right_state_int
      \if_meaning:w \c_true_bool #3
        \regex_build_transition_right:nNn \regex_action_free_group:n
          \l_regex_right_state_int \l_regex_internal_a_int
      \else:
        \regex_build_transition_left:NNN \regex_action_free_group:n
          \l_regex_right_state_int \l_regex_internal_a_int
      \fi:
      \regex_build_new_state:
    \fi:
  }
\cs_new_protected:Npn \regex_group_repeat:nnnN #1#2#3#4
  {
    \regex_group_submatches:nNN {#1}
      \l_regex_left_state_int \l_regex_right_state_int
    \regex_group_repeat_aux:n { #2 + #3 }
    \if_meaning:w \c_true_bool #4
      \int_set_eq:NN \l_regex_left_state_int \l_regex_max_state_int
      \prg_replicate:nn { #3 }
        {
          \int_sub:Nn \l_regex_left_state_int
            { \l_regex_internal_b_int - \l_regex_internal_a_int }
          \regex_build_transition_left:NNN \regex_action_free:n
            \l_regex_left_state_int \l_regex_max_state_int
        }
    \else:
      \prg_replicate:nn { #3 - \c_one }
        {
          \int_sub:Nn \l_regex_right_state_int
            { \l_regex_internal_b_int - \l_regex_internal_a_int }
          \regex_build_transition_right:nNn \regex_action_free:n
            \l_regex_right_state_int \l_regex_max_state_int
        }
      \if_num:w #2 = \c_zero
        \int_set:Nn \l_regex_right_state_int
          { \l_regex_left_state_int - \c_one }
      \else:
        \int_sub:Nn \l_regex_right_state_int
          { \l_regex_internal_b_int - \l_regex_internal_a_int }
      \fi:
      \regex_build_transition_right:nNn \regex_action_free:n
        \l_regex_right_state_int \l_regex_max_state_int
    \fi:
    \regex_build_new_state:
  }
\cs_new_protected:Npn \regex_assertion:Nn #1#2
  {
    \regex_build_new_state:
    \regex_toks_put_right:Nx \l_regex_left_state_int
      {
        \exp_not:n {#2}
        \regex_break_point:TF
          \bool_if:NF #1 { { } }
          {
            \regex_action_free:n
              {
                \int_eval:n
                  { \l_regex_right_state_int - \l_regex_left_state_int }
              }
          }
          \bool_if:NT #1 { { } }
      }
  }
\cs_new_protected:Npn \regex_anchor:N #1
  {
    \if_num:w #1 = \l_regex_current_pos_int
      \exp_after:wN \regex_break_true:w
    \fi:
  }
\cs_new_protected_nopar:Npn \regex_b_test:
  {
    \group_begin:
      \int_set_eq:NN \l_regex_current_char_int \l_regex_last_char_int
      \regex_prop_w:
      \regex_break_point:TF
        { \group_end: \regex_item_reverse:n \regex_prop_w: }
        { \group_end: \regex_prop_w: }
  }
\cs_new_protected_nopar:Npn \regex_command_K:
  {
    \regex_build_new_state:
    \regex_toks_put_right:Nx \l_regex_left_state_int
      {
        \regex_action_submatch:n { 0< }
        \bool_set_true:N \l_regex_fresh_thread_bool
        \regex_action_free:n
          { \int_eval:n { \l_regex_right_state_int - \l_regex_left_state_int } }
        \bool_set_false:N \l_regex_fresh_thread_bool
      }
  }
\int_new:N \l_regex_min_pos_int
\int_new:N \l_regex_max_pos_int
\int_new:N \l_regex_current_pos_int
\int_new:N \l_regex_start_pos_int
\int_new:N \l_regex_success_pos_int
\int_new:N \l_regex_current_char_int
\int_new:N \l_regex_current_catcode_int
\int_new:N \l_regex_last_char_int
\int_new:N \l_regex_case_changed_char_int
\int_new:N \l_regex_current_state_int
\prop_new:N \l_regex_current_submatches_prop
\prop_new:N \l_regex_success_submatches_prop
\int_new:N \l_regex_step_int
\int_new:N \l_regex_min_active_int
\int_new:N \l_regex_max_active_int
\tl_new:N \l_regex_every_match_tl
\bool_new:N \l_regex_fresh_thread_bool
\bool_new:N \l_regex_empty_success_bool
\cs_new_eq:NN \regex_if_two_empty_matches:F \use:n
\bool_new:N \g_regex_success_bool
\bool_new:N \l_regex_saved_success_bool
\bool_new:N \l_regex_match_success_bool
\cs_new_protected:Npn \regex_match:n #1
  {
    \int_zero:N \l_regex_balance_int
    \int_set:Nn \l_regex_current_pos_int { \c_two * \l_regex_max_state_int }
    \regex_query_set:nnn { } { -1 } { -2 }
    \int_set_eq:NN \l_regex_min_pos_int \l_regex_current_pos_int
    \tl_analysis_map_inline:nn {#1}
      { \regex_query_set:nnn {##1} {"##2} {##3} }
    \int_set_eq:NN \l_regex_max_pos_int \l_regex_current_pos_int
    \regex_query_set:nnn { } { -1 } { -2 }
    \bool_gset_false:N \g_regex_success_bool
    \prg_stepwise_inline:nnnn
      \l_regex_min_state_int \c_one { \l_regex_max_state_int - \c_one }
      { \tex_dimen:D ##1 \c_one sp \scan_stop: }
    \int_set_eq:NN \l_regex_min_active_int \l_regex_max_state_int
    \int_set_eq:NN \l_regex_step_int \c_zero
    \int_set_eq:NN \l_regex_success_pos_int \l_regex_min_pos_int
    \int_set:Nn \l_regex_submatch_int
      { \c_two * \l_regex_max_state_int }
    \bool_set_false:N \l_regex_empty_success_bool
    \regex_match_once:
  }
\cs_new_protected_nopar:Npn \regex_match_once:
  {
    \if_meaning:w \c_true_bool \l_regex_empty_success_bool
      \cs_set_nopar:Npn \regex_if_two_empty_matches:F
        { \int_compare:nNnF \l_regex_start_pos_int = \l_regex_current_pos_int }
    \else:
      \cs_set_eq:NN \regex_if_two_empty_matches:F \use:n
    \fi:
    \int_set_eq:NN \l_regex_start_pos_int \l_regex_success_pos_int
    \bool_set_false:N \l_regex_match_success_bool
    \prop_clear:N \l_regex_current_submatches_prop
    \int_set_eq:NN \l_regex_max_active_int \l_regex_min_active_int
    \regex_store_state:n { \l_regex_min_state_int }
    \int_set:Nn \l_regex_current_pos_int
      { \l_regex_start_pos_int - \c_one }
    \regex_query_get:
    \regex_match_loop:
    \l_regex_every_match_tl
  }
\cs_new_protected_nopar:Npn \regex_single_match:
  {
    \tl_set:Nn \l_regex_every_match_tl
      { \bool_gset_eq:NN \g_regex_success_bool \l_regex_match_success_bool }
  }
\cs_new_protected:Npn \regex_multi_match:n #1
  {
    \tl_set:Nn \l_regex_every_match_tl
      {
        \if_meaning:w \c_true_bool \l_regex_match_success_bool
          \bool_gset_true:N \g_regex_success_bool
          #1
          \exp_after:wN \regex_match_once:
        \fi:
      }
  }
\cs_new_protected_nopar:Npn \regex_match_loop:
  {
    \tex_advance:D \l_regex_step_int \c_two
    \int_incr:N \l_regex_current_pos_int
    \int_set_eq:NN \l_regex_last_char_int \l_regex_current_char_int
    \int_set_eq:NN \l_regex_case_changed_char_int \c_max_int
    \regex_query_get:
    \use:x
      {
        \int_set_eq:NN \l_regex_max_active_int \l_regex_min_active_int
        \exp_after:wN \regex_match_one_active:w
          \int_use:N \l_regex_min_active_int ;
      }
    \prg_break_point:n { \bool_set_false:N \l_regex_fresh_thread_bool }
    \if_num:w \l_regex_max_active_int > \l_regex_min_active_int
      \if_num:w \l_regex_current_pos_int < \l_regex_max_pos_int
        \exp_after:wN \exp_after:wN \exp_after:wN \regex_match_loop:
      \fi:
    \fi:
  }
\cs_new:Npn \regex_match_one_active:w #1;
  {
    \if_num:w #1 < \l_regex_max_active_int
      \regex_use_state_and_submatches:nn
        { \int_value:w \tex_skip:D #1 }
        { \tex_the:D \tex_toks:D #1 }
      \exp_after:wN \regex_match_one_active:w
        \int_use:N \int_eval:w #1 + \c_one \exp_after:wN ;
    \fi:
  }
\cs_new_protected:Npn \regex_query_set:nnn #1#2#3
  {
    \tex_muskip:D \l_regex_current_pos_int
      = \etex_gluetomu:D
        #3 sp
        plus #2 sp
        minus \l_regex_balance_int sp
      \scan_stop:
    \tex_toks:D \l_regex_current_pos_int {#1}
    \int_incr:N \l_regex_current_pos_int
    \if_case:w #2 \exp_stop_f:
    \or: \int_incr:N \l_regex_balance_int
    \or: \int_decr:N \l_regex_balance_int
    \fi:
  }
\cs_new_protected_nopar:Npn \regex_query_get:
  {
    \l_regex_current_char_int
      = \etex_mutoglue:D \tex_muskip:D \l_regex_current_pos_int
    \l_regex_current_catcode_int = \etex_gluestretch:D
      \etex_mutoglue:D \tex_muskip:D \l_regex_current_pos_int
  }
\cs_new_protected_nopar:Npn \regex_use_state:
  {
    \tex_dimen:D \l_regex_current_state_int
      = \l_regex_step_int sp \scan_stop:
    \tex_the:D \tex_toks:D \l_regex_current_state_int
    \tex_dimen:D \l_regex_current_state_int
      = \int_eval:w \l_regex_step_int + \c_one \int_eval_end: sp \scan_stop:
  }
\cs_new_protected:Npn \regex_use_state_and_submatches:nn #1 #2
  {
    \int_set:Nn \l_regex_current_state_int {#1}
    \if_num:w \tex_dimen:D \l_regex_current_state_int < \l_regex_step_int
      \tl_set:Nn \l_regex_current_submatches_prop {#2}
      \exp_after:wN \regex_use_state:
    \fi:
    \scan_stop:
  }
\cs_new_protected_nopar:Npn \regex_action_start_wildcard:
  {
    \bool_set_true:N \l_regex_fresh_thread_bool
    \regex_action_free:n {1}
    \bool_set_false:N \l_regex_fresh_thread_bool
    \regex_action_cost:n {0}
  }
\cs_new_protected_nopar:Npn \regex_action_free:n
  { \regex_action_free_aux:nn { > \l_regex_step_int \else: } }
\cs_new_protected_nopar:Npn \regex_action_free_group:n
  { \regex_action_free_aux:nn { < \l_regex_step_int } }
\cs_new_protected:Npn \regex_action_free_aux:nn #1#2
  {
    \use:x
      {
        \int_add:Nn \l_regex_current_state_int {#2}
        \exp_not:n
          {
            \if_num:w \tex_dimen:D \l_regex_current_state_int #1
              \exp_after:wN \regex_use_state:
            \fi:
          }
        \int_set:Nn \l_regex_current_state_int
          { \int_use:N \l_regex_current_state_int }
        \tl_set:Nn \exp_not:N \l_regex_current_submatches_prop
          { \exp_not:o \l_regex_current_submatches_prop }
      }
  }
\cs_new_protected:Npn \regex_action_cost:n #1
  {
    \exp_args:No \regex_store_state:n
      { \int_use:N \int_eval:w \l_regex_current_state_int + #1 }
  }
\cs_new_protected:Npn \regex_store_state:n #1
  {
    \regex_store_submatches:
    \tex_skip:D \l_regex_max_active_int = #1 sp \scan_stop:
    \int_incr:N \l_regex_max_active_int
  }
\cs_new_protected_nopar:Npn \regex_store_submatches:
  {
    \tex_toks:D \l_regex_max_active_int \exp_after:wN
      { \l_regex_current_submatches_prop }
  }
\cs_new_protected_nopar:Npn \regex_disable_submatches:
  {
    \cs_set_protected_nopar:Npn \regex_store_submatches: { }
    \cs_set_protected:Npn \regex_action_submatch:n ##1 { }
  }
\cs_new_protected:Npn \regex_action_submatch:n #1
  {
    \prop_put:Nno \l_regex_current_submatches_prop {#1}
      { \int_use:N \l_regex_current_pos_int }
  }
\cs_new_protected_nopar:Npn \regex_action_success:
  {
    \regex_if_two_empty_matches:F
      {
        \bool_set_true:N \l_regex_match_success_bool
        \bool_set_eq:NN \l_regex_empty_success_bool
          \l_regex_fresh_thread_bool
        \int_set_eq:NN \l_regex_success_pos_int \l_regex_current_pos_int
        \prop_set_eq:NN \l_regex_success_submatches_prop
          \l_regex_current_submatches_prop
        \prg_map_break:
      }
  }
\int_new:N \l_regex_replacement_csnames_int
\tl_new:N \l_regex_balance_tl
\cs_new:Npn \regex_replacement_balance_one_match:n #1
  { - \regex_submatch_balance:n {#1} }
\cs_new:Npn \regex_replacement_do_one_match:n #1
  {
    \regex_query_range:nn
      { \etex_glueshrink:D \tex_skip:D #1 }
      { \tex_skip:D #1 }
  }
\cs_new:Npn \regex_replacement_exp_not:N #1 { \exp_not:n {#1} }
\cs_new:Npn \regex_query_range:nn #1#2
  {
    \exp_after:wN \regex_query_range_loop:ww
    \int_use:N \int_eval:w #1 \exp_after:wN ;
    \int_use:N \int_eval:w #2 ;
    \prg_break_point:n { }
  }
\cs_new:Npn \regex_query_range_loop:ww #1 ; #2 ;
  {
    \if_num:w #1 < #2 \exp_stop_f:
    \else:
      \exp_after:wN \prg_map_break:
    \fi:
    \tex_the:D \tex_toks:D #1 \exp_stop_f:
    \exp_after:wN \regex_query_range_loop:ww
      \int_use:N \int_eval:w #1 + \c_one ; #2 ;
  }
\cs_new:Npn \regex_query_submatch:n #1
  {
    \regex_query_range:nn
      { \tex_skip:D \int_eval:w #1 }
      { \etex_gluestretch:D \tex_skip:D \int_eval:w #1 }
  }
\cs_new_protected:Npn \regex_submatch_balance:n #1
  {
    \etex_glueshrink:D \etex_mutoglue:D \etex_muexpr:D
      \tex_muskip:D \etex_gluestretch:D \tex_skip:D #1
      - \tex_muskip:D \tex_skip:D #1
    \scan_stop:
  }
\cs_new_protected:Npn \regex_replacement:n #1
  {
    \tl_set_build:Nw \l_regex_internal_a_tl
      \int_zero:N \l_regex_balance_int
      \tl_clear:N \l_regex_balance_tl
      \regex_escape_use:nnnn
        {
          \if_charcode:w \c_rbrace_str ##1
            \regex_replacement_rbrace:N \else: \tl_build_one:n \fi: ##1
        }
        { \regex_replacement_escaped:N ##1 }
        { \tl_build_one:n ##1 }
        {#1}
      \prg_do_nothing: \prg_do_nothing:
      \if_int_compare:w \l_regex_replacement_csnames_int > \c_zero
        \msg_kernel_error:nnx { regex } { replacement-missing-rbrace }
          { \int_use:N \l_regex_replacement_csnames_int }
        \tl_build_one:x
          { \prg_replicate:nn \l_regex_replacement_csnames_int \cs_end: }
      \fi:
      \cs_gset:Npx \regex_replacement_balance_one_match:n ##1
        {
          + \int_use:N \l_regex_balance_int
          \l_regex_balance_tl
          - \regex_submatch_balance:n {##1}
        }
    \tl_build_end:
    \exp_args:No \regex_replacement_aux:n \l_regex_internal_a_tl
  }
\cs_new_protected:Npn \regex_replacement_aux:n #1
  {
    \cs_set:Npn \regex_replacement_do_one_match:n ##1
      {
        \regex_query_range:nn
          { \etex_glueshrink:D \tex_skip:D ##1 }
          { \tex_skip:D ##1 }
        #1
      }
  }
\cs_new_protected:Npn \regex_replacement_escaped:N #1
  {
    \cs_if_exist_use:cF { regex_replacement_#1:w }
      {
        \if_num:w \c_one < 1#1 \exp_stop_f:
          \regex_replacement_put_submatch:n {#1}
        \else:
          \tl_build_one:n #1
        \fi:
      }
  }
\cs_new_protected:Npn \regex_replacement_put_submatch:n #1
  {
    \if_num:w #1 < \l_regex_capturing_group_int
      \tl_build_one:n { \regex_query_submatch:n { #1 + ##1 } }
      \if_num:w \l_regex_replacement_csnames_int = \c_zero
        \tl_put_right:Nn \l_regex_balance_tl
          { + \regex_submatch_balance:n { \int_eval:w #1+##1 \int_eval_end: } }
      \fi:
    \fi:
  }
\cs_new_protected:Npn \regex_replacement_g:w #1#2
  {
    \str_if_eq:xxTF { #1#2 } { \tl_build_one:n \c_lbrace_str }
      {
        \int_zero:N \l_regex_internal_a_int
        \regex_replacement_g_digits:NN
      }
      { \regex_replacement_error:NNN g #1 #2 }
  }
\cs_new_protected:Npn \regex_replacement_g_digits:NN #1#2
  {
    \token_if_eq_meaning:NNTF #1 \tl_build_one:n
      {
        \if_num:w \c_one < 1#2 \exp_stop_f:
          \int_set:Nn \l_regex_internal_a_int
            { \c_ten * \l_regex_internal_a_int + #2 }
          \exp_after:wN \use_i:nnn
          \exp_after:wN \regex_replacement_g_digits:NN
        \else:
          \exp_after:wN \regex_replacement_error:NNN
          \exp_after:wN g
        \fi:
      }
      {
        \if_meaning:w \regex_replacement_rbrace:N #1
          \exp_args:No \regex_replacement_put_submatch:n
            { \int_use:N \l_regex_internal_a_int }
          \exp_after:wN \use_none:nn
        \else:
          \exp_after:wN \regex_replacement_error:NNN
          \exp_after:wN g
        \fi:
      }
    #1 #2
  }
\cs_new_protected:Npn \regex_replacement_c:w #1#2
  {
    \token_if_eq_meaning:NNTF #1 \tl_build_one:n
      {
        \cs_if_exist_use:cF { regex_replacement_c_#2:w }
          { \regex_replacement_error:NNN c #1#2 }
      }
      { \regex_replacement_error:NNN c #1#2 }
  }
\cs_new_protected_nopar:cpn { regex_replacement_c_ \c_lbrace_str :w }
  {
    \if_case:w \l_regex_replacement_csnames_int
      \tl_build_one:n
        { \exp_not:n { \exp_after:wN \regex_replacement_exp_not:N \cs:w } }
    \else:
      \tl_build_one:n { \exp_not:n { \exp_after:wN \tl_to_str:N \cs:w } }
    \fi:
    \int_incr:N \l_regex_replacement_csnames_int
  }
\cs_new_protected:Npn \regex_replacement_u:w #1#2
  {
    \str_if_eq:xxTF { #1#2 } { \tl_build_one:n \c_lbrace_str }
      {
        \if_case:w \l_regex_replacement_csnames_int
          \tl_build_one:n { \exp_not:n { \exp_after:wN \exp_not:V \cs:w } }
        \else:
          \tl_build_one:n { \exp_not:n { \exp_after:wN \tl_to_str:V \cs:w } }
        \fi:
        \int_incr:N \l_regex_replacement_csnames_int
      }
      { \regex_replacement_error:NNN u #1#2 }
  }
\cs_new_protected:Npn \regex_replacement_rbrace:N #1
  {
    \if_int_compare:w \l_regex_replacement_csnames_int > \c_zero
      \tl_build_one:n \cs_end:
      \int_decr:N \l_regex_replacement_csnames_int
    \else:
      \tl_build_one:n #1
    \fi:
  }
\group_begin:
  \cs_new_protected:Npn \regex_replacement_char:nNN #1#2#3
    {
      \if_meaning:w \prg_do_nothing: #3
        \msg_kernel_error:nn { regex } { replacement-catcode-end }
      \else:
        \tex_lccode:D \c_zero = `#3 \scan_stop:
        \tl_to_lowercase:n { \tl_build_one:n {#1} }
      \fi:
    }
  \char_set_catcode_active:N \^^@
  \cs_new_protected_nopar:Npn \regex_replacement_c_A:w
    { \regex_replacement_char:nNN { \exp_not:n { \exp_not:N ^^@ } } }
  \char_set_catcode_group_begin:N \^^@
  \cs_new_protected_nopar:Npn \regex_replacement_c_B:w
    {
      \if_num:w \l_regex_replacement_csnames_int = \c_zero
        \int_incr:N \l_regex_balance_int
      \fi:
      \regex_replacement_char:nNN
        { \exp_not:n { \exp_after:wN ^^@ \if_false: } \fi: } }
    }
  \cs_new_protected:Npn \regex_replacement_c_C:w #1#2
    { \tl_build_one:n { \exp_not:N \exp_not:N \exp_not:c {#2} } }
  \char_set_catcode_math_subscript:N \^^@
  \cs_new_protected_nopar:Npn \regex_replacement_c_D:w
    { \regex_replacement_char:nNN { ^^@ } }
  \char_set_catcode_group_end:N \^^@
  \cs_new_protected_nopar:Npn \regex_replacement_c_E:w
    {
      \if_num:w \l_regex_replacement_csnames_int = \c_zero
        \int_decr:N \l_regex_balance_int
      \fi:
      \regex_replacement_char:nNN
        { \exp_not:n { \if_false: { \fi:  ^^@ } }
    }
  \char_set_catcode_letter:N \^^@
  \cs_new_protected_nopar:Npn \regex_replacement_c_L:w
    { \regex_replacement_char:nNN { ^^@ } }
  \char_set_catcode_math_toggle:N \^^@
  \cs_new_protected_nopar:Npn \regex_replacement_c_M:w
    { \regex_replacement_char:nNN { ^^@ } }
  \char_set_catcode_other:N \^^@
  \cs_new_protected_nopar:Npn \regex_replacement_c_O:w
    { \regex_replacement_char:nNN { ^^@ } }
  \char_set_catcode_parameter:N \^^@
  \cs_new_protected_nopar:Npn \regex_replacement_c_P:w
    {
      \regex_replacement_char:nNN
        { \exp_not:n { \exp_not:n { ^^@^^@^^@^^@ } } }
    }
  \cs_new_protected:Npn \regex_replacement_c_S:w #1#2
    {
      \if_meaning:w \prg_do_nothing: #2
        \msg_kernel_error:nn { regex } { replacement-catcode-end }
      \else:
        \if_num:w `#2 = \c_zero
          \msg_kernel_error:nn { regex } { replacement-null-space }
        \fi:
        \tex_lccode:D 32 = `#2 \scan_stop:
        \tl_to_lowercase:n { \tl_build_one:n {~} }
      \fi:
    }
  \char_set_catcode_alignment:N \^^@
  \cs_new_protected_nopar:Npn \regex_replacement_c_T:w
    { \regex_replacement_char:nNN { ^^@ } }
  \char_set_catcode_math_superscript:N \^^@
  \cs_new_protected_nopar:Npn \regex_replacement_c_U:w
    { \regex_replacement_char:nNN { ^^@ } }
\group_end:
\cs_new_protected:Npn \regex_replacement_error:NNN #1#2#3
  {
    \msg_kernel_error:nnx { regex } { replacement-#1 } {#3}
    #2 #3
  }
\cs_new_protected:Npn \regex_new:N #1
  { \cs_new_eq:NN #1 \c_regex_no_match_regex }
\cs_new_protected_nopar:Npn \regex_set:Nn #1#2
  {
    \regex_compile:n {#2}
    \tl_set_eq:NN #1 \l_regex_internal_regex
  }
\cs_new_protected_nopar:Npn \regex_gset:Nn #1#2
  {
    \regex_compile:n {#2}
    \tl_gset_eq:NN #1 \l_regex_internal_regex
  }
\cs_new_protected_nopar:Npn \regex_const:Nn #1#2
  {
    \regex_compile:n {#2}
    \tl_const:Nx #1 { \exp_not:o \l_regex_internal_regex }
  }
\cs_new_protected:Npn \regex_show:n #1
  {
    \regex_compile:n {#1}
    \regex_show_aux:Nx \l_regex_internal_regex
      { { \tl_to_str:n {#1} } }
  }
\cs_new_protected:Npn \regex_show:N #1
  { \regex_show_aux:Nx #1 { variable~\token_to_str:N #1 } }
\prg_new_protected_conditional:Npnn \regex_match:nn #1#2 { T , F , TF }
  {
    \regex_match_aux:nn { \regex_build:n {#1} } {#2}
    \regex_aux_return:
  }
\prg_new_protected_conditional:Npnn \regex_match:Nn #1#2 { T , F , TF }
  {
    \regex_match_aux:nn { \regex_build:N #1 } {#2}
    \regex_aux_return:
  }
\cs_new_protected:Npn \regex_count:nnN #1
  { \regex_count_aux:nnN { \regex_build:n {#1} } }
\cs_new_protected:Npn \regex_count:NnN #1
  { \regex_count_aux:nnN { \regex_build:N #1 } }
\cs_set_protected:Npn \regex_tmp:w #1#2#3
  {
    \cs_new_protected:Npn #2 ##1 { #1 { \regex_build:n {##1} } }
    \cs_new_protected:Npn #3 ##1 { #1 { \regex_build:N  ##1  } }
    \prg_new_protected_conditional:Npnn #2 ##1##2##3 { T , F , TF }
      { #1 { \regex_build:n {##1} } {##2} ##3 \regex_aux_return: }
    \prg_new_protected_conditional:Npnn #3 ##1##2##3 { T , F , TF }
      { #1 { \regex_build:N  ##1  } {##2} ##3 \regex_aux_return: }
  }
\regex_tmp:w \regex_extract_once_aux:nnN
  \regex_extract_once:nnN \regex_extract_once:NnN
\regex_tmp:w \regex_extract_all_aux:nnN
  \regex_extract_all:nnN \regex_extract_all:NnN
\regex_tmp:w \regex_replace_once_aux:nnN
  \regex_replace_once:nnN \regex_replace_once:NnN
\regex_tmp:w \regex_replace_all_aux:nnN
  \regex_replace_all:nnN \regex_replace_all:NnN
\regex_tmp:w \regex_split_aux:nnN \regex_split:nnN \regex_split:NnN
\int_new:N \l_regex_match_count_int
\flag_new:n { regex_begin }
\flag_new:n { regex_end }
\int_new:N \l_regex_submatch_int
\int_new:N \l_regex_zeroth_submatch_int
\cs_new_protected_nopar:Npn \regex_aux_return:
  {
    \if_meaning:w \c_true_bool \g_regex_success_bool
      \prg_return_true:
    \else:
      \prg_return_false:
    \fi:
  }
\cs_new_protected:Npn \regex_match_aux:nn #1#2
  {
    \group_begin:
      \regex_disable_submatches:
      \regex_single_match:
      #1
      \regex_match:n {#2}
    \group_end:
  }
\cs_new_protected:Npn \regex_count_aux:nnN #1#2#3
  {
    \group_begin:
      \regex_disable_submatches:
      \int_zero:N \l_regex_match_count_int
      \regex_multi_match:n { \int_incr:N \l_regex_match_count_int }
      #1
      \regex_match:n {#2}
      \exp_args:NNNo
    \group_end:
    \int_set:Nn #3 { \int_use:N \l_regex_match_count_int }
  }
\cs_new_protected:Npn \regex_extract_once_aux:nnN #1#2#3
  {
    \group_begin:
      \regex_single_match:
      #1
      \regex_match:n {#2}
      \regex_extract:
    \regex_group_end_extract_seq:N #3
  }
\cs_new_protected:Npn \regex_extract_all_aux:nnN #1#2#3
  {
    \group_begin:
      \regex_multi_match:n { \regex_extract: }
      #1
      \regex_match:n {#2}
    \regex_group_end_extract_seq:N #3
  }
\cs_new_protected:Npn \regex_split_aux:nnN #1#2#3
  {
    \group_begin:
      \regex_multi_match:n
        {
          \if_num:w \l_regex_start_pos_int < \l_regex_success_pos_int
            \regex_extract:
            \tex_skip:D \l_regex_zeroth_submatch_int
              = \l_regex_start_pos_int sp
                plus \tex_skip:D \l_regex_zeroth_submatch_int \scan_stop:
          \fi:
        }
      #1
      \regex_match:n {#2}
      \tex_skip:D \l_regex_submatch_int
        = \l_regex_start_pos_int sp plus \l_regex_max_pos_int sp \scan_stop:
      \int_incr:N \l_regex_submatch_int
      \if_meaning:w \c_true_bool \l_regex_empty_success_bool
        \if_num:w \l_regex_start_pos_int = \l_regex_max_pos_int
          \int_decr:N \l_regex_submatch_int
        \fi:
      \fi:
    \regex_group_end_extract_seq:N #3
  }
\cs_new_protected:Npn \regex_group_end_extract_seq:N #1
  {
      \cs_set_eq:NN \seq_item:n \scan_stop:
      \flag_clear:n { regex_begin }
      \flag_clear:n { regex_end }
      \tl_set:Nx \l_regex_internal_a_tl
        {
          \prg_stepwise_function:nnnN
            { \c_two * \l_regex_max_state_int }
            \c_one
            { \l_regex_submatch_int - \c_one }
            \regex_extract_seq_aux:n
        }
      \int_compare:nNnF
        { \flag_height:n { regex_begin } + \flag_height:n { regex_end } }
        = \c_zero
        {
          \msg_kernel_error:nnxxx { regex } { result-unbalanced }
            { splitting~or~extracting~submatches }
            { \flag_height:n { regex_end } }
            { \flag_height:n { regex_begin } }
        }
      \use:x
        {
          \group_end:
          \tl_set:Nn \exp_not:N #1 { \l_regex_internal_a_tl }
        }
  }
\cs_new:Npn \regex_extract_seq_aux:n #1
  {
    \seq_item:n
      {
        \exp_after:wN \regex_extract_seq_aux:ww
        \int_value:w \regex_submatch_balance:n {#1} ; #1;
      }
  }
\cs_new:Npn \regex_extract_seq_aux:ww #1; #2;
  {
    \if_num:w #1 < \c_zero
      \flag_raise:n { regex_end }
      \prg_replicate:nn {-#1} { \exp_not:n { { \if_false: } \fi: } }
    \fi:
    \regex_query_submatch:n {#2}
    \if_num:w #1 > \c_zero
      \flag_raise:n { regex_begin }
      \prg_replicate:nn {#1} { \exp_not:n { \if_false: { \fi: } } }
    \fi:
  }
\cs_new_protected_nopar:Npn \regex_extract:
  {
    \if_meaning:w \c_true_bool \g_regex_success_bool
      \int_set_eq:NN \l_regex_zeroth_submatch_int \l_regex_submatch_int
      \prg_replicate:nn \l_regex_capturing_group_int
        {
          \tex_skip:D \l_regex_submatch_int \c_zero sp \scan_stop:
          \int_incr:N \l_regex_submatch_int
        }
      \prop_map_inline:Nn \l_regex_success_submatches_prop
        {
          \if_num:w ##1 \c_minus_one
            \exp_after:wN \regex_extract_aux_e:wn \int_value:w
          \else:
            \exp_after:wN \regex_extract_aux_b:wn \int_value:w
          \fi:
          \int_eval:w \l_regex_zeroth_submatch_int + ##1 {##2}
        }
      \tex_skip:D \l_regex_zeroth_submatch_int
        = \tex_the:D \tex_skip:D \l_regex_zeroth_submatch_int
          minus \l_regex_start_pos_int sp \scan_stop:
    \fi:
  }
\cs_new_protected:Npn \regex_extract_aux_b:wn #1 < #2
  {
    \tex_skip:D #1 = #2 sp
      plus \etex_gluestretch:D \tex_skip:D #1 \scan_stop:
  }
\cs_new_protected:Npn \regex_extract_aux_e:wn #1 > #2
  {
    \tex_skip:D #1
      = 1 \tex_skip:D #1 plus #2 sp \scan_stop:
  }
\cs_new_protected:Npn \regex_replace_once_aux:nnN #1#2#3
  {
    \group_begin:
      \regex_single_match:
      #1
      \regex_replacement:n {#2}
      \exp_args:No \regex_match:n { #3 }
      \if_meaning:w \c_false_bool \g_regex_success_bool
        \group_end:
      \else:
        \regex_extract:
        \int_set:Nn \l_regex_balance_int
          {
            \regex_replacement_balance_one_match:n
              { \l_regex_zeroth_submatch_int }
          }
        \tl_set:Nx \l_regex_internal_a_tl
          {
            \regex_replacement_do_one_match:n { \l_regex_zeroth_submatch_int }
            \regex_query_range:nn
              { \etex_gluestretch:D \tex_skip:D \l_regex_zeroth_submatch_int }
              { \l_regex_max_pos_int }
          }
        \regex_group_end_replace:N #3
      \fi:
  }
\cs_new_protected:Npn \regex_replace_all_aux:nnN #1#2#3
  {
    \group_begin:
      \regex_multi_match:n { \regex_extract: }
      #1
      \regex_replacement:n {#2}
      \exp_args:No \regex_match:n {#3}
      \int_set:Nn \l_regex_balance_int
        {
          0
          \prg_stepwise_function:nnnN
            { \c_two * \l_regex_max_state_int }
            \l_regex_capturing_group_int
            { \l_regex_submatch_int - \c_one }
            \regex_replacement_balance_one_match:n
        }
      \tl_set:Nx \l_regex_internal_a_tl
        {
          \prg_stepwise_function:nnnN
            { \c_two * \l_regex_max_state_int }
            \l_regex_capturing_group_int
            { \l_regex_submatch_int - \c_one }
            \regex_replacement_do_one_match:n
          \regex_query_range:nn
            \l_regex_start_pos_int \l_regex_max_pos_int
        }
    \regex_group_end_replace:N #3
  }
\cs_new_protected_nopar:Npn \regex_group_end_replace:N #1
  {
    \if_num:w \l_regex_balance_int = \c_zero
    \else:
      \msg_kernel_error:nnxxx { regex } { result-unbalanced }
        { replacing }
        { \int_max:nn { - \l_regex_balance_int } { \c_zero } }
        { \int_max:nn { \l_regex_balance_int } { \c_zero } }
    \fi:
    \use:x
      {
        \group_end:
        \tl_set:Nn \exp_not:N #1
          {
            \if_int_compare:w \l_regex_balance_int < \c_zero
              \prg_replicate:nn { - \l_regex_balance_int }
                { { \if_false: } \fi: }
            \fi:
            \l_regex_internal_a_tl
            \if_int_compare:w \l_regex_balance_int > \c_zero
              \prg_replicate:nn { \l_regex_balance_int }
                { \if_false: { \fi: } }
            \fi:
          }
      }
  }
\msg_kernel_new:nnnn { regex } { trailing-backslash }
  { Trailing~escape~character~\iow_char:N\\. }
  {
    A~regular~expression~or~its~replacement~text~ends~with~
    the~escape~character~\iow_char:N\\.~It~will~be~ignored.
  }
\msg_kernel_new:nnnn { regex } { x-missing-rbrace }
  { Missing~closing~brace~in~\iow_char:N\\x~hexadecimal~sequence. }
  {
    You~wrote~something~like~
    `\iow_char:N\\x\{\int_to_hexadecimal:n{#1}'.~
    The~closing~brace~is~missing.
  }
\msg_kernel_new:nnnn { regex } { x-overflow }
  { Character~code~'#1'~too~large~in~\iow_char:N\\x~hexadecimal~sequence. }
  {
    You~wrote~something~like~
    `\iow_char:N\\x\{\int_to_hexadecimal:n{#1}\}'.~
    The~character~code~'#1'~is~larger~than~\int_use:N \c_max_char_int.
  }
\msg_kernel_new:nnnn { regex } { invalid-quantifier }
  { Braced~quantifier~'#1'~may~not~be~followed~by~'#2'. }
  {
    The~character~'#2'~is~invalid~in~the~braced~quantifier~'#1'.~
    The~only~valid~quantifiers~are~'*',~'?',~'+',~'{<int>}',~
    '{<min>,}'~and~'{<min>,<max>}',~followed~or~not~by~'?'.
  }
\msg_kernel_new:nnnn { regex } { missing-rbrack }
  { Missing~right~bracket~inserted~in~regular~expression. }
  {
    LaTeX~was~given~a~regular~expression~where~a~character~class~
    was~started~with~'[',~but~the~matching~']'~is~missing.
  }
\msg_kernel_new:nnnn { regex } { missing-rparen }
  {
    Missing~right~parenthes\int_compare:nTF{#1=1}{i}{e}s~
    inserted~in~regular~expression.
  }
  {
    LaTeX~was~given~a~regular~expression~with~\int_eval:n{#1}~
    more~left~parenthes\int_compare:nTF{#1=1}{i}{e}s~than~right~
    parenthes\int_compare:nTF{#1=1}{i}{e}s.
  }
\msg_kernel_new:nnnn { regex } { extra-rparen }
  { Extra~right~parenthesis~ignored~in~regular~expression. }
  {
    LaTeX~came~across~a~closing~parenthesis~when~no~submatch~group~
    was~open.~The~parenthesis~will~be~ignored.
  }
\msg_kernel_new:nnnn { regex } { bad-escape }
  {
    Invalid~escape~\c_backslash_str #1~
    \regex_if_in_cs:TF { within~a~control~sequence. }
      {
        \regex_if_in_class:TF
          { in~a~character~class. }
          { following~a~category~test. }
      }
  }
  {
    The~escape~sequence~\iow_char:N\\#1~may~not~appear~
    \regex_if_in_cs:TF
      {
        within~a~control~sequence~test~introduced~by~
        \iow_char:N\\c\iow_char:N\{.
      }
      {
        \regex_if_in_class:TF
          { within~a~character~class~ }
          { following~a~category~test~such~as~\iow_char:N\\cL~ }
        because~it~does~not~match~exactly~one~character.
      }
  }
\msg_kernel_new:nnnn { regex } { range-missing-end }
  { Invalid~end-point~for~range~'#1-#2'~in~character~class. }
  {
    The~end-point~'#2'~of~the~range~'#1-#2'~may~not~serve~as~an~
    end-point~for~a~range:~alphanumeric~characters~should~not~be~
    escaped,~and~non-alphanumeric~characters~should~be~escaped.
  }
\msg_kernel_new:nnnn { regex } { range-backwards }
  { Range~[#1-#2]~out~of~order~in~character~class. }
  {
    In~ranges~of~characters~[x-y]~appearing~in~character~classes,~
    the~first~character~code~must~not~be~larger~than~the~second.~
    Here,~#1~has~character~code~\int_eval:n {`#1},~while~#2~has~
    character~code~\int_eval:n {`#2}.
  }
\msg_kernel_new:nnnn { regex } { c-bad-mode }
  { Invalid~nested~\iow_char:N\\c~escape~in~regular~expression. }
  {
    The~\iow_char:N\\c~escape~cannot~be~used~within~
    a~control~sequence~test~'\iow_char:N\\c{...}'.~
    To~combine~several~category~tests,~use~'\iow_char:N\\c[...]'.
  }
\msg_kernel_new:nnnn { regex } { c-missing-rbrace }
  { Missing~right~brace~inserted~for~\iow_char:N\\c~escape. }
  {
    LaTeX~was~given~a~regular~expression~where~a~
    '\iow_char:N\\c\iow_char:N\{...'~construction~was~not~ended~
    with~a~closing~brace~'\iow_char:N\}'.
  }
\msg_kernel_new:nnnn { regex } { c-missing-rbrack }
  { Missing~right~bracket~inserted~for~\iow_char:N\\c~escape. }
  {
    A~construction~'\iow_char:N\\c[...'~appears~in~a~
    regular~expression,~but~the~closing~']'~is~not~present.
  }
\msg_kernel_new:nnnn { regex } { c-missing-category }
  { Invalid~character~'#1'~following~\iow_char:N\\c~escape. }
  {
    In~regular~expressions,~the~\iow_char:N\\c~escape~sequence~
    may~only~be~followed~by~a~left~brace,~a~left~bracket,~or~a~
    capital~letter~representing~a~character~category,~namely~
    one~of~ABCDELMOPSTU.
  }
\msg_kernel_new:nnnn { regex } { u-missing-lbrace }
  { Missing~left~brace~following~\iow_char:N\\u~escape. }
  {
    The~\iow_char:N\\u~escape~sequence~must~be~followed~by~
    a~brace~group~with~the~name~of~the~variable~to~use.
  }
\msg_kernel_new:nnnn { regex } { u-missing-rbrace }
  { Missing~right~brace~inserted~for~\iow_char:N\\u~escape. }
  {
    LaTeX~
    \tl_if_empty:xTF {#2}
      { reached~the~end~of~the~string~ }
      { encountered~an~escaped~alphanumeric~character '\iow_char:N\\#2'~ }
    when~parsing~the~argument~of~an~'\iow_char:N\\u\iow_char:N\{...\}'~escape.
  }
\msg_kernel_new:nnnn { regex } { posix-unsupported }
  { POSIX~collating~element~'[#1 ~ #1]'~not~supported. }
  {
    The~[.foo.]~and~[=bar=]~syntaxes~have~a~special~meaning~in~POSIX~
    regular~expressions.~This~is~not~supported~by~LaTeX.~Maybe~you~
    forgot~to~escape~a~left~bracket~in~a~character~class?
  }
\msg_kernel_new:nnnn { regex } { posix-unknown }
  { POSIX~class~[:#1:]~unknown. }
  {
    [:#1:]~is~not~among~the~known~POSIX~classes~
    [:alnum:],~[:alpha:],~[:ascii:],~[:blank:],~
    [:cntrl:],~[:digit:],~[:graph:],~[:lower:],~
    [:print:],~[:punct:],~[:space:],~[:upper:],~
    [:word:],~and~[:xdigit:].
  }
\msg_kernel_new:nnnn { regex } { posix-missing-close }
  { Missing~closing~':]'~for~POSIX~class. }
  { The~POSIX~syntax~'#1'~must~be~followed~by~':]',~not~'#2'. }
\msg_kernel_new:nnnn { regex } { result-unbalanced }
  { Missing~brace~inserted~when~#1. }
  {
    LaTeX~was~asked~to~do~some~regular~expression~operation,~
    and~the~resulting~token~list~would~not~have~the~same~number~
    of~begin-group~and~end-group~tokens.~Braces~were~inserted:~
    #2~left,~#3~right.
  }
\msg_kernel_new:nnnn { regex } { unknown-option }
  { Unknown~option~`#1'~for~regular~expressions. }
  {
    The~only~available~option~is~'case-insensitive',~toggled~by~
    '(?i)'~and~'(?-i)'.
  }
\msg_kernel_new:nnnn { regex } { replacement-c }
  { Misused~\iow_char:N\\c~command~in~a~replacement~text. }
  {
    In~a~replacement~text,~the~\iow_char:N\\c~escape~sequence~
    can~be~followed~by~one~of~the~letters~ABCDELMOPSTU~
    or~a~brace~group,~not~by~'#1'.
  }
\msg_kernel_new:nnnn { regex } { replacement-u }
  { Misused~\iow_char:N\\u~command~in~a~replacement~text. }
  {
    In~a~replacement~text,~the~\iow_char:N\\u~escape~sequence~
    must~be~~followed~by~a~brace~group~holding~the~name~of~the~
    variable~to~use.
  }
\msg_kernel_new:nnnn { regex } { replacement-g }
  { Missing~brace~for~the~\iow_char:N\\g~construction~in~a~replacement~text. }
  {
    In~the~replacement~text~for~a~regular~expression~search,~
    submatches~are~represented~either~as~\iow_char:N \\g{dd..d},~
    or~\\d,~where~`d'~are~single~digits.~Here,~a~brace~is~missing.
  }
\msg_kernel_new:nnnn { regex } { replacement-catcode-end }
  {
    Missing~character~for~the~\iow_char:N\\c<category><character>~
    construction~in~a~replacement~text.
  }
  {
    In~a~replacement~text,~the~\iow_char:N\\c~escape~sequence~
    can~be~followed~by~one~of~the~letters~ABCDELMOPSTU~representing~
    the~character~category.~Then,~a~character~must~follow.~LaTeX~
    reached~the~end~of~the~replacement~when~looking~for~that.
  }
\msg_kernel_new:nnnn { regex } { replacement-null-space }
  { TeX~cannot~build~a~space~token~with~character~code~0. }
  {
    You~asked~for~a~character~token~with~category~'space',~
    and~character~code~0,~for~instance~through~
    '\iow_char:N\\cS\iow_char:N\\x00'.~
    This~specific~case~is~impossible~and~will~be~replaced~
    by~a~normal~space.
  }
\msg_kernel_new:nnnn { regex } { replacement-missing-rbrace }
  { Missing~right~brace~inserted~in~replacement~text. }
  {
    There~were~\int_use:N \l_regex_replacement_csnames_int \
    missing~right~braces.
  }
\cs_new:Npn \regex_msg_repeated:nnN #1#2#3
  {
    \str_if_eq:xxF { #1 #2 } { 1 0 }
      {
        , ~ repeated ~
        \prg_case_int:nnn {#2}
          {
            { -1 } { #1~or~more~times,~\bool_if:NTF #3 { lazy } { greedy } }
            {  0 } { #1~times }
          }
          {
            between~#1~and~\int_eval:n {#1+#2}~times,~
            \bool_if:NTF #3 { lazy } { greedy }
          }
      }
  }
%% 
%%
%% End of file `l3regex.sty'.
