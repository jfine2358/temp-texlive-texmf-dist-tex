%% 
%% \iffalse ^^A we skip the debug setting
\IfFileExists{\string~/bin/gen_and_xela}{\errorcontextlines=1000 }{}
%% \fi
%% ^^A $Id: TheUltimateMaster.gmd,v 0.352 2011/10/12 15:19:42 natror Exp natror $
%% This is file “gmbase.sty” generated with the DocStrip utility.
%% 
%%
%% The original source files were:
%%
%% gmutils/gmutils.gmd  (with options: `base')
%%
%% 
%% Copyright ©  
%% by Grzegorz ‘Natror’ Murzynowski
%% natror (at) gmail (dot) com
%% 
%% This program is subject to the LaTeX Project Public License.
%% See http://www.ctan.org/tex-archive/help/Catalogue/licenses.lppl.html
%% for the details of that license.
%%
%% LPPL status: "author-maintained".
%%
%% 
%% 
%% For documentation please refer to the file(s)
%% gmutils.{gmd,pdf}.
%% 
%% 
\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{gmbase}
    [2011/10/12 v0.996 some low-level macros (GM)]


%%
%%
%%     ^^A\typeout{\unexpanded{#4}}%%

\RequirePackage {expl3, xparse} % because it's used anyway: by

\ifx\XeTeXversion\relax
  \let\XeTeXversion\@undefined% If someone earlier used
\fi

\ifdefined\XeTeXversion
\XeTeXinputencoding utf-8 % we use Unicode dashes later in this file.
\fi% and if we are not in \XeTeX, we skip them thanks to \XeTeX-test.

\unless\ifdefined\strcmp
  \let\strcmp\pdfstrcmp
\fi

\let\@xa\expandafter
\let\@nx\noexpand

\def\@xanx{\@xa\@nx}

\long\def\@xadef#1{\@xa\def\@xa#1\@xa}

\long\def\@csn#1{\csname #1\endcsname}

\long\def\Name#1#2{\@xa#1\csname #2\endcsname}

\long\def\@xau#1{\unexpanded\@xa{#1}}

\def\gmu@firstandspace#1{#1 }

\long\def\strip@bslash#1{%
  \gmu@ifempty{#1}{}{%
    \gmu@if {cat}{\@nx~\@nx#1}% this is specially for an active
    % backslash (have you ever met it?). Thanks to this special case
    % the inner macro declared for an active |\| by |\DeclareCommand|
    % is |\\\| not |\\csname\endcsname\|.
    {\string#1}% if |#1| is active
    {%
      \@xa\@xa\@xa\ifnum\@xa\@xa\@xa\escapechar
        \@xa\@xa\@xa=\@xa\@xa\@xa`\@xa\gmu@firstandspace
        \string#1\@xa\@gobble
      \else\@xa\@firstofone \fi
      {\string#1}%
    }% if |#1| is not active
  }% of if |#1| not empty
}

\long\def\bslash@or@ac#1{%
  \ifcat\@nx~\@nx#1%
  \else
    \bslash
  \fi
  \strip@bslash{#1}%
}

\long\def\@xanxcs #1{%
  \ifcat\@nx~\@nx#1%
    \@nx#1%
  \else
    \@xa\@nx\csname #1\endcsname
  \fi
}

\long\def\@xanxcssimple #1{%
    \@xa\@nx\csname #1\endcsname
}

\long\def\@xaucs#1{%
  \unexpanded\@xa\@xa\@xa{\csname #1\endcsname}%
}

\long\def\@xanxtri#1{%
  \ifcat\@nx~\@nx#1%
    \@nx#1%
  \else
    \@xa\@nx\csname \strip@bslash{#1}\endcsname
  \fi
}

\def\pdef{\protected\def}

\def\lpdef{\long\protected\def}
\let\pldef\lpdef

\long\def\gmu@ifdefinable
#1% a \CS
{%
  \ifx #1\@undefined
    \@xa \@firstoftwo
  \else
    \@xa\@secondoftwo
  \fi
  {\@firstoftwo}%
  {\ifx #1\relax
      \@xa\@firstoftwo
    \else
      \@xa \@secondoftwo
    \fi
  }%
}

\def\pedef{\protected\edef}

\def\pxdef{\protected\xdef}

\long\def\gobble#1{}
\let\@gobble\gobble
\let\gobbletwo\@gobbletwo % it's a \LaTeX's |\long| macro (in File d:

\long\def\@gobbleeight#1#2#3#4#5#6#7#8{}

\long\pdef\provide#1{%\changes{v0.93}{2008/08/30}{added}
  \ifdefined#1% \UnDef
    \ifx\relax#1\afterfifi{\def#1}%
    \else\afterfifi{\gmu@gobdef}% \UnDef
    \fi
  \else\afterfi{\def#1}%
  \fi}

\long\def\gmu@gobdef#1#{% \UnDef
  \def\gmu@tempa{}% it's a~junk |\def|-assignment
  % to absorb possible prefixes.
  \@gobble
}

\def\pprovide{\protected\provide}

\long\def\@nameedef#1#2{% \changes{v0.93}{2008/08/30}{added}
  \@xa\edef\csname#1\endcsname{#2}}


\pdef\gmu@DefSymbol#1{%
  \unless\ifdefined#1%
    \def#1{#1}%
  \fi
}

\newcommand\newdef % sort of newcommand that accepts prefixes.
[1]%
{%
  \gmu@ifdefinable #1%
  {\pdef #1}
  {%
    \PackageError {gmbase} {\@nx#1 already defined.}{}%
    \gmu@gobdef
  }%
}

\protected\newdef \pnew {%
  \protected\newdef
}


\long\def\gmu@if #1#2{%
  \csname if#1\endcsname #2%
    \@xa\@firstoftwo
  \else\@xa\@secondoftwo
  \fi
}

\long\def\gmu@notif#1#2{%
  \gmu@if {#1}{#2}%
  \@secondoftwo\@firstoftwo
}

\def\gmu@ifsw #1{\gmu@if {#1}{}}
\def\gmu@notsw #1{\gmu@notif {#1}{}}

\def \gmu@ifincsname
{%
  \ifincsname
    \@xa\@firstoftwo
  \else
    \@xa\@secondoftwo
  \fi
}

\long\def\gmu@unless #1#2{%
  \@xa\unless \csname if#1\endcsname  #2%
    \@xa\@firstoftwo
  \else
    \@xa\@secondoftwo
  \fi
}


\lpdef\@iwru@EC#1#2#3{%
  \@iwrum{#1»{#2}« »#3«}%
  \gmu@passbraced{#1{#2}}{#3}%
}

\long\def\gmu@generalCASE
#1% Testing macro (|\gmu@if| etc.
#2% |#1| of the testing macro
#3% |#2| of the testing macro
#4% |#3| of the testing macro (what if test satisfied)\\
{%
  #1{#2}{#3}%
  {%
    \gmu@EatCases{#4}}{}%
}

\long\def\gmu@EatCases
#1%
#2\gmu@ESAC
{#1}

\let\gmu@lastCASE\gmu@EatCases

\def\gmu@CASE {\gmu@generalCASE \gmu@if }
\def\gmu@CASEnot {\gmu@generalCASE \gmu@notif }
\def\gmu@CASExany {\gmu@generalCASE \gmu@ifxany }
\def\gmu@CASExnone {\gmu@generalCASE \gmu@ifxnone }

\long\def\gmu@reserved@firstofmany#1#2\gmu&nil{#1}

\long\def\ifsingletoken#1{% ^^V \gmu &nil % such a strange delimiter to
                                % make it work both in letter and
                                % other |@| scopes etc.\ (|&| seems to
                                % me recatcoded rather seldom)
  \ifnum \strcmp{\unexpanded{#1}}%
    {\@xau{\gmu@reserved@firstofmany #1\blekotnizza@ \di \broccoli
        \gmu&nil}%
    }% of right text of |\strcmp|
    =\z@
}

\long\def\gmu@predetokstring #1{%
  \gmu@if {num}
  {%
    % After a couple of hours of debug I reached the proper test which
    % is given below. The goal is to (expandably!) check whether |#1|
    % is braced and/or begins with a blank space. In any of those
    % cases we don't hit it('s first token) with |\string|.
    %
    % |\@firstofone| strips outermost pair of braces if any and
    % gobbles the lading blank(s) if any so the detokenised strings
    % will differ.
    \strcmp
    {\detokenize{#1x}}%
    {\detokenize\@xa{\@firstofone #1x}}=\z@
  }% of test
  {\@xa{\string#1}}
  {{#1}}%
}


\long\def\ifstrings#1#2{%
  \ifnum\strcmp
  {\detokenize\gmu@predetokstring{#1x}}%
  {\detokenize\gmu@predetokstring{#2x}}=\z@
}


\long\def\ifstribs#1#2{%
  \ifnum\strcmp{\strip@bslash{#1}}{\strip@bslash{#2}}=\z@
}


\long\def\ifStrX#1#2{%
  \gmu@CASEnot {x}{#1#2}%
  {\iffalse}% if tokens are x-unequal, all is clear.
  %
  \gmu@CASEnot x {\@undefined#1}
  {\iftrue}%
  %
  % some (i.e.\ \emph{both}) tokens are-x |\@undefined| or |\relax|,
  % then
  \gmu@CASE {strings}{#1#2}%
    {\iftrue}%
  %
  \gmu@lastCASE
  {\iffalse}%
  \gmu@ESAC
}

\long\def\firstofone#1{#1}

\long\def\bracefirstofone#1{{#1}}

\long\pdef\scantwo#1#2{
  \begingroup\endlinechar\m@ne
  \@xa\endgroup\scantokens{#1#2}%
}

\long\def\@firstofthree#1#2#3{#1}
\long\def\@secondofthree#1#2#3{#2}
\long\def\@thirdofthree#1#2#3{#3}
\long\def\@twoofthree#1#2#3{#1#2}
\long\def\@secondoffive#1#2#3#4#5{#2}

\long\def\@firstofmany#1#2\@nil{#1}

\long\def\@secondofmany#1#2#3\@nil{#2}

\long\def\@allbutfirstof#1#2\@nil{#2}


\long\def\@firstthensecond #1#2{#1#2} % Note this macro strips braces
                                % if present.
\long\def\@secondthenfirst #1#2{#2#1} % Note as above.



\def\longafterfi{%
  \long\def\afterfi##1##2\fi{\fi##1}}
\longafterfi
\long\def\afterfifi#1#2\fi#3\fi{\fi\fi#1}
\long\def\afteriffifi#1#2\fi#3\fi{\fi#1}

\long\def\afterififfififi#1#2\fi#3\fi#4\fi{\fi#1}
\long\def\afteriffififi#1#2\fi#3\fi#4\fi{\fi\fi#1}
\long\def\afterfififi#1#2\fi#3\fi#4\fi{\fi\fi\fi#1}


\long\def\foone#1{\begingroup#1\relax\egfirstofone}
\long\def\egfirstofone#1{\endgroup#1}

\def\fooatletter{\foone\makeatletter}

\newcommand*\@emptify[1]{\let#1=\@empty}
\gmu@ifdefinable\emptify{\let\emptify\@emptify}

\newcommand*\g@emptify{\global\@emptify}
\gmu@ifdefinable\gemptify{\let\gemptify\g@emptify}

\newcommand\@relaxen[1]{\let#1=\relax}
\gmu@ifdefinable\relaxen{\let\relaxen\@relaxen}

\newcommand*\g@relaxen{\global\@relaxen}
\gmu@ifdefinable\grelaxen{\let\grelaxen\g@relaxen}

\long\def\gmu@ifempty#1{%\
  \ifnum\strcmp{\detokenize{#1}}{}=\z@
    \@xa\@firstoftwo
  \else\@xa\@secondoftwo
  \fi
}

\long\pdef\@ifnonempty#1#2#3{\gmu@ifempty{#1}{#3}{#2}}



\long\def\gmu@ifexempty #1{%
  \ifnum \strcmp{#1}{}=\z@
    \@xa\@firstoftwo
  \else\@xa\@secondoftwo
  \fi
}

\long\pdef\IfAmong
#1% the token(s) whose presence we check,
\among % delimiter of |#1|
#2%  the list of tokens in which we search |#1|,
{%\label{IfAmong}
  % \chgs{2008/12/05 v0.98 split from \cs{IfAmong}}
  %
  \long\def\gmu@among@##1#1##2\gmu@among@{%
    \gmu@ifempty{##2}\@secondoftwo\@firstoftwo}%
  \gmu@among@#2#1\gmu@among@
}

\newif\ifgmu@ifquant

\long\pdef\gmu@ifxany
#1% a single token to be |\ifx| ed with each of |#2|
#2% counterpart to the above—a sequence of tokens to check |#1|
{%
  \gmu@ifempty{#2}{\@secondoftwo}{%
    % we wrap the iteration over |#2|'s tokens in |\gmu@ifempty| because
    % we expect many empty |#2|'s in |\DeclareCommand|'s |\loop|
    % arguments (such as |Q| and |U|)
    \gmu@ifquantfalse
    \let\gmu@ifxa@aasiter\@@gmu@ifxa@aasiter
    %
    \edef\gmu@ifxa@aas{% edef and unexpanded to protect agains
      % |#|\cat6 token(s) in |#1|.
      \unexpanded{%
        \ifx #1\gmu@ifxa@token
          \gmu@ifquanttrue
          \let\gmu@ifxa@aas\gmu@ifxa@drainer
        \else
          \ifx \gmu@ifxa@Limit\gmu@ifxa@token
            \emptify \gmu@ifxa@aasiter
          \fi
        \fi
        \gmu@ifxa@aasiter
      }%of |\unexpanded|
    }% of |\gmu@ifxa@aas|
    %
    \gmu@ifxa@aasiter #2\gmu@ifa@PreLimit\gmu@ifxa@Limit
    \gmu@if {gmu@ifquant}{}%
  }% of if |#2| nonempty
}

\def\gmu@ifxa@drainer{%
  \ifx\gmu@ifxa@Limit\gmu@ifxa@token
    \emptify\gmu@ifxa@aasiter
  \fi
  \gmu@ifxa@aasiter
}

\gmu@DefSymbol \gmu@ifa@PreLimit
\gmu@DefSymbol \gmu@ifxa@Limit

\def\@@gmu@ifxa@aasiter{%
  \afterassignment\gmu@ifxa@aas
  \let\gmu@ifxa@token= }% thanks to this space it'll look also at

\long\pdef\gmu@ifxnone
#1% token to be checked against
#2% list of tokens to \emph{not} find |#1| at
{%
  \gmu@ifxany{#1}{#2}\@secondoftwo\@firstoftwo
}


\long\def\gmu@foreach#1\gmu@foreach@delim#2{%
  %
  \long\def\gmu@forer##1{%
    \gmu@if {strings} {\gmu@foreach@delim {##1}}%
    {}% if we've met the delimiter, we stop.
    {% otherwise we wrap |#1| in a macro to make it available to |#2|
      \edefU\gmu@forarg{##1}%
      #2% we execute |#2| and probably continue iteration (unless the
        % loop isn't broken with the next macro).
      \gmu@forer
    }%
  }% of forer.
  \gmu@forer#1\gmu@foreach@delim
}

\long\def\gmu@foreach@break
#1\gmu@foreach@delim{}

\long\def\gmu@ifsXXany
#1% kind of test (|strings| or |stribs| so far)
#2% token to be checked against |#3|
#3% the list of tokens to be iterated over\\
{%
  \gmu@ifsXXany@{#1}{#2}#3\gmu@ifsXXany@end
  \@firstoftwo\@secondoftwo
}

\long\def\gmu@ifsXXany@
#1% kind of test
#2% left side of comparison
#3% right side of comparison
{%
  \gmu@if {#1}{#2#3}%
  \gmu@ifsXXany@found
  {% else
    \gmu@if {#1}{#3\gmu@ifsXXany@end}%
    \@secondoftwo
    {\gmu@ifsXXany@{#1}{#2}}% if we didn't meet the sentinel, we iterate
  }%
}

\long\def\gmu@ifsXXany@found
#1\gmu@ifsXXany@end
{\@firstoftwo}

\def\gmu@ifstrany{\gmu@ifsXXany {strings}}

\def\gmu@ifsbany{\gmu@ifsXXany {stribs}}

\def\gmu@ifStrXany{\gmu@ifsXXany {StrX}}

\long\def\gmu@ifstrnone#1#2#3#4{%
  \gmu@ifstrany{#1}{#2}{#4}{#3}%
}

\long\def\gmu@ifsbnone#1#2#3#4{%
  \gmu@ifsbany{#1}{#2}{#4}{#3}%
}

\long\def\gmu@ifStrXnone#1#2#3#4{%
  \gmu@ifStrXany{#1}{#2}{#4}{#3}%
}

\lpdef\gmu@CASEstrany {\gmu@generalCASE \gmu@ifstrany }

\lpdef\gmu@CASEstrnone {\gmu@generalCASE \gmu@ifstrnone }

\lpdef\gmu@CASEsbany {\gmu@generalCASE \gmu@ifsbany }

\lpdef\gmu@CASEsbnone {\gmu@generalCASE \gmu@ifsbnone }


\newtoks\degroup@toks

\long\pdef\gmu@degroup
#1% text to be degrouped
{\degroup@toks={}%
  \gmu@degroup@iter#1\gmu@degroup@end
}

\long\def\gmu@degroup@afterlet{%
  \gmu@if x{\degroup@lettoken\bgroup}%
  {\degroup@drainanditer}%
  {\gmu@if x{\degroup@lettoken\egroup}%
    {\degroup@drainanditer}%
    {\degroup@addanditer}%
  }%
}

\def\gmu@degroup@iter{%
  \futurelet\degroup@lettoken\gmu@degroup@afterlet}

\def\degroup@drainanditer{%
  \afterassignment\gmu@degroup@iter
  \let\gmu@drain=
}

\def\degroup@addanditer{%
  \gmu@if x{\degroup@lettoken\gmu@letspace}%
  {\addtotoks\degroup@toks{ }%
    \degroup@drainanditer
  }{%
    \degroup@addanditer@i
  }%
}

\long\def\degroup@addanditer@i
#1{%
  \gmu@if {strings}{#1\gmu@degroup@end}%
  {}% we've reached the end of iteration
  {% it's sth.\ to add
    \addtotoks\degroup@toks{#1}%
    \gmu@degroup@iter
  }%
}

\pdef\IfIntersect
{\gmu@ifintersect \gmu@ifxany}

\lpdef\gmu@ifintersect
#1% an iterating test (|\gmu@ifxany|, |\gmu@ifstrany| or
#2% one list to match
#3% another list to match
{%
  \let\IfIntersect@next\@secondoftwo
  \gmu@foreach #2\gmu@foreach@delim{%
    \@xa #1\gmu@forarg{#3}%
    {\let\IfIntersect@next\@firstoftwo
      \gmu@foreach@break
    }{}%
  }% of |\gmu@foreach|'s |#2|.
  \IfIntersect@next
}

\pdef\gmu@ifstrintersect
{\gmu@ifintersect\gmu@ifstrany}

\pdef\gmu@ifsbintersect
{\gmu@ifintersect\gmu@ifsbany}


\newtoks\@XAtoks

\long\pdef\@XA#1{%
  \@XAtoks={#1}%
  \@xa\the\@xa\@XAtoks}

\long\pdef\@ifinmeaning#1\of#2{% \
  % \begin{enumargs}
  % \item the token(s) whose presence we check,
  % \item the macro in whose meaning we search |#1| (the first token of
  %   this argument is expanded one level with |\expandafter|),
  % \item the `if found' stuff,
  % \item the `if not found' stuff.
  % \end{enumargs}
  %
  % \chgs{2007/11/06 v0.98 (in \pk{gmdoc}) made more elegant:
  % \cs{if} changed to \cs{ifx} made four parameters and not expanding
  % to an open \cs{if›(true⁄|false›)}. % ^^A |
  % Also renamed from \cs{@ifismember}}
  % \chgs{2008/12/05 v0.98 moved here from \pk{gmdoc} and rewritten,
  % including split to \cs{IfAmong} because the latter is needed in
  % \cs{DeclareCommand}}
  %
  \@XA{\IfAmong#1\among}\@xa{#2}}

\gmu@DefSymbol\defNoHash
\gmu@DefSymbol\defHashy
\gmu@DefSymbol\boolean

\def\gmu@geteschar{%
  % A macro that edefines detokenised char of the charcode |\escapechar|
  \edef\gmu@xiieschar{%
    \gmu@CASE {num} {\escapechar <\z@}
    {}%
    %
    \gmu@CASE {num}{\escapechar <32 }
    {\@xa \@firstofmany \string \blekotnizza\@nil}% not firstthreeofmany!!!!
    %
    \gmu@CASE {num} {\escapechar=32 }
    { }% space cannot be “first of…”.
    \gmu@lastCASE
    {\@xa \@firstofmany \string \blekotnizza \@nil}%
    \gmu@ESAC
  }%
}

\long\def\gmu@IfBooleanMacro#1{%
  \gmu@ifedetokens{\meaning#1}{macro:->true}%
  {\@firstoftwo}%
  {\gmu@ifedetokens{\meaning#1}{macro:->false}%
    {\@firstoftwo}%
    {\@secondoftwo}%
  }%
}

\pdef\IfIs
#1% a \CS
#2% |\dimen|, |\long|, |\toks|, |\skip|, |\count|, |\dimexpr|,
  % |\numexpr|, |\glueexpr|, |\newif| for |\iffalse| and |\iftrue|,
  % |\if| or |\conditional| for any Boolean test/switch, |\def| for a
  % macro.
  %
  % This test tells us in particular what kind of assignment may be
  % applied to |#1|. Therefore it turns true for |#1| being e.g.\ primitive
  % \TeX's  skip registers and |#2|==|\skip|.
{%
  \@tempswafalse
  %
  \gmu@CASE x{\defNoHash#2}%
  {% case “def no hash” (hashless macro)
    \@tempswatrue
    \edef\gmu@IfIs@resa{%
      \pdef\@nx\gmu@IfIs@resa
      ####1\detokenize{macro:->}%
      ####2\@nx\@nil{\@ifnonempty{####2}}%
      % And we prepare applying thus defined macro to |#1|:
      \unexpanded{\@xa\gmu@IfIs@resa\meaning#1}%
      \detokenize{macro:->}\@nx\@nil
    }% of |\edef|
  }% of case hasless macro (“def no hash”)
  %
  % if not hashless
  \gmu@CASE x {\defHashy#2}%
  {%
    % case hashy macro
    \@tempswatrue
    \edef\gmu@IfIs@resa{%
      \pdef\@nx\gmu@IfIs@resa
      ####1\detokenize{macro:}####2\xiihash1####3->%
      ####4\@nx\@nil{\@ifnonempty{####4}}%
      % And we prepare applying thus defined macro to |#1|:
      \unexpanded{\@xa\gmu@IfIs@resa\meaning#1}%
      \detokenize{macro:}\xiihash1->\@nx\@nil
    }% of |\edef|
  }% of case hashy macro
  %
  \gmu@CASE x {#2\boolean}
  {% case Boolean
    \@tempswatrue
    \def\gmu@IfIs@resa{\gmu@IfBooleanMacro#1}%
    %
  }% of case Boolean
  %
  \gmu@CASEstrany #2{\dimexpr \numexpr \glueexpr }%
  {%  case \eTeX\ expression
    \@tempswatrue
    \def\gmu@IfIs@resa{% if should be a macro expanding to
      % expression contents
      \IfIsExpression #1#2}%
  }% of case expression
  %
  % The subsequent part of this huge test refers to |\meaning|s. We
  % want to make it robust to possible (although rather seldom)
  % changes of |\escapechar|. Therefore define an aux macro that
  % expands to detokenised escape char.
  %
  % Assume that letters, icluding »e«, will not be used as the escape
  % char:
  \gmu@geteschar
  %
  % Now |\gmu@xiieschar| carries the detokenised escape char (is empty
  % if |\escapechar|${}<0$).
  %
  %
  \gmu@CASE x {\dimen#2}%
  {% Case dimen. Let's check if it's special (inner \TeX's)
    % or normal.
    \gmu@ifxany#1{\prevdepth \pagegoal \pagetotal \pagestretch
      \pagefilstretch \pagefillstretch \pagefilllstretch
      \pageshrink \pagedepth
      \hfuzz \vfuzz \overfullrule \emergencystretch \hsize \vsize
      \maxdepth \splitmaxdepth \boxmaxdepth \lineskiplimit
      \delimitershortfall \nulldelimiterspace \scriptspace
      \mathsurround \predisplaysize \displaywidth
      \displayindent \parindent \hangindent \hoffset \voffset
    }%
    {\@tempswatrue\let\gmu@IfIs@resa\@firstoftwo}%
    {% subcase normal dimen
      \def\gmu@IfIs@resa{%
        \gmu@ifexempty {\gmu@xiieschar}%
        {%
          \pdef\gmu@IfIs@resa####1####2####3####4####5####6\@nil{%
            \gmu@if {}
            {1%
              \if d####1\else0\fi
              \if i####2\else0\fi
              \if m####3\else0\fi
              \if e####4\else0\fi
              \if n####5\else0\fi
              1}%
          }% of inner |\gmu@IfIs@resa|…
        }% …if eschar negative
        {%
          \pdef\gmu@IfIs@resa####1####2####3####4####5####6####7\@nil{%
            \gmu@if {} {1%
              \if \gmu@xiieschar ####1\else0\fi
              \if d####2\else0\fi
              \if i####3\else0\fi
              \if m####4\else0\fi
              \if e####5\else0\fi
              \if n####6\else0\fi
              1%
            }%
          }% of inner |\gmu@IfIs@resa|…
        }% …when eschar nonnegative
      }% of outer |\gmu@IfIs@resa|
    }% of if special dimen or not
  }% of case dimen
  %
  \gmu@CASE x {\count#2}%
  {% case count
    \gmu@ifxany#1{\spacefactor \prevgraf \deadcycles
      \insertpenalties
      \pretolerance \tolerance \hbadness \vbadness \linepenalty
      \hyphenpenalty \exhyphenpenalty \binoppenalty \relpenalty
      \clubpenalty \widowpenalty \displaywidowpenalty
      \brokenpenalty \predisplaypenalty \postdisplaypenalty
      \interlinepenalty \floatingpenalty \outputpenalty
      \doublehyphendemerits \finalhyphendemerits \adjdemerits
      \looseness \pausing \holdinginserts \tracingonline
      \tracingmacros \tracingstats \tracingparagraphs
      \tracingpages \tracingoutput \tracinglostchars
      \tracingcommands \tracingrestores \language \uchyph
      \lefthyphenmin \righthyphenmin \globaldefs
      \defaulthyphenchar \defaultskewchar \escapechar \endlinechar
      \newlinechar \maxdeadcycles \hangafter \fam \mag
      \delimiterfactor \time \day \month \year \showboxbreadth
      \showboxdepth \errorcontextlines
      \lastlinefit
    }%
    {% if special count register then:
      \@tempswatrue\let\gmu@IfIs@resa\@firstoftwo}%
    {%
      % if normal count register then
      \def\gmu@IfIs@resa{%
        \gmu@ifexempty \gmu@xiieschar
        {\pdef\gmu@IfIs@resa####1####2####3####4####5####6\@nil{%
            \gmu@if {} {1%
              \if c####1\else0\fi
              \if o####2\else0\fi
              \if u####3\else0\fi
              \if n####4\else0\fi
              \if t####5\else0\fi
              1%
            }% of test
          }% of inner |\gmu@IfIs@resa|…
        }% … when eschar is negative
        %
        {% eschar not empty (nonnegative)
          \pdef\gmu@IfIs@resa####1####2####3####4####5####6####7\@nil{%
            \gmu@if {} {1%
              \if \gmu@xiieschar####1\else0\fi
              \if c####2\else0\fi
              \if o####3\else0\fi
              \if u####4\else0\fi
              \if n####5\else0\fi
              \if t####6\else0\fi
              1%
            }% of test
          }% of inner |\gmu@IfIs@resa|…
        }% … when eschar nonnegative
      }% of outer |\gmu@IfIs@resa|
    }% of if normal count register
  }% of case count
  %
  \gmu@CASE x {\skip#2}%
  {% case skip
    \gmu@ifxany#1{%
      \baselineskip \lineskip \parskip \abovedisplayskip
      \abovedisplayshortskip \belowdisplayskip
      \belowdisplayshortskip \leftskip \rightskip \topskip
      \splittopskip \tabskip \spaceskip \xspaceskip \parfillskip
    }%
    {% if special skip
      \@tempswatrue\let\gmu@IfIs@resa\@firstoftwo}%
    {% not special skip
      \def\gmu@IfIs@resa{%
        \gmu@ifexempty \gmu@xiieschar
        {\pdef\gmu@IfIs@resa####1####2####3####4####5\@nil{%
            \gmu@if {} {1%
              \if s####1\else0\fi
              \if k####2\else0\fi
              \if i####3\else0\fi
              \if p####4\else0\fi
              1%
            }%
          }% of inner |\gmu@IfIs@resa|…
        }% …when eschar nonnegative
        %
        {\pdef\gmu@IfIs@resa####1####2####3####4####5####6\@nil{%
            \gmu@if {} {1%
              \if \gmu@xiieschar ####1\else0\fi
              \if s####2\else0\fi
              \if k####3\else0\fi
              \if i####4\else0\fi
              \if p####5\else0\fi
              1%
            }%
          }% of inner |\gmu@IfIs@resa|…
        }% …when eschar nonnegative
      }% of outer |\gmu@IfIs@resa|
    }% of if skip but not special
  }% of case skip
  %
  \gmu@CASE x {\toks#2}
  {% case toks
    \gmu@ifxany#1{%
      \output \everypar \everymath \everydisplay \everyhbox
      \everyvbox \everyjob \everycr \errhelp \everyeof}%
    {% subcase special toks
      \@tempswatrue\let\gmu@IfIs@resa\@firstoftwo}%
    {% subcase normal toks
      \def\gmu@IfIs@resa{%
        \gmu@ifexempty \gmu@xiieschar
        {\pdef\gmu@IfIs@resa####1####2####3####4####5\@nil{%
            \gmu@if {} {1%
              \if t####1\else0\fi
              \if o####2\else0\fi
              \if k####3\else0\fi
              \if s####4\else0\fi
              1%
              }%
            }% of inner |\gmu@IfIs@resa|…
          }% …when eschar negative
        {\pdef\gmu@IfIs@resa####1####2####3####4####5####6\@nil{%
            \gmu@if {} {1%
              \if \gmu@xiieschar ####1\else0\fi
              \if t####2\else0\fi
              \if o####3\else0\fi
              \if k####4\else0\fi
              \if s####5\else0\fi
              1%
              }%
            }% of inner |\gmu@IfIs@resa|…
          }% …when eschar nonnegative
      }% of outer |\gmu@IfIs@resa|
    }% of if toks but not special
  }% of case toks
  %
  \gmu@CASE x {\long#2}%
  % if a macro is |\long|, then these detokens open its meaning
  % despite of possible |\outer|.
  {% case long macro
    \def\gmu@IfIs@resa{%
      \gmu@ifexempty \gmu@xiieschar
      {\pdef\gmu@IfIs@resa####1####2####3####4####5\@nil{%
          \gmu@if {} {1%
            \if l####1\else0\fi
            \if o####2\else0\fi
            \if n####3\else0\fi
            \if g####4\else0\fi
            1%
          }%
        }% of inner |\gmu@IfIs@resa|…
      }% …when eschar negative
      {\pdef\gmu@IfIs@resa####1####2####3####4####5####6\@nil{%
          \gmu@if {} {1%
            \ifnum \gmu@xiieschar ####1\else0\fi
            \if l####2\else0\fi
            \if o####3\else0\fi
            \if n####4\else0\fi
            \if g####5\else0\fi
            1%
          }%
        }% of inner |\gmu@IfIs@resa|…
      }% …when eschar nonnegative
    }% of outer |\gmu@IfIs@resa|
  }% of case |\long|
  % Note that we also can put here a test whether the meaning
  % begins with |macro| which would mean that a macro is
  % short.
  \gmu@CASE x {\newif#2}%
  {% case |\newif| (Boolean switch)
    \def\gmu@IfIs@resa{%
      \gmu@ifexempty \gmu@xiieschar
      {\pdef\gmu@IfIs@resa####1####2####3%
        ####4####5####6####7####8\@nil{%
          \gmu@unless {} {0% lazy disjunction
            \gmu@if {} {1% lazy conjunction
              \if i####1\else0\fi
              \if f####2\else0\fi
              \if f####3\else0\fi
              \if a####4\else0\fi
              \if l####5\else0\fi
              \if s####6\else0\fi
              \if e####7\else0\fi
              1%
            }%
            {}{0}%
            \gmu@if {} {1% lazy conjunction
              \if i####1\else0\fi
              \if f####2\else0\fi
              \if t####3\else0\fi
              \if r####4\else0\fi
              \if u####5\else0\fi
              \if e####6\else0\fi
              \if \relax####7\else0\fi
              1%
            }%
            {}{0}%
            0%
          }%
        }% of inner |\gmu@IfIs@resa|…
      }% …when eschar nonnegative
      %
      {\pdef\gmu@IfIs@resa####1####2####3%
        ####4####5####6####7####8####9\@nil{%
          \gmu@unless {} {0%
            \gmu@if {} {1%
              \if \gmu@xiieschar ####1\else0\fi
              \if i####2\else0\fi
              \if f####3\else0\fi
              \if f####4\else0\fi
              \if a####5\else0\fi
              \if l####6\else0\fi
              \if s####7\else0\fi
              \if e####8\else0\fi
              1%
            }%
            {}{0}%
            \gmu@if {} {1%
              \if \gmu@xiieschar ####1\else0\fi
              \if i####2\else0\fi
              \if f####3\else0\fi
              \if t####4\else0\fi
              \if r####5\else0\fi
              \if u####6\else0\fi
              \if e####7\else0\fi
              \if \relax####8\else0\fi
              1%
            }%
            {}{0}%
            0%
          }%
        }% of inner |\gmu@IfIs@resa|…
      }% …when eschar nonnegative
    }% of outer |\gmu@IfIs@resa|
  }% of case |\newif| (Boolean switch)
  %
  \gmu@CASE {x\@xa\@xa} {\csname if\endcsname#2}%
  {%  case |\if| test
    \def\gmu@IfIs@resa{%
      \gmu@ifexempty \gmu@xiieschar
      {\pdef\gmu@IfIs@resa####1####2####3\@nil{%
          \gmu@if {} {1%
            \if i####1\else0\fi
            \if f####2\else0\fi
            1%
          }%
        }% of inner |\gmu@IfIs@resa|…
      }% …when eschar negative
      %
      {\pdef\gmu@IfIs@resa####1####2####3####4\@nil{%
          \gmu@if {} {1%
            \if \gmu@xiieschar ####1\else0\fi
            \if i####2\else0\fi
            \if f####3\else0\fi
            1%
          }%
        }% of inner |\gmu@IfIs@resa|…
      }% …when eschar nonnegative
    }% of outer |\gmu@IfIs@resa|
  }% of case |\if|
  %
  \gmu@lastCASE %^^A >>>>> ??????
  {false}{}{}%
  \gmu@ESAC
  % For the cases 1–$n$ we just launch their auxiliary macro:
  \if@tempswa
    \@xa\gmu@IfIs@resa
  \else
  %
  % For the other cases their auxiliary macro defines “inner |@resa|”
  % (protected) which perform the test on the meaning of |#1|.
      \gmu@IfIs@resa
      %
      % now (new) |\gmu@IfIs@resa| it's defined as delimited
      % with |#2| and |\@nil| (if |#1| may be one of kinds checked letter
      % by letter).
      %
      \edef\gmu@IfIs@resb{%
      \gmu@IfIs@resa\meaning#1%
      \relax\relax\relax\relax\relax\relax\relax\relax %to provide
      % something for gobbling tests.
      \@xa\detokenize\@xa{\string#2}\@nx\@nil}%
    \@xa\gmu@IfIs@resb
  \fi
}% of |\IfIs|

\unless\ifdefined\@tempskipa\newskip\@tempskipa\fi
\unless\ifdefined\@tempmuskipa\newmuskip\@tempmuskipa\fi

\long\def\IfIsExpression
#1% the stuff to be examined
#2% |\dimexpr|, |\glueexpr|, |\numexpr| or |\muexpr|
{%
  \ifx#2\numexpr\let\next\@tempcnta\fi
  \ifx#2\glueexpr\let\next\@tempskipa\fi
  \ifx#2\dimexpr\let\next\@tempdima\fi
  \ifx#2\muexpr\let\next\@tempmuskipa\fi
  \afterassignment\gmu@testtopenalty
  \next=#2#1\penalty
}

\def\gmu@testtopenalty#1\penalty{%
  \gmu@ifempty{#1}}

\pdef\newgif#1{%
  {\escapechar\m@ne
    \global\let#1\iffalse
    \@gif#1\iftrue
    \@gif#1\iffalse
  }}
\def\@gif#1#2{%
  \protected\@xa\gdef\csname\@xa\@gobbletwo\string#1%
  g% the letter $g$ for `|\global|'.
  \@xa\@gobbletwo\string#2\endcsname
  {\global\let#1#2}}

\pdef\newif#1{% We not only make \incs{newif}
  % \incs{protected} but also make it to define \cs{protected}
  % assignments so that premature expansion doesn't affect
  % \inverb|\if…\fi| nesting.
 % \changes{v0.92}{2008/08/09}{added redefinition so that now
 % switches defined with it are \cs{protected} so they won't expand to
 % a~further expanding or unbalanced \cs{iftrue/false} in an \cs{edef}}
  \count@\escapechar \escapechar\m@ne
  \let#1\iffalse
  \@if#1\iftrue
  \@if#1\iffalse
  \escapechar\count@}

\def\@if#1#2{%
  \protected \@xa\def\csname\@xa\@gobbletwo\string#1%
  \@xa\@gobbletwo\string#2\endcsname
  {\let#1#2}}

\pdef\hidden@iffalse{\iffalse}
\pdef\hidden@iftrue{\iftrue}


\pdef\grefstepcounter#1{%
  {\let\protected@edef=\protected@xdef\refstepcounter{#1}}}

\pdef\hgrefstepcounter#1{%
  \ifhmode\leavevmode\fi\grefstepcounter{#1}}


\pdef\hunskip{\ifhmode\unskip\fi}


\def\glet{\global\let}


\lpdef\addtomacro
#1% macro (has to be parameterless)
#2% stuff to be added
{\edef #1{\@xau #1\unexpanded{#2}}}

\pdef\gaddtomacro{\global\addtomacro}

\long\def\prependtomacro#1#2{% \changes{v0.94}{2008/09/15}{order of
  % arguments reversed}
  \edef#1{\unexpanded{#2}\@xa\unexpanded\@xa{#1}}}

\lpdef\addtotoks#1#2{%
  #1=\@xa{\the#1#2}}

\newtoks\gmu@prependtoks@aux

\lpdef\gmu@prependtotoks@ambig
#1% scope
#2% toks register
#3% text of prependement
{%
  \iffalse {\fi % hack to balance braces in definition
    \@XA{%
      #1#2=\bgroup#3%
    }% during execution, this brace closes the |\@XA|'s argument…
    \the#2}% and this one closes the text opened by |\bgroup|, i.e.,
}

\lpdef\prependtotoks
#1% toks register
#2% text to be prepended
{\gmu@prependtotoks@ambig {}{#1}{#2}}%

\lpdef\gprependtotoks
#1% toks register
#2% text to be prepended
{\gmu@prependtotoks@ambig \global{#1}{#2}}%

\long\def\addto@forlist
#1% a comma-separated list
#2% the element(s) added
{\ifx#1\@empty
    \@xa\@gobble
  \else\@xa\@firstofone
  \fi
  {\addtomacro#1{,}}%
  \addtomacro#1{#2}%
}

\lpdef\eaddtomacro
#1% a macro
#2% stuff to be added (will be fully expanded)
{\edef#1{\@xau#1#2}}

\long\def\gmu@ifundefined #1{% not |\protected| because expandable.
  % \changes{v0.94}{2008/9/12}{added. All \cs{@ifundefined}s used by
  % me changed to this}
  % \changes{v0.94}{2008/10/03}{made robust to unbalanced \cs{if}s and
  % \cs{fi}s the same way as \LaTeX's \cs{@ifundefined} (after a~heavy
  % debug :-)}
  %
  \gmu@CASEnot {csname} {#1\endcsname}% defined…
  {\@firstoftwo}%
  %
  \gmu@CASE  {x\@xa\@xa} {\csname #1\endcsname\relax}% but only as |\relax|---then
  % 2nd argument.
  {\@firstoftwo}%
  \gmu@lastCASE
  {\@secondoftwo}%
  \gmu@ESAC
}

\long\def\gmu@ifdefined #1#2#3{%
  \gmu@ifundefined {#1}{#3}{#2}}


\long\def \gmu@ifCSdefined#1{%
  \gmu@CASEnot {defined} {#1}
  {\@secondoftwo}%
  %
  \gmu@CASE x {\relax #1}
  {\@secondoftwo}%
  %
  \gmu@EatCases
  {\@firstoftwo}%
  \gmu@ESAC
}

\long\def\CSNameIf
#1% the name to check and probably execute
{%
  \ifcsname #1\endcsname
    \@xa\@twoofthree
  \else\@xa\@thirdofthree
  \fi
  {\csname #1\endcsname}%
}

\foone{\catcode`\_=8 }
{\let\subs=_}

\foone{\catcode`\^=7 }
{\let\sups=^}

\foone{\@makeother\_}
{\def\xiiunder{_}}

\let\all@unders\xiiunder
\foone{\catcode`\_=8 }
{\addtomacro\all@unders{_}}
\foone{\catcode`\_=11 }
{\addtomacro\all@unders{_}}
\foone{\catcode`\_=13 }
{\addtomacro\all@unders{_}}

\foone{\@makeother\^^M}{\def\xiiM{
  }}% \chgs{2010/03/16 v0.992 added}

\def\all@stars{*}
\foone{\catcode`\*=11 }
{\addtomacro\all@stars{*}}
\foone{\catcode`\*=13 }
{\addtomacro\all@stars{*}}

\def\all@spaces{ }
\foone{\@makeother\ }{%
\addtomacro\all@spaces{ }%
}
\foone{\obeyspaces}{%
\addtomacro\all@spaces{ }%
}

\foone\obeylines{%
  \def\two@Ms{
  }}
\foone{\@makeother\^^M}{%
  \addtomacro\two@Ms{
  }}

\edef\spaces@and@Ms{\@xau{\all@spaces}\@xau{\two@Ms}}

\ifdefined\XeTeXversion
  \chardef\_="005F
\fi

\foone{\@makeother\`}%
{\def\backquote{`}}

\foone{\catcode`\[=1 \@makeother\{
  \catcode`\]=2 \@makeother\}}%
[%
  \def\xiilbrace[{]%
  \def\xiirbrace[}]%
]% of |\firstofone|


\foone{\catcode`\_=\active}
{%
  \pdef\smartunder{%
    \catcode`\_=\active
    \def_{%
      \ifincsname\xiiunder
      \else
        \ifmmode\subs
        \else\xiiunder %
        \fi
      \fi}}}% We define it as \inverb|\_| not just as
\foone{\catcode`\!=0
  \@makeother\\}
{!newcommand*!xiibackslash{\}}

\let\bslash=\xiibackslash

\foone{\@makeother\%}
{\def\xiipercent{%}}

\foone{\@makeother\&}%
{\def\xiiand{&}}

\foone{\@makeother\ }%
{\def\xiispace{ }}

\foone{\@makeother\#}%
{\def\xiihash{#}}


\AtBeginDocument{%
  \ifdefined\xxt@visiblespace
    \let\visiblespace\xxt@visiblespace
    \def\xxt@visiblespace@fallback{{%
        \fontspec{Latin Modern Mono}\textvisiblespace}}%
  \else
    \let\visiblespace\xiispace
  \fi}

\foone\obeyspaces{\def\gmu@activespace{ }}

\foone\obeylines{\def\activeM{^^M}}

\pdef\makeblanksignored{%
  \catcode`\^^M=9\relax
  \catcode`\^^I=9\relax
  \catcode`\ =9\relax}

\pdef\fooblanksignored{%
  \foone{\makeblanksignored}%
}


\long\pdef\edefU#1#2{%
  \edef#1{\unexpanded{#2}}%
}

\long\pdef\xdefU#1#2{%
  \xdef#1{\unexpanded{#2}}%
}

\long\pdef\@ifnextcat#1#2#3{%
  \edefU\reserved@d{#1}%
  \edefU\reserved@a{#2}%
  \edefU\reserved@b{#3}%
  \futurelet\@let@token\@ifncat}

\def\@ifncat{%
  \ifx\@let@token\@sptoken
    \let\reserved@c\@xifncat
  \else
    \ifcat\reserved@d\@nx\@let@token
      \let\reserved@c\reserved@a
    \else
      \let\reserved@c\reserved@b
    \fi
  \fi
  \reserved@c}

{\def\:{\let\@sptoken= } \global\: % this makes |\@sptoken| a space token.

  % \DefIndex\@xifncat
\def\:{\@xifncat} \@xa\gdef\: {\futurelet\@let@token\@ifncat}}
\pdef\spifletter{\@ifnextcat a{\space}{}}

\long\pdef\@ifnextif#1#2#3{%
  \def\reserved@d{#1}%
  \def\reserved@a{#2}%
  \def\reserved@b{#3}%
  \futurelet\@let@token\@ifnif}

\def\@ifnif{%
  \ifx\@let@token\@sptoken
    \let\reserved@c\@xifnif
  \else
    \if\reserved@d\@nx\@let@token
      \let\reserved@c\reserved@a
    \else % |#1| of |\@ifnextif| is not |\if|-equivalent the future
      % token. But this may be because the future token is active
      % so it \emph{would} be |\if|-equivalent if not passed
      % through |\futurelet|. Let's manage this case.
      \begingroup
      \edef\gmu@tempa{%
        \lccode`\@nx~=`\reserved@d
      }\gmu@tempa
      \lowercase{\endgroup
        \ifx~}\@let@token
        \let\reserved@c\reserved@a
      \else
        \let\reserved@c\reserved@b
      \fi
    \fi
  \fi
  \reserved@c}

{\def\:{\let\@sptoken= } \: % this makes |\@sptoken| a space token.
\def\:{\@xifnif} \@xa\gdef\: {\futurelet\@let@token\@ifnif}}

\long\pdef\@ifnextac#1#2{%
  \@ifnextnotgroup
  {\gmu@ifnac{#1}{#2}}%
  {#2}}

\long\def\gmu@ifnac#1#2#3{%
  \ifcat\@nx~\@nx#3%
    \@xa\@firstoftwo
  \else\@xa\@secondoftwo
  \fi{#1#3}{#2#3}}



\pdef\gmu@lowstar{%
  \iffontchar\font"22C6 \char"22C6 \else\gmu@lowstarfake\fi
}% we could define it to


\def\gmu@tempa{*}
\foone{\catcode`\*=\active}
{\def\gmu@tempb{*}% it's defined in line \ref{active star}
 % to make |*| defined (when it was undefined,
  % \incmd\newcommand's \incs{gm@ifstar} test turned
  % true, the next undefined token was gobbled and raised an error).
  \let*=\gmu@lowstar}

\edef\gmu@tempa{%
  \long\pdef\@nx\gmu@ifstar##1##2{% \chgs{2008/12/16 v0.98 renamed from
    % \cs{@ifstar} since something
    % redefines \cs{@ifstar}}
    \@nx\@ifnextif\gmu@tempa%
    {\@nx\@firstoftwo{##1}}% it's a bit hacky but O.K.: if the
    % condition is not satisfied, the following brace is taken
    {%
      \@nx\@ifnextchar\@xa\@nx\gmu@tempb
      {\@nx\@firstoftwo{##1}}% and again, if the condition is not
      % satisfied, the second brace is taken.
      {##2}%
    }% of if not |*|\cat 12
  }% of |\gmu@ifstar|.
}\gmu@tempa


\long\pdef\@ifnextnotgroup#1#2{% \chgs{2008/12/11 v0.98 extracted from
  % \cs{@ifnextac}} This macro checks whether the next token is able
  % to be picked or is it a~braced list of tokens or is it a~group
  % closer so there's no token to be picked.
  \@ifnextcat\bgroup{#2}{%
    \@ifnextcat\egroup{#2}% \chgs{2008/12/11 v0.98 added test for
    % \cmd\egroup}
    {#1}}}

\long\pdef\@ifnextgroup#1#2{% Note this macro turns true both before
  % a~group opener and before a~group closer.
  \@ifnextnotgroup{#2}{#1}}

\pdef\ignoreactiveM{%
  \@ifnextgroup{}{\gmu@checkM}%
}

\foone\obeylines{% we know it's a~single token since we use this macro
  % only in \incmd\@ifnextgroup's ‘else’.
  \long\pdef\gmu@checkM#1{%
    \ifx
    #1\@xa\ignoreactiveM%
    \else\@xa#1\fi %
  }%
}

\let\gmu@reserveda\*%
\def\*{%
  \let\*\gmu@reserveda
  \let\gmu@letspace= }%
\* %


\lpdef\gmu@peep@next #1{%
  \let\@def@token\@undefined
  \edefU\gmu@peepnext@inner {%
    \gmu@CASE x {\@let@token\gmu@letspace}%
    {\@ifnextchar\par
      {#1}
      {\let\@let@token= \gmu@letspace % note |=| and blank space
        \@XA{#1}\space
      }%
    }% of if |\futurelet| detected a blank space
    %
    \gmu@CASE {AnyClause} % if any of the conditions below:
    {{ x {\@let@token\@undefined}
        x {\@let@token\relax}}} % it's arg of disjunction
    {\gmu@peep@hash{#1}}%
    %
    \gmu@lastCASE
    {#1}%
    \gmu@ESAC
  }%
  \futurelet\@let@token\gmu@peepnext@inner
}

\lpdef\gmu@peep@hash
#1% stuff that probably tests |#2| somehow
#2% a single token, which we are sure is undefined or |\relax| (and
{%
  \def\@def@token{#2}%
  #1%
  #2%
}

\lpdef\gmu@ifpeeped
#1% kind of comparison
#2% stuff to compare
{%
  \gmu@if {defined} {\@def@token}
  {\@XA{\gmu@if {#1}}\@xa{\@def@token #2}}
  {\gmu@if {#1} {\@let@token #2}}%
}

\long\pdef\@ifnextspace
#1% if yes
#2% if not
{%
  \gmu@peep@next
  {\gmu@if x {\@let@token\gmu@letspace}{#1}{#2}}%
}

\long\pdef\@ifnextcharRS
#1% a single token (will be |\ifx|ed)
#2% what if yes
#3% what if not
{%
  \gmu@peep@next
  {\gmu@if {defined} {\@def@token}
    {\@XA{\gmu@if {StrX}}\@xa {\@def@token #1}}% of the special “null”
                                % case
                                %
    {\gmu@if x {\@let@token #1}}%
    {#2}{#3}%
  }% of |\gmu@peep@next|
}

\long\pdef\@ifnextanyRS
#1% list of tokens (any balanced text, will be |\let| token after token
#2% what if next is one of listed |#1|
#3% what if not
{\gmu@peep@next
  {\gmu@if {defined} {\@def@token}
    {\@xa \gmu@ifStrXany \@def@token }
    % otherwise we are next to a defined and not |\relax| token so
    {\gmu@ifxany {\@let@token}}%
    {#1}{#2}{#3}%
  }% of peep
}


\long\def\gmu@ifnextStrXany
#1%  outer macro's tested list of tokens
#2% “if found” branch
#3% “if not found” branch
{\gmu@notif {AnyClause}
  {{ x {\@let@token\@undefined} x {\@let@token\relax}}}%
  {#2}%
  %
  % Some (i.e.\ \emph{both}) |\@undefined| or |\relax|, then we
  % compare strings
  {\gmu@futureifany {#2}{#3}{#1}}%
}

\long\def\gmu@futureifany
#1% what if \OK
#2% what if not \OK
#3% list of tokens
#4% token ot be checked against |#3| (and put back on the input) Note
{\gmu@ifstrany #4 {#3}{#1}{#2}#4}

\long\pdef\@ifnextanyIS
#1% list of tokens (any balanced text, will be |\let| token after token
#2% what if next is one of listed in |#1|
#3% what if not
{%
  \edefU\gmu@ifna@afterlet{%
    \gmu@if x{\@let@token\gmu@letspace}%
    {% if next is blank space, we drop it and retry:
      \edefU\gmu@ifna@resa{\@ifnextanyIS{#1}{#2}{#3}}%
      \afterassignment\gmu@ifna@resa
      \let\gmu@drain=
    }%
    {% else we perform |\gmu@ifnextanyIS|
      \gmu@ifxany{\@let@token}{#1}{%
        \gmu@ifnextStrXany {#1}{#2}{#3}%
      }%
      {#3}%
    }%
  }% of the after-let macro
  \futurelet\@let@token\gmu@ifna@afterlet
}% of |\@ifnextanyIS|

\long\pdef\@ifnextnoneRS
#1% list of tokens (any balanced text, will be |\let| token after token
#2% what if next is one of listed |#1|
#3% what if not
{%
  \@ifnextanyRS{#1}{#3}{#2}%
}

\long\pdef\@ifnextgroupRS #1#2{%
  \gmu@peep@next
  {\gmu@if x{\@let@token\bgroup}{#1}%
    {\gmu@if x{\@let@token\egroup}{#1}{#2}}%
  }%
}

\long\pdef\@ifnextnotgroupRS#1#2{%
  \@ifnextgroupRS{#2}{#1}}



\foone\obeylines{%
  \long\pdef\@ifnextMac#1#2{%
    \@ifnextchar^^M{#1}{#2}}}

\long\def\xiistring#1{%
  \if\@nx#1\xiispace
    \xiispace
  \else
    \afterfi{\string#1}% to make the same error as bare |\string|
    % would cause in case of empty \inhash1.
  \fi}

\def\@xiispaces#1 #2\@nil{%
  #1%
  \ifx\@xiispaces#2\@xiispaces
  \else
  \xiispace
  \afterfi{\@xiispaces#2\@nil}%
  \fi}

\long\pdef\xiiEdetoke
#1% a scratch \CS
#2% stuff to be fully expanded and turned to catcode 12 including
  % spaces.
{%
  \edef#1{#2}%
  \edef#1{%
    \@xa\@xa\@xa\@xiispaces
    \@xa\detokenize\@xa{#1} \@nil}%
}

\long\def\@ifEUnextchar#1#2#3{%
  % ‘if Edefed Unexpanded next char’
  \let\reserved@d=#1%
 \edefU\reserved@a{#2}%
 \edefU\reserved@b{#3}%
 \futurelet\@let@token\@ifnch}

\newcommand\gmu@storespecials[1][]{% we provide a~possibility of
  % adding stuff. For usage see line \ref{@storespecials}.
  \def\do##1{\catcode`\@nx##1=\the\catcode`##1\relax}%
  \edef\gmu@restorespecials{%
    \dospecials\do\^^M}#1}

\pdef\gmu@septify{% restoring the standard catcodes of specials. The
  % name is the opposite of `sanitize' ^^A(
  % :-)\,. It restores also the original catcode of \inverb|^^M|.
  \def\do{\relax\catcode`}%
  \do\ 10\do\\0\do\{1\do\}2\do\$3\do\&4%
  \do\#6\do\^7\do\_8\do\%14\do\~13\do\^^M5\relax
  %\nostanza |%% \let\do\@makeother|\\
  % |%% \do0\do1\do2\do3\do4\do5\do6\do7\do8\do9\relax|\nostanza
}

\newif\ifgmu@SMglobal

\pdef\SMglobal{\gmu@SMglobaltrue}

\def\MakePrivateLetters{\makeatletter}

\pdef\StoreMacro{%
  \begingroup\MakePrivateLetters
  \gmu@ifstar\egStore@MacroSt\egStore@Macro}

\lpdef\egStore@Macro#1{\endgroup\Store@Macro{#1}}
\lpdef\egStore@MacroSt#1{\endgroup\Store@MacroSt{#1}}

\pdef\StoreMacro@nocat
{%
  \gmu@ifstar \Store@MacroSt \Store@Macro
}

\def\gmu@storeprefix{/gmu/store}

\lpdef\Store@Macro#1{%
  \escapechar92
  \ifgmu@SMglobal\afterfi\global\fi
  \@xa\let\csname \gmu@storeprefix/\bslash@or@ac{#1}\endcsname#1%
  \global\gmu@SMglobalfalse
}

\lpdef\Store@MacroSt#1{%
  \edef\gmu@smtempa{%
    \ifgmu@SMglobal\@xa\global\fi
    \let\@xa\@nx\csname\gmu@storeprefix/\bslash@or@ac{#1}\@xa\endcsname%\label{SMbslash}
    % we add backslash because to ensure compatibility between
    % \incs{(Re)StoreMacro} and \incs{(Re)StoreMacro*}, that is. to allow
    % writing e.g.  \inverb|\StoreMacro\kitten| and then
    % \inverb|\RestoreMacro*{kitten}| to restore the meaning of
    % \incs{kitten}.\ilrr
    \ifcsname #1\endcsname % \chgs[\StoreMacro]{2010/04/16 v0.993
    % fixed asymmetry with the unstarred version: till today the
    % unstarred version for an undefined \CS undefine the storage \CS
    % and the starred version made it \cmd\relax. Now both undefine}
    % If the argument \CS is undefined, we undefine the storage macro too.
      \@xa\@nx\csname#1\endcsname
    \else\@nx\@undefined
    \fi
    \global\gmu@SMglobalfalse}%% we wish the globality to be just
  % once.\par
  \gmu@smtempa
}


\lpdef\StoreMacros{\begingroup\MakePrivateLetters\egStore@Macros}

\lpdef\egStore@Macros#1{\endgroup
  \Store@Macros{#1}%
}

\lpdef\Store@Macros #1{%
  \gmu@setsetSMglobal
  \let\gml@StoreCS\Store@Macro
  \gml@storemacros#1.}

\def\gmu@setsetSMglobal{%
  \ifgmu@SMglobal
    \let\gmu@setSMglobal\gmu@SMglobaltrue
  \else
    \let\gmu@setSMglobal\gmu@SMglobalfalse
  \fi}

\lpdef\gml@storemacros#1{%
  \def\gmu@storemacros@resa{\@nx#1}% My \TeX\ Guru's trick to deal with |\fi|
  % and such, i.e., to hide |#1| from \TeX\ when it is processing a~test's
  % branch without expanding.
  \if\gmu@storemacros@resa.% a~dot finishes storing.
    \global\gmu@SMglobalfalse
  \else
    \if\gmu@storemacros@resa,% The list this macro is put before may
    % contain commas and that's O.K., we just continue the work.
      \afterfifi\gml@storemacros
    \else% what is else this shall be stored.
      \gml@StoreCS{#1}% we use a~particular \CS to may |\let| it both to
      % the storing macro as above and to the restoring one as
      % \gmiflink[letRestore]{below}.
      \afterfifi{\gmu@setSMglobal\gml@storemacros}%
    \fi
  \fi
}

\lpdef\RestoreMacro{%
  \begingroup\MakePrivateLetters\gmu@ifstar\egRestore@MacroSt\egRestore@Macro}

\lpdef\egRestore@Macro#1{\endgroup\Restore@Macro{#1}}
\lpdef\egRestore@MacroSt#1{\endgroup\Restore@MacroSt{#1}}

\lpdef\Restore@Macro#1{%
  \escapechar92
  \gmu@ifstored#1{%
    \ifgmu@SMglobal\afterfi\global\fi
    \@xa\let\@xa#1\csname \gmu@storeprefix/\bslash@or@ac{#1}\endcsname
    \global\gmu@SMglobalfalse}%
  {\unless\ifgmu@quiet
      \PackageWarning{gmutils}{\@nx#1 is not stored, I do nothing with
        it}%
    \fi
  }%
}

\long\def\gmu@ifstored#1#2#3{%
  \gmu@ifundefined{\gmu@storeprefix/%
    \bslash@or@ac{#1}}{#3}{#2}%
}

\lpdef\gmu@storeifnotyet#1{%
  \gmu@if {} {\relax\@nx#1}% we check if it's a~\CS
  {\gmu@ifstored{#1}{}{\StoreMacro@nocat#1}}%
  {}%
}

\lpdef\Restore@MacroSt#1{%
  \gmu@ifundefined{\gmu@storeprefix/\bslash@or@ac{#1}}%
  {\unless\ifgmu@quiet
    \PackageWarning{gmutils}{\bslash#1 is not stored. I~do nothing}%
    \fi}%
  {\edef\gmu@smtempa{%
      \ifgmu@SMglobal\global\fi
      \@nx\let\@xa\@nx\csname#1\endcsname
      \@xa\@nx\csname\gmu@storeprefix/\bslash@or@ac{#1}\endcsname}% cf. the commentary
    % in line \ref{SMbslash}.
    \gmu@smtempa}%
  \global\gmu@SMglobalfalse
}

\lpdef\RestoreMacros{%
  \begingroup\MakePrivateLetters
  \egRestore@Macros}

\lpdef\egRestore@Macros#1{\endgroup
  \Restore@Macros{#1}%
}

\lpdef\Restore@Macros #1{%
  \gmu@setsetSMglobal
  \let\gml@StoreCS\Restore@Macro% \gmhypertarget[letRestore]{we}
  % direct the core \CS towards restoring and call the same iterating
  % macro as in line \ref{InnerStore}.
  \gml@storemacros#1.}

\pdef\ResetMacro{% restore possibly to |\@undefined|
  % \chgs{2010/04/16 v0.993 added}
  \begingroup\MakePrivateLetters\gmu@ifstar\egReset@MacroSt\egReset@Macro}

\lpdef\egReset@Macro#1{\endgroup\Reset@Macro{#1}}
\lpdef\egReset@MacroSt#1{\endgroup\Reset@MacroSt{#1}}

\lpdef\Reset@Macro#1{%
  \escapechar92
  \ifgmu@SMglobal\@xa\global\fi
  \ifcsname  \gmu@storeprefix/\bslash@or@ac{#1}\endcsname
    \@xa\let\@xa#1\csname \gmu@storeprefix/\bslash@or@ac{#1}\endcsname
  \else
    \let#1\@undefined
  \fi
  \global\gmu@SMglobalfalse
}%

\lpdef\Reset@MacroSt#1{%
  \ifcsname \gmu@storeprefix/\bslash@or@ac{#1}\endcsname
    \ifgmu@SMglobal\@xa\global\fi
    \@xa\let\csname#1\@xa\endcsname
    \csname\gmu@storeprefix/\bslash@or@ac{#1}\endcsname % cf. the commentary
    % in line \ref{SMbslash}.
  \else
    \@xa\let\csname#1\endcsname\@undefined
  \fi
  \global\gmu@SMglobalfalse
}

\lpdef\ResetMacros{\begingroup\MakePrivateLetters\Reset@Macros}

\lpdef\Reset@Macros#1{\endgroup
  \gmu@setsetSMglobal
  \let\gml@StoreCS\Reset@Macro% \gmhypertarget[letReset]{we}
  % direct the core \CS towards restoring and call the same iterating
  % macro as in line \ref{InnerStore}.
  \gml@storemacros#1.}

\pdef\StoredMacro{\begingroup\MakePrivateLetters\Stored@Macro}
\lpdef\Stored@Macro#1{\endgroup\Restore@Macro#1#1}

\long\def\storedcsname#1{%% \changes{v0.88}{2008/08/03}{added}
  \ifcsname \gmu@storeprefix/\bslash@or@ac{#1}\endcsname
    \afterfi{%
      \csname \gmu@storeprefix/\bslash@or@ac{#1}\endcsname}%
  \else \@xa \@undefined
  \fi
}

\pdef\StoreEnvironment#1{% \label{StoreEnvironment}
  \Store@MacroSt{#1}\Store@MacroSt{end#1}}

\pdef\RestoreEnvironment#1{%
  \Restore@MacroSt{#1}\Restore@MacroSt{end#1}}

\pdef\StoringAndRelaxingDo{%
  \gmu@SMdo@setscope
  \long\def\do##1{%
    \gmu@SMdo@scope
    \@xa\let\csname \gmu@storeprefix/\bslash@or@ac{##1}\endcsname##1%
    \gmu@SMdo@scope\let##1\relax}}

\pdef\gmu@SMdo@setscope{%
  \ifgmu@SMglobal\let\gmu@SMdo@scope\global
  \else\let\gmu@SMdo@scope\relax
  \fi
  \global\gmu@SMglobalfalse
}

\lpdef\RestoringDo{%
  \gmu@SMdo@setscope
  \long\def\do##1{%
    \gmu@SMdo@scope
    \@xa\let\@xa##1\csname
    \gmu@storeprefix/\bslash@or@ac{##1}\endcsname}%
}

\pdef\gmu@MakeScopePrefix
#1% \CS to be let |\global| or |\relax|
#2% a sequence of tokens
{%
  \let#1\relax
  \gmu@ifxany{\global}{#2}%
  {\let#1\global}{}%
}

\lpdef\gmu@namelet
#1% scope prefix (to be honest, \emph{any} sequence of tokens that may
  % be passed as an argument: |\gmu@ifxany| will parse it)
#2% left side of the assignment
#3% right side of the assignment
{%
  \gmu@MakeScopePrefix\gmu@namelet@scpref{#1}%
  \gmu@if {csname} {#3\endcsname}%
  {%
    \@xa\gmu@namelet@scpref\@xa\let\csname#2\@xa\endcsname
    \csname#3\endcsname}%
  {%
    \@xa\gmu@namelet@scpref
    \@xa\let\csname#2\endcsname\@undefined}%
}

\pdef\n@melet{\gmu@namelet\relax}

\pdef\gn@melet{\gmu@namelet\global}

\long\pdef\tri@let
#1% scope prefix(es)
#2% left side
#3% right side of the assignment
{%
  \gmu@MakeScopePrefix\gmu@tri@let@scpref{#1}%
  \ifcat\@nx~\@nx#2%
    \def\next{\gmu@tri@let@scpref\let#2}%
  \else \edef\next{\gmu@tri@let@scpref\let\@xanxtri{#2}}%
  \fi
  \ifcat\@nx~\@nx#3%
    \next#3%
  \else
    \edef\next{%
      \@xau\next
      \ifcsname \strip@bslash{#3}\endcsname
      \@xanxtri{#3}%
      \else\@nx\@undefined
      \fi
    }% of next's edef
    \next
  \fi
}%

\long\pdef\envirlet#1#2{% for |\let|ting environments.
  \n@melet{#1}{#2}%
  \n@melet{end#1}{end#2}%
}

\long\pdef\glenvirlet#1#2{% for |\let|ting environments.
  \gn@melet{#1}{#2}%
  \gn@melet{end#1}{end#2}%
}



\def\@ifXeTeX{% two-argument command
  \ifdefined\XeTeXversion
  \unless\ifx\XeTeXversion\relax\afterfifi\@firstoftwo\else\afterfifi\@secondoftwo\fi
  \else\afterfi\@secondoftwo\fi
}


\newif\ifgmuXeTeX
\@ifXeTeX{\gmuXeTeXtrue}{}%


\@ifXeTeX{%
  \pdef\textbullet{% \changes{v0.94}{2008/10/3}{the \XeTeX\
    % version enriched with \cs{iffontchar} due to lack of bullets
    % with the default settings reported by Morten H\o{}gholm and Edd Barrett}
    \iffontchar\font"2022 \char"2022 \else\ensuremath{\bullet}\fi}%
  %
  \pprovide\glyphname#1{% \changes{v0.96}{2008/11/12}{moved here from
    % my private document class}
    \XeTeXglyph \numexpr\XeTeXglyphindex "#1"\relax\relax}% since
                                % \XeTeX\ … \incs{numexpr} is redundant.
}
{\def\textbullet{\ensuremath{\bullet}}}

\def\if@XeTeX {\@ifXeTeX {\iftrue}{\iffalse}}


\long\def\detoken@xa#1{\detokenize\@xa{#1}}

 \long\def\all@other#1{\@xa\gmu@gobmacro\meaning#1}

 % The |\gmu@gobmacro| macro above is applied to gobble the |\meaning|'s
 % beginning, |long macro:->| all `other' that is.
 % \Define\gmu@gobmacro
 \edef\gmu@tempa{%
   \def\@nx\gmu@gobmacro##1\@xa\@gobble\string\macro:##2->{}}
 \gmu@tempa


\def\gmshowlists{%
  \tracingonline=1
  \showboxdepth=1 \showboxbreadth=1000000 \showlists}

\def\gmshowbox{%
  \tracingonline=1
  \showboxdepth=10000 \showboxbreadth=10000 \showbox}

\def\gmtracingoutput{%
  \tracingoutput\@ne
  \tracingonline=\@ne
  \showboxdepth=1
  \showboxbreadth=1000000
}

\newif\ifgmu@debug@msgs

\def\gmtron{%
  \tracingonline=\@M
  \tracingmacros=\@M
  \tracingassigns=\@M
  \tracingcommands=\@m
  \gmu@debug@msgstrue
  \let\let\let
}

\def\gmtroff{%
  \tracingonline=\m@ne
  \tracingmacros\m@ne
  \tracingassigns=\m@ne
  \tracingcommands=\m@ne
  \tracingoutput=\m@ne
  \gmu@debug@msgsfalse
  \let\let\let
}

\newcommand\nameshow[1]{%
  \ifcsname #1\endcsname
    \@xa\show\csname#1\endcsname
  \else \show\@undefined
  \fi}

\newcommand\nameshowthe[1]{%
  \ifcsname #1\endcsname
    \@xa\showthe\csname#1\endcsname
  \else \showthe\@undefined
  \fi}

\newcommand\namemeaning[1]{%
  \ifcsname #1\endcsname
    \@xa\typeout{\@xa\meaning\csname#1\endcsname}%
    \show\relax
  \else \typeout{\meaning\@undefined}\show\relax
  \fi}

\def\secondclass{%
  \newif\ifSecondClass
  \SecondClasstrue
  \@fileswithoptions\@clsextension}%|[outeroff,gmeometric]{gmdocc}|%

\AtBeginDocument{%
  \unless\ifdefined\@parindent
    \newskip\@parindent
    \@parindent=\parindent
  \fi
}

\def\balsmiley#1 {}% to balance parentheses and brackets in
                % smileys. \balsmiley( ;-) \inverb|\balsmiley( ;-)|

\long\def\scantnoline#1{%  ‘rescan tokens without adding line at the end’
  {\endlinechar\m@ne\scantokens{#1}}}

\pdef\getprevdepth{% to pass last depth through a group (e.g. |\end{envir.}|)
  \endgraf
  \xdef\setprevdepth{\prevdepth=\the\prevdepth\relax}%
}

\pdef\getprevdepthlocal{%
  \endgraf
  \edef\setprevdepth{\prevdepth=\the\prevdepth\relax}%
}

\def\StoreCatM{%
  \protected\edef\RestoreCatM{%
    \catcode`\@nx\^^M=\the\catcode`\^^M\relax}%
}

\pdef\RestoreCatM{\PackageE{gmutils}{first store the catcode of
    ^\empty^\empty M with \string\StoreCatM.}%
}


\RequirePackage{graphicx}

\pdef\resizegraphics#1#2#3{% % \changes{v0.94}{2008/10/4}{\cs{includegraphics}
  % works well in \XeTeX\ so I~remove the complicated version
  % with \cs{XeTeXpicfile}}
  % 2009/11/17 works bad with a file whose name contains spaces so I
  % return \cmd\XeTeXpicfile
  \resizebox{#1}{#2}{%
    \edef\gmu@tempa{\@nx\csname XeTeX\@nx\@ifendswithpdf{%
        \@xa\string\csname#3\endcsname}{pdf}{pic}file\@nx\endcsname}%
    \gmu@tempa "#3"\relax}}

\edef\gmu@tempa{%
  \def\@nx\@ifendswithpdf##1{%
    \unexpanded{%
      \ifnum
      \if\relax\gmu@pdfdetector}##1%
    \detokenize{pdf}\unexpanded{\relax0\else1\fi}% we expand to 1 if
    % \inhash1 ends with lowercase ‘pdf’ of cat. 12
    \unexpanded{\if\relax\gmu@PDFdetector}##1%
    \detokenize{PDF}\unexpanded{\relax0\else1\fi}% we expand to 1 if
    % \inhash1 ends with uppercase ‘PDF’ of cat. 12
    >0
    \unexpanded{\@xa\@firstoftwo\else\@xa\@secondoftwo\fi}%
  }% of |\@ifendswithpdf|
  %
  % \stanza
  %
  \def\@nx\gmu@pdfdetector##1\detokenize{pdf}{}%
  \def\@nx\gmu@PDFdetector##1\detokenize{PDF}{}%
}\gmu@tempa


\def\lastcentered{%
  \lastlinefit\z@
  \parindent0sp\relax
  \leftskip\dimexpr1\leftskip\relax plus 1fil\relax
  \rightskip\dimexpr1\rightskip\relax plus -1fil\relax
  \parfillskip0sp plus 2fil\relax
}

\def\endlastcentered{\par\@endpetrue}

\def\firstcentered{%
  \lastlinefit\z@
  \parfillskip 0sp\relax
  \rightskip0sp plus 1fil\relax
  \leftskip0sp plus -1fil\relax
  \parindent 0sp
  \addtotoks\everypar{\hskip0sp plus 2fil\relax}%
}

\let\endfirstcentered\endlastcentered

\def\gmu@measurewd#1{% \label{@measurewd}
  \edef\gmu@tempa{\the\fontcharwd\font`#1}%
  \settowidth{\@tempdimb}{% to preserve kerning
    \char`#1\char`#1\char`#1\char`#1\char`#1\char`#1%
    \char`#1\char`#1\char`#1\char`#1\char`#1\char`#1%
    \char`#1\char`#1\char`#1\char`#1\char`#1\char`#1%
    \char`#1\char`#1\char`#1}%
  \edef\gmu@tempb{\the\dimexpr(\@tempdimb-\gmu@tempa)/20}%
}

\def\@xa@three#1#2{% reverses expansion of three tokens, two given as
  % arguments. (third may be |{|^^A }
  % )
  \@xa\@xa\@xa \@xa\@xa\@xa \@xa #1%
  \@xa\@xa\@xa #2%
  \@xa }

\def\@xa@four#1#2#3{% reverses expansion of four tokens, three given as
  % arguments. (fourth may be |{|^^A }
  % )
  \@xa\@xa\@xa\@xa \@xa\@xa \@xa
  \@xa\@xa\@xa\@xa \@xa\@xa\@xa\@xa #1%
  \@xa\@xa\@xa\@xa \@xa\@xa \@xa #2
  \@xa\@xa\@xa #3%
  \@xa }


\long\pdef\@ifenvir#1{%\label{@ifenvir}\
  % \begin{enumargs}
  %   \mand enquired environment name which will be confronted with
  %   \incs{@currenvir}
  %   \mand what if true (if the names are
  %   equivalent\qfootnote{The names are checked whether they produce
  %     the same \cmd\csname. They don't have to have the same
  %     catcodes.})
  %   \mand what if false
  % \end{enumargs}
  %
  % \changes{v0.92}{2008/08/07}{added}
  % \chgs{2010/06/02 v0.993 made \cmd\protected after an error at work}
  \gmu@ifedetokens{\@currenvir}{#1}%
}

\pdef\@ifjobname#1{\gmu@ifedetokens{\jobname}{#1}}

\long\def\gmu@ifstrcmp
#1% wrapper for left side of comparison
#2% wrapper for right side of comparison
#3% left side of comparison (list of tokens)
#4% right —”—
{%
  \ifnum\strcmp{#1{#3}}{#2{#4}}=\z@
    \@xa\@firstoftwo
  \else
    \@xa\@secondoftwo
  \fi
}

\def\gmu@ifdetokens
{%
  \gmu@ifstrcmp\detokenize\detokenize
}% of |\gmu@ifdetokens|

\def\gmu@ifutokens
{%
  \gmu@ifstrcmp\unexpanded\unexpanded
}

\def\gmu@ifedetokens{%
  \gmu@ifstrcmp \@firstofone \@firstofone
}

\@XA{\pdef\gmu@pifdetokens}\@xa{\gmu@ifdetokens}

\@XA{\pdef\gmu@pifutokens}\@xa{\gmu@ifutokens}

\@XA{\pdef\gmu@pifedetokens}\@xa{\gmu@ifedetokens}

  % \chgs{2009/04/21 v0.99 moved to a~separate macro from
  % \cmd\@ifenvir\ and made symmetric to both arguments}
  % \chgs{2008/12/01 v0.98 rewritten not to make entries in the hash
  % table, thanks to \cmd\detokenize\ and made robust to open \cs{if}s
  % in the arguments thanks to substitution of explicit parameters
  % with \cmd\@firstoftwo\ and \cmd\@secondoftwo}



\def\gmu@HHashes#1#2{% this is a~fully expandable loop analogous to
  % that of The  % \eTeX\ Manual p.~9.
  \ifnum#1<#2 %
  ################\number#1
  \expandafter\gmu@HHashes
  \expandafter{\number\numexpr#1+1\expandafter}%
  \expandafter{\number#2\expandafter}%
  \fi}% of |\gmu@HHashes|.

\def\gmu@Hashes#1#2{% this is a~fully expandable loop analogous to
  % that of The  % \eTeX\ Manual p.~9.
  % expanding in an |\edef| to |####›1›…####⁄<h.$2-1$>| (quadruple hashes' sequence)
  \ifnum#1<#2 %
  ########\number#1
  \expandafter\gmu@HHashes
  \expandafter{\number\numexpr#1+1\expandafter}%
  \expandafter{\number#2\expandafter}%
  \fi}% of |\gmu@hashes|.

\def\gmu@hashes#1#2{% this is a  loop analogous to
  \ifnum#1<#2%
  ####\number#1
  \expandafter\gmu@hashes
  \expandafter{\number\numexpr#1+1\expandafter}%
  \expandafter{\number#2\expandafter}%
  \fi
}% of |\gmu@hashes|.

\def\gmu@HHashesbraced#1#2{%
  \ifnum#1<#2%
  {################\number#1}%
  \expandafter\gmu@HHashesbraced
  \expandafter{\number\numexpr#1+1\expandafter}%
  \expandafter{\number#2\expandafter}%
  \fi}% of |\gmu@hashesbraced|.

\def\gmu@Hashesbraced#1#2{%
  \ifnum#1<#2%
  {########\number#1}%
  \expandafter\gmu@HHashesbraced
  \expandafter{\number\numexpr#1+1\expandafter}%
  \expandafter{\number#2\expandafter}%
  \fi}% of |\gmu@hashesbraced|.

\def\gmu@hashesbraced#1#2{%
  \ifnum#1<#2%
  {####\number#1}%
  \expandafter\gmu@hashesbraced
  \expandafter{\number\numexpr#1+1\expandafter}%
  \expandafter{\number#2\expandafter}%
  \fi
}% of |\gmu@hashesbraced|.

\def\gmu@hashesOut#1#2{%
  \ifnum#1<#2%
  \space\space\space\space
  »\@nx\unexpanded{####\number#1}«%
  \expandafter\gmu@hashesOut
  \expandafter{\number\numexpr#1+1\expandafter}%
  \expandafter{\number#2\expandafter}%
  \fi
}% of |\gmu@hashesbraced|.

\def\gmu@hashesOutU#1#2{%
  \ifnum#1<#2%
  \space\space\space\space
  »\@nx\unexpanded{####\number#1}«%
  \expandafter\gmu@hashesOut
  \expandafter{\number\numexpr#1+1\expandafter}%
  \expandafter{\number#2\expandafter}%
  \fi
}% of |\gmu@hashesbraced|.

\@tempcnta=1
\@whilenum\@tempcnta<11\do{% 2010/4/15
  \@nameedef{gmu@hashes@\the\numexpr\@tempcnta-1\relax}%
  {\gmu@hashes1\@tempcnta}%
  %
  \@nameedef{gmu@Hashes@\the\numexpr\@tempcnta-1\relax}%
  {\gmu@Hashes1\@tempcnta}%
  %
  \@nameedef{gmu@HHashes@\the\numexpr\@tempcnta-1\relax}%
  {\gmu@HHashes1\@tempcnta}%
  %
  \@nameedef{gmu@hashesbraced@\the\numexpr\@tempcnta-1\relax}%
  {\gmu@hashesbraced1\@tempcnta}%
  %
  \@nameedef{gmu@Hashesbraced@\the\numexpr\@tempcnta-1\relax}%
  {\gmu@Hashesbraced1\@tempcnta}%
  % %
  \@nameedef{gmu@HHashesbraced@\the\numexpr\@tempcnta-1\relax}%
  {\gmu@HHashesbraced1\@tempcnta}%
  %
  \edef\gmu@eloops@resa{%
    \long\def\@xanxcs{% ^^A >>>>>> printhashes
      gmu@TOhashes@\romannumeral\numexpr\@tempcnta-1\relax}%
      \gmu@hashes1\@tempcnta{%
        \@nx\TypeOut{%
          \gmu@hashesOut % ^^A2
          1 \@tempcnta}%
      }% of |\gmu@TOhashes@viii| etc.
      %
    }% of temporary macro
    %
    \gmu@eloops@resa
    % Generates nine pairs of macros |\gmu@TOhashes@i|,
    % |\gmu@TOUhashes@i|, |\gmu@TOhashes@ii|, |\gmu@TOUhashes@ii|
    % etc. that print (type out) their arguments  on the terminal,
    % ^^A expanded or \textbf Unexpanded.
    % unexpanded
    %
    \advance\@tempcnta\@ne
}% of |\@whilenum|

\foone{\catcode`\ \active}%
{\newcommand*\gmobeyspaces{\let \ \catcode`\ \active}}

\newcommand*\nohy{\leavevmode\kern0sp\relax}
\newcommand*\yeshy{\leavevmode\penalty\@M\hskip\z@skip}

\long\pdef\gmu@EdefCurrnames#1{%
  \xiiEdetoke\gmu@EdefCurrnames@resa{#1}%
  \@xa  \gmu@EdefCurrnames@ \gmu@EdefCurrnames@resa.tex.\@nil
  % if no extension is present, |tex| is assumed. This couple of
  % macros won't work well for files with dots in their names.
}

\pdef\gmu@EdefCurrnames@ #1.#2.#3\@nil{%
  \def\@currname{#1}%
  \def\@currext{#2}%
}

\def\NamedInput@prepare#1{% we wrap in a macro to use also in |\DocInput|
  \@pushfilename
  \gmu@EdefCurrnames {#1}%
}

\let\NamedInput@finish=\@popfilename

\pdef\NamedInput#1{% useful e.g.~in error handling
  \NamedInput@prepare {#1}%
  \@@input #1\relax
  \NamedInput@finish
}

\def\gmu@ifdim
#1% dimen specification
#2% comparison
#3% dimen specification
{%
  \ifnum0\ifx#2≤1\fi\ifx#2≥1\fi\ifx#2≠1\fi=\@ne
    \afterfi\unless
  \fi
  \ifdim#1\ifx#2≤>\fi\ifx#2≥<\fi\ifx#2≠=\fi
    \ifx#2>>\fi\ifx#2<<\fi\ifx#2==\fi
    \dimexpr(#3)*1\relax% parentheses are for closing all possible
                        % \eTeX pressions not to gobble that |\relax|
                        % by them but only by the outermost |\dimexpr|
                        % to avoid premature expansion of the
                        % following |\expandafter|. (2010/6/14)
    \@xa\@firstoftwo
  \else\@xa\@secondoftwo
  \fi
}

\def\gmu@ifskip
#1% glue specification
#2% comparison for natural part
#3% comparison for stretch part
#4% comparison for shrink part
#5% glue specification
{\ifnum
    0\gmu@ifdim{1\glueexpr#1}#2{1\glueexpr#5}10%
    \gmu@ifdim{\gluestretch\glueexpr#1}#3{\gluestretch\glueexpr#5}10%
    \gmu@ifdim{\glueshrink\glueexpr#1}#4{\glueshrink\glueexpr#5}10=111
    \@xa\@firstoftwo
  \else\@xa\@secondoftwo
  \fi
}% of |\gmu@ifskip|.

\def\gmu@ifbox
#1% a box register number (e.g.~|\copy\z@|)
#2% comparison for heights
#3% comparison for depths
#4% comparison for widths
#5% a box register number
{%
  \gmu@ifskip
  {\glueexpr (\ht#1 plus \dp#1 minus\wd#1 )*1\relax}%
  #2#3#4%
  {\glueexpr (\ht#5 plus \dp#5 minus\wd#5 )*1\relax}%
}

\def\greater@dim#1#2{%
  \ifdim\dimexpr#1>\dimexpr(#2)*1\relax
    #1%
  \else #2%
  \fi
}

\long\pdef\gmu@removeelement
#1% element to be removed
#2% macro carrying a comma-separated list
#3% \CS to carry removed element.
{%
  \let#3\@undefined%
  \def\gmu@removeelement@resa##1,#1,##2\@nil{%
    \gmu@ifempty{##2}%
    {\edefU#2{##1}}%
    {\edefU#2{##1,##2}%
      \def#3{#1}%
      \@xa\gmu@removeelement@resa#2\@nil
    }%
    % If |##2| is not empty, then we know |#1| was in the list so we
    % have to remove its copy from the end of the list.
  }% of |\gmu@removeelement@resa|
  \@xa\gmu@removeelement@resa\@xa,#2,#1,\@nil
  % We gobble the beginning comma
  \@xa\@xa\@xa\ifx\@xa\@firstofmany#2\relax\@nil,%
    \edef#2{\unexpanded
      \@xa\@xa\@xa{\@xa\@gobble#2}}%
  \fi
}

\long\def\@nxcsn#1{%
  \@xa\@nx\csname #1\endcsname}


\def\@listbegvskipping{%
  \@topsepadd=\topsep
  \ifvmode
    \advance\@topsepadd by\partopsep
  \fi
  \par
  \addvspace\@topsepadd
}


\def\foolc#1#2{%
  \begingroup\lccode`#1=`#2\relax
  \lcfirstofone
}

\long\def\lcfirstofone#1{%
  \lowercase{\endgroup#1}%
}

\long\def\PackageWarning#1#2{%
  \GenericWarning{%
    (#1)\@spaces\@spaces\@spaces\@spaces
  }{%
    Package #1 Warning: #2%
  }%
}

\long\def\TypeOut#1{%
  \edef\TO@resa{#1}%
  \edef\TO@resa{\@xa\detokenize\@xa{\TO@resa}}%
  \typeout{\TO@resa}}

\long\def\ShowOut#1{%
  \TypeOut{#1}%
  \show\TO@resa
}

\long\pdef\incsdef
#1% a CS or active char
#2% parameters string
#3% definition's body
{%
  \def#1#2{\gmu@ifincsname {\string#1}{#3}}%
}


\gmu@DefSymbol\gmu@CountTokens@end
\newcount\c@gmu@TokensCount

\lpdef\gmu@CountTokens
#1% the tokens to be counted.
{%
  \c@gmu@TokensCount=\m@ne
  \let\gmu@CountToken@token\@undefined
  \gmu@CountToken@iter
  #1\gmu@CountTokens@end
}

\def\gmu@CountToken@iter{%
  \gmu@if x{\gmu@CountToken@token\gmu@CountTokens@end}%
  {}% we've reached the end of iteration
  {%
    % We increase the counter and throw the iterator after next assignment
    \advance\c@gmu@TokensCount\@ne
    \afterassignment\gmu@CountToken@iter
    \let\gmu@CountToken@token=
  }%
}%


\long\def\gmu@passbraced
#1% the stuff to be put before |#2|
#2% the stuff we check and pass unbraced if single or braced otherwise
{%
  \gmu@CountTokens{#2}%
  \gmu@if {num}{\c@gmu@TokensCount=\@ne}%
  {\gmu@if x{#2 }% if |#2| is single token of blank space then we
                 % don't consider it single since it can't be an
                 % argument to a macro if without braces.
    \@secondoftwo\@firstoftwo
  }%
  \@secondoftwo
  {#1#2}{#1{{#2}}}%
}% of |\gmu@passbraced|

\long\def\gmu@passbracedNotSp
#1% the stuff to be put before |#2|
#2% the stuff we check and pass unbraced if single or braced otherwise
{%
  \gmu@CountTokens{#2}%
  \gmu@if {num}{\c@gmu@TokensCount=\@ne}%
  {#1{#2}}%
  {#1{{#2}}}%
}% of |\gmu@passbracedNotSp|

\long\def\MeaningOrUnex#1{%
  \gmu@if {singletoken}{{#1}}%
  {\meaning#1}{\unexpanded{#1}}%
}

\pldef\@iwru#1{%
  %
  % as simple as possible not to put much output on the terminal if
  % tracing is on.
  %
  \immediate \write \@unused {l.\the\inputlineno:\space #1}%
}

\pldef\@iwruJ{\@iwru{^^J}}

\pldef\@iwrum#1{%
  \@iwru{»\unexpanded{#1}« is »\MeaningOrUnex{#1}«}%
}

\pldef\@iwruU #1{\@iwru{\unexpanded{#1}}}

\pldef\@iwruif#1{%
  \gmu@if {gmu@debug@msgs}{}
  {\@iwru{#1}}{}%
}

\long\pdef\IgnInfo
#1% package name
#2% description
#3% stuff we announce as ignored
{%
  \PackageInfo{#1}{Item »\unexpanded{#3}« (\MeaningOrUnex{#3}) ignored^^J%
      #2}%
}

\pldef\@iwma{%
  % (Added 2010/10/19)
  %
  % Note it takes a \emph{text} not an argument.
  \immediate \write \@mainaux
}

\def\stepnummacro
#1% a macro that expands to some numerical stuff
#2%
{\edef#1{\the\numexpr #1+#2}}

\def\boolstobin
#1% a sequence of Boolean switches' names without »if«
{%
  \numexpr \boolstobin@iter 0 #1 {}\gmu@delim %
}

\def\boolstobin@iter
#1% expression so far
#2% the name of current  switch (without »if«)
#3% tail of switches
\gmu@delim
{%
  \gmu@ifempty{#3}%
  {#1\relax}% |\relax| to close the num expression
  {\boolstobin@iter
    {(#1)*2+\csname if#2\endcsname 1\else 0\fi}%
    #3\gmu@delim
  }%
}

\long\def\condstobin
#1% a sequence of conditionals' names without »if« followed by the condition
{%
  \numexpr \condstobin@iter 0 #1 {}{}\gmu@delim %
}

\long\def\condstobin@iter
#1% expression so far
#2% the name of current conditional (without »if«)
#3% the condition for |#2|
#4% tail of switches
\gmu@delim
{%
  \gmu@ifempty{#3}%
  {#1\relax}% |\relax| to close the num expression
  {\condstobin@iter
    {(#1)*2+\csname if#2\endcsname #31\else 0\fi}%
    #4\gmu@delim
  }%
}


\long\def\gmu@ifQUANT@iter
#1% the (binary) value that terminates calculation: 0 for AND and 1
  % for OR (it has to be a single token due to |\expandafter| in line
  % \ref{@xa-in-QUANT})
#2% the (binary) value so far;
#3% the name of current conditional (without »if«)
#4% the condition for |#2|
#5% tail of condition(al)s
\gmu@delim
{%
  \gmu@ifempty{#5}%
  {#2}%
  {% or else we check whether |#2| is terminating
    \gmu@if {num}{#2=#1 }% with a space
    {#1}%
    {\@xa\gmu@ifQUANT@iter \@xa #1% \label{@xa-in-QUANT}
      \the\numexpr %^^V 1 *  % |\numexpr| is used here to get the full
      % expansion in one step. No need of superposing with identity.
      (\gmu@if {#3}{#4 } {1} {0}) +\z@\relax
      #5\gmu@delim
    }%
  }%
}% of |\gmu@ifQUANT@iter|.

\long\def \ifAnyClause
#1{%
   \ifnum
      \gmu@ifQUANT@iter
      1% for the Existential Quantifier 1 terminates calculation (\emph{an(y)}
      % example has just been found)
      0% To make any calculation sense we assume 0 at the beginning
      % (i.e., “we haven't found an example yet”)
      #1
      {false}{} {false} {}% the sentinel(s)
      \gmu@delim % the delimiter
      =\@ne % right side of |\Ѻifnum|
}

\long\def\gmu@OR
#1% as  above\\
{%
   \ifAnyClause {#1}%
      \@xa\@firstoftwo
   \else
      \@xa\@secondoftwo
   \fi
}

\long\def\ifAllClauses
#1% a sequence of pairs \arg{conditionals' name without »if«}{the
{%
  \ifnum
     \gmu@ifQUANT@iter
     0% for the General Quantifier 0 terminates calculation (when a
     % counter-example has just been found)
     1% To make any calculation sense we assume 1 at the beginning
     #1
     {true}{} {true} {}% the sentinel(s)
     \gmu@delim % the delimiter
     =\@ne % right side of |\Ѻifnum|
}

\long\def\gmu@AND
#1%
{%
   \ifAllClauses {#1}%
      \@xa\@firstoftwo
   \else
      \@xa\@secondoftwo
   \fi
}

\long\def\sName    #1#2    {\@xa#1\csname #2\endcsname}

\long\def\sdName    #1#2    {\@xa#1\csname \detokenize{#2}\endcsname}

\long\def\dName #1#2{\@xa #1\csname \detokenize{#2}\endcsname}

\long\def\@sN    #1    {\csname #1\endcsname}
\long\def\@sdN    #1    {\csname \detokenize{#1}\endcsname}


\pdef\clap #1{\hbox to \z@{\hss #1\hss}}

\pdef\hsizecline #1{\hbox to\hsize{\hss #1\hss}}

\long\def\gmu@extreme
#1% kind of test (|num| or |dim|)
#2% inequality sign: |<| for minimum, |>| for maximum.
#3% left side of comparison
#4%  right side of comparison
{%
  \gmu@if {x\@xa\@xa}{\@firstofmany#4\@nil\relax} % this complicated test is to
  % allow arguments beginning with some \incs{if⁄<…>} as in
  % \incs{possvfil} e.g.
  {#3}%
  {%
    \gmu@if {#1} {\csname #1expr\endcsname#3\relax
      #2\csname #1expr\endcsname #4\relax }
    {\gmu@extreme {#1}#2{#3}}%
    {\gmu@extreme {#1}#2{#4}}%
  }%
}% of |\gmu@extreme|

\def\gmu@maxnum{\gmu@extreme {num}>}
\def\gmu@minnum{\gmu@extreme {num}<}

\def\gmu@maxdim{\gmu@extreme {dim}>}
\def\gmu@mindim{\gmu@extreme {dim}<}

\pdef\gmu@fitto
#1% scope (nothing, |\relax| or |\global|.
#2% left side of the assignment (must be a dimen able to be ”passive”)
#3% the comparison (if |#2#3#4| then reassign |#2|)
#4% right side of the assignment---any correct text for |\dimexpr|.
{%
  \gmu@if {dim}{#2#3\dimexpr (#4)+\z@\relax\relax}%
  {#1#2=\dimexpr (#4)+\z@\relax}%
  {}%
}

\pdef\gmu@g@enlargeto
#1% |#2| of the above
#2% |#4| of the above
{\gmu@fitto\global{#1}<{#2}}

\pdef\discre#1#2#3{\leavevmode\kern\z@
  \discretionary{#1}{#2}{#3}\penalty\@M\hskip\z@skip}

\pdef\discret#1{\discre{#1}{#1}{#1}}

\pdef\gmu@flexhyphen{%
  \discre{% before break
    \ifnum\hyphenchar\font>\z@
      \char\hyphenchar\font
    \fi
  }% end of before break
  {}%after break
  {}% without break
}

\def\:{%
  \ifmmode\afterfi{\mskip\medmuskip}%
  \else\afterfi{\discre{\null}{}{}}% \incs{null} to get
  % \incs{hyphenpenalty} not \incs{exhyphenpenalty}.
  \fi
}

\lpdef\hboxreflected#1{%
  \hbox{%
    \reflectbox{#1}%
  }%
}

\pdef\gmu@ifSystemX{% the ‘If file exists” test is \emph{NOT}
                    % expandable since it involves opening some
                    % streams. Therefore we define this macro as protected.
  \IfFileExists{/etc/passwd}%
}

\def\hrule@zero{\hrule height\z@ width\z@ depth\z@}
\def\vrule@zero{\vrule height\z@ width\z@ depth\z@}

\def\do#1#2{% (2010/10/11)
  \Name  \def{gmu@iflast#1}{%
    \ifnum #2=\lastnodetype
      \@xa\@firstoftwo
    \else
      \@xa\@secondoftwo
    \fi
  }%
}

\do {glue}{11}    \do{skip}{11}
\do{kern}{12}
\do {penalty}{13}

\def\gmu@dimratio
#1% numerator dim(en/expr)
#2% denominator dim(en/expr)
{\strip@pt
  \dimexpr  1pt *
  \numexpr\dimexpr (#1)*1\relax\relax /
  \numexpr \dimexpr (#2)*1\relax \relax
  \relax
}

\def\MakeFalseIfDefined #1{%
  \ifcsname if#1\endcsname
    \csn{#1false}%
  \fi
}

\def\MakeTrueIfDefined #1{%
  \ifcsname if#1\endcsname
    \csn{#1true}%
  \fi
}

\def\gmu@pageremain{\dimexpr
  \ifdim\pagegoal=\maxdimen \textheight \else \pagegoal \fi
  -\pagetotal
  \relax
}

\def\gmu@GobbleMinus #1{\if-#1\else#1\fi}

\def\gmu@absExpr
#1% \eTeX's expression primitive, num or dim so far (2010/12/17, 11.46)
#2% expression of respective kind
{%
  \@xa\gmu@GobbleMinus\the #1#2\endexpr
}

\def\gmu@absdim {\gmu@absExpr \dimexpr }
\def\gmu@absnum {\gmu@absExpr \numexpr }

\pdef\gmu@SetPagegoal #1{%
  \gmu@if {dim} {\pagegoal=\maxdimen}%
  {}% in this case we do nothing, as explained above
  {\pagegoal = \dimexpr (#1)\relax}%
}

\pdef\gmu@SetPagegoalGlobal #1{%
  \gmu@if {dim} {\pagegoal=\maxdimen}%
  {}% in this case we do nothing, as explained above
  {\global\pagegoal = \dimexpr (#1)\relax}%
}

\pdef\gmu@AdvancePagegoal #1{% the arg.\ should be a proper stuff for
  % a sub-dimexpr (i.a., no spurious |\relax|es are allowed).
  \gmu@SetPagegoal {\pagegoal +#1}%
}

\def\pagegoalortextheight{% as in the name:
  \dimexpr
    \ifdim \pagegoal=\maxdimen
      \textheight
    \else \pagegoal
    \fi
  \relax
}

\def\gmu@totalht #1{% the arg.\ should be a~box register.
  \dimexpr \ht #1+\dp#1\relax
}

\def\vbadness@M {%
   \unless\ifnum\vbadness=\@M
      \edef\gmu@VeryBadBadness {\the\vbadness }%
      \vbadness\@M
   \fi
}

\def\vbadness@Restore {%
   \ifdefined \gmu@VeryBadBadness
      \vbadness \gmu@VeryBadBadness \relax
   \else
      \PackageError{gmbase}{You try to gm-restore \vbadness\space where
         it is not gm-stored}{}%
   \fi
}

\relaxen\endexpr

\relaxen\endrule

\def\gmu@ifpageodd {%
  \ifodd \c@page
    \@xa\@firstoftwo
  \else
    \@xa\@secondoftwo
  \fi
}


\gmu@DefSymbol\gmu@Fake

\def\gmu@FakeLoaded
#1% extension
#2% name
{\ifcsname  ver@#2.#1\endcsname
    \@xa\ifx\csname ver@#2.#1\endcsname \relax
      \@xa\@xa\@xa \@firstofone
    \else
       \@xa\@xa\@xa \@gobble
    \fi
  \else
    \@xa\@firstofone
  \fi
  {\Name\def {ver@#2.#1}{\gmu@Fake }}%
}

\def\gmu@FakeUnloaded
#1% extension
#2% name
{\ifcsname  ver@#2.#1\endcsname
    \@xa\ifx\csname ver@#2.#1\endcsname\gmu@Fake
      \Name\let {ver@#2.#1}\@undefined
    \fi
  \fi
}

\pdef\LoadPackagePolski {%
  \gmu@FakeLoaded \@pkgextension {inputenc}%
  \RequirePackage {polski}%
  \gmu@FakeUnloaded \@pkgextension {inputenc}%
}

\def\hrule@zero{\hrule height\z@ width\z@ depth\z@}


\pdef \protected@nil {}
\let\protected@empty\protected@nil

\ifgmuXeTeX

  % 2011/02/03, 12.53 definitions of the macros for combinig

  \def\gmu@nobound
  #1% a~char
  #2% bound number
  {%
    \gmu@unless {}
    {0%
      \gmu@if {num}{#2=\@ne }{0}{}%
      \gmu@if {num}{#2=13 }   {0}{}%
      1}
    {}
    {%
      \leavevmode
      \kern -\glyphbound #1 1%
    }%
    #1%
    \gmu@unless {}
    {0%
      \gmu@if {num}{#2=\thr@@ }{0}{}%
      \gmu@if {num}{#2=13 }{0}{}%
      1}
    {}
    {%
      \kern -\glyphbound #1 3%
    }%
  }

  \def\glyphbound
  #1% char (name)
  #2% number of the bound
  {%
    \XeTeXglyphbounds #2 \XeTeXglyphindex "#1"
  }

  \def\gmu@halfcomb
  #1% the “basic” char
  #2% the accent char
  #3% emergency [\pk{fontspec}] font spec
  {%
    #1\kern-\gmu@halfwd #1%
    \clap{%
      \gmu@unless {fontchar}{\font `#2 }
      {#3}{}%
      #2}%
    \kern\gmu@halfwd #1%
  }

  \def\gmu@halfwd#1{0,45\fontcharwd\font`#1 }

  \def\gmu@llapcomb
  #1% the “basic” char
  #2% the accent char
  #3% emergency [\pk{fontspec}] font spec
  {%
    \gmu@nobound #13%
    \llap{%
      \gmu@unless {fontchar}{\font `#2 }
      {#3}{}%
      #2}%
    \kern \XeTeXglyphbounds 3 \XeTeXglyphindex "#1"
  }

\fi % of if \XeTeX

\pdef\@rmfromreset
#1% counter to be freed, e.g., |figure|,
#2% counter from whose power we free |#1|, e.g., |chapter|.
{%
  {%
    \def\@elt ##1{%
      \gmu@ifdetokens{#1}{##1}%
      {}% then we remove the element, otherwise
      {\@nx\@elt {##1}}%
    }%
    %
    \Name\xdef{cl@#2}{\csname cl@#2\endcsname}%
  }%
}


\long\def \gmu@iflist {%
  % |#1| (implicit) what if in a list environment
  % |#2| (implicit) what if not in a list env.
  \ifnum \@listdepth>\z@
    \@xa\@firstoftwo
  \else
    \@xa\@secondoftwo
  \fi
}

\foone {\@makeother \^^I }{%
  \def\xiitab{^^I}%
}

\foone {\catcode 9=\active } {%
  % Totally perverse, but seems to be useful with DocStrip.
  \def\gmu@maketabtab {%
    \def ^^I{\xiitab}%
  }%
}


\endinput
%%
%% End of file `gmbase.sty'.
