%%
%% This is file `phfqit.sty',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% phfqit.dtx  (with options: `package')
%% 
%% This is a generated file.
%% 
%% Copyright (C) 2016 by Philippe Faist <philippe.faist@bluewin.ch>
%% 
%% This file may be distributed and/or modified under the conditions of
%% the LaTeX Project Public License, either version 1.3 of this license
%% or (at your option) any later version.  The latest version of this
%% license is in:
%% 
%%    http://www.latex-project.org/lppl.txt
%% 
%% and version 1.3 or later is part of all distributions of LaTeX version
%% 2005/12/01 or later.
%% 
\NeedsTeXFormat{LaTeX2e}[2005/12/01]
\ProvidesPackage{phfqit}
    [2016/08/15 v1.0 phfqit package]
\RequirePackage{calc}
\RequirePackage{etoolbox}
\RequirePackage{amsmath}
\RequirePackage{dsfont}
\RequirePackage{mathrsfs}
\RequirePackage{mathtools}
\newcommand{\Hs}{\mathscr{H}}
\newcommand{\Ident}{\mathds{1}}
\def\IdentProc{%
  \phfqit@parsesizearg\phfqit@IdentProc@maybeA%
}
\newcommand\phfqit@IdentProc@maybeA[1][]{%
  \def\phfqit@IdentProc@val@A{#1}%
  \phfqit@IdentProc@maybeB%
}
\newcommand\phfqit@IdentProc@maybeB[1][]{%
  \def\phfqit@IdentProc@val@B{#1}%
  \phfqit@IdentProc@arg%
}
\def\phfqit@IdentProc@arg#1{%
  \def\phfqit@IdentProc@val@arg{#1}%
  \edef\@tmp@args{%
    {\expandonce{\phfqit@IdentProc@val@A}}%
    {\expandonce{\phfqit@IdentProc@val@B}}%
    {\expandonce{\phfqit@IdentProc@val@arg}}%
  }%
  \expandafter\phfqit@IdentProc@do\@tmp@args%
}
\def\phfqit@IdentProc@do#1#2#3{%
  \operatorname{id}_{#1\notblank{#2}{\to #2}{}}%
  \notblank{#3}{\expandafter\phfqit@inner@parens\phfqit@val@sizearg{#3}}{}%
}
\def\ee^#1{e^{#1}} % we could imagine that in inlines, we replace this by exp()...
\DeclareMathOperator{\tr}{tr}
\DeclareMathOperator{\supp}{supp}
\DeclareMathOperator{\rank}{rank}
\DeclareMathOperator{\linspan}{span}
\DeclareMathOperator{\spec}{spec}
\DeclareMathOperator{\diag}{diag}
\let\phfqit@Re\Re
\DeclareMathOperator{\phfqit@Realpart}{Re}%
\renewcommand{\Re}{\phfqit@Realpart}
\let\phfqit@Im\Im
\DeclareMathOperator{\phfqit@Imagpart}{Im}%
\renewcommand{\Im}{\phfqit@Imagpart}
\DeclareMathOperator{\poly}{poly}
\newcommand\bit[1]{\texttt{#1}}
\newcommand\bitstring[1]{\phfqit@bitstring{#1}}
\def\phfqit@bitstring#1{%
  \begingroup%
  \setlength{\phfqit@len@bit}{\maxof{\widthof{\bit{0}}}{\widthof{\bit{1}}}}%
  \phfqitBitstringFormat{\phfqit@bitstring@#1\phfqit@END}%
  \endgroup%
}
\def\phfqit@bitstring@#1#2\phfqit@END{%
  \makebox[\phfqit@len@bit][c]{\phfqitBitstringFormatBit{#1}}%
  \if\relax\detokenize\expandafter{#2}\relax%
  \else%
    \phfqitBitstringSep\phfqit@bitstring@#2\phfqit@END%
  \fi%
}
\newlength\phfqit@len@bit
\newcommand\phfqitBitstringSep{\hspace{0.3ex}}
\newcommand\phfqitBitstringFormat[1]{\ensuremath{\underline{\overline{#1}}}}
\def\phfqitBitstringFormatBit{\bit}
\DeclareRobustCommand\gate[1]{\ifmmode\textsc{\lowercase{#1}}%
  \else{\rmfamily\textsc{\lowercase{#1}}}\fi}
\newcommand{\AND}{\gate{And}}
\newcommand{\XOR}{\gate{Xor}}
\newcommand{\CNOT}{\gate{C-Not}}
\newcommand{\NOT}{\gate{Not}}
\newcommand{\NOOP}{\gate{No-Op}}
\def\uu(#1){\phfqit@fmtLieAlgebra{u}(#1)}
\def\UU(#1){\phfqit@fmtGroup{U}(#1)}
\def\su(#1){\phfqit@fmtLieAlgebra{su}(#1)}
\def\SU(#1){\phfqit@fmtGroup{SU}(#1)}
\def\so(#1){\phfqit@fmtLieAlgebra{so}(#1)}
\def\SO(#1){\phfqit@fmtGroup{SO}(#1)}
\def\SN(#1){\mathrm{S}_{#1}}
\def\phfqit@fmtLieAlgebra#1{\mathrm{#1}}
\def\phfqit@fmtGroup#1{\mathrm{#1}}
\DeclarePairedDelimiterX\ket[1]{\lvert}{\rangle}{{#1}}
\DeclarePairedDelimiterX\bra[1]{\langle}{\rvert}{{#1}}
\DeclarePairedDelimiterX\braket[2]{\langle}{\rangle}{%
  {#1}\hspace*{0.2ex}\delimsize\vert\hspace*{0.2ex}{#2}%
}
\DeclarePairedDelimiterX\ketbra[2]{\lvert}{\rvert}{%
  {#1}\delimsize\rangle\hspace*{-0.25ex}\delimsize\langle{#2}%
}
\DeclarePairedDelimiterX\proj[1]{\lvert}{\rvert}{%
  {#1}\delimsize\rangle\hspace*{-0.25ex}\delimsize\langle{#1}%
}
\DeclarePairedDelimiterX\matrixel[3]{\langle}{\rangle}{%
  {#1}\hspace*{0.2ex}\delimsize\vert\hspace*{0.2ex}{#2}%
  \hspace*{0.2ex}\delimsize\vert\hspace*{0.2ex}{#3}%
}
\DeclarePairedDelimiterX\dmatrixel[2]{\langle}{\rangle}{%
  {#1}\hspace*{0.2ex}\delimsize\vert\hspace*{0.2ex}{#2}%
  \hspace*{0.2ex}\delimsize\vert\hspace*{0.2ex}{#1}%
}
\DeclarePairedDelimiterX\innerprod[2]{\langle}{\rangle}{%
  {#1},\hspace*{0.2ex}{#2}%
}
\DeclarePairedDelimiterX\abs[1]{\lvert}{\rvert}{{#1}}
\DeclarePairedDelimiterX\avg[1]{\langle}{\rangle}{{#1}}
\DeclarePairedDelimiterX\norm[1]{\lVert}{\rVert}{{#1}}
\def\phfqit@insideinterval#1#2{{#1\mathclose{},\mathopen{}#2}}
\DeclarePairedDelimiterX\intervalc[2]{[}{]}{\phfqit@insideinterval{#1}{#2}}
\DeclarePairedDelimiterX\intervalo[2]{]}{[}{\phfqit@insideinterval{#1}{#2}}
\DeclarePairedDelimiterX\intervalco[2]{[}{[}{\phfqit@insideinterval{#1}{#2}}
\DeclarePairedDelimiterX\intervaloc[2]{]}{]}{\phfqit@insideinterval{#1}{#2}}
\def\phfqit@parsesizearg#1{%
  \begingroup%
  \mathcode`\`="0060\relax%
  \gdef\phfqit@val@sizearg{}%
  \@ifnextchar`{\phfqit@parsesizearg@withsize{#1}}{\endgroup#1}%
}
\def\phfqit@parsesizearg@withsize#1`#2{%
  \def\@tmp@arg{#2}%
  \def\@tmp@star{*}%
  \def\@tmp@endgroupandcontinue{\endgroup#1}%
  \ifx\@tmp@arg\@tmp@star\relax%
    \gdef\phfqit@val@sizearg{*}%
    \expandafter\@tmp@endgroupandcontinue%
  \else%
    \gdef\phfqit@val@sizearg{[#2]}%
    \expandafter\@tmp@endgroupandcontinue%
  \fi%
}
\DeclarePairedDelimiterX\phfqit@inner@parens[1]{(}{)}{#1}
\newcommand\HHSym{H}
\def\@HHbase#1#2{%
  #1_{#2}%
  \@HHbase@parsesize%
}
\robustify\@HHbase
\def\@HHbase@parsesize{%
  \begingroup\mathcode`\`="0060\relax%
  \gdef\HH@tmp@sizearg{}%
  \@ifnextchar`\@HHbase@withsize\@HHbase@endgroupandparseinner%
}
\def\@HHbase@withsize`#1{%
  \def\@tmp@arg{#1}%
  \def\@tmp@star{*}%
  \ifx\@tmp@arg\@tmp@star\relax%
    \gdef\HH@tmp@sizearg{*}%
    \expandafter\@HHbase@endgroupandparseinner%
  \else%
    \gdef\HH@tmp@sizearg{[#1]}%
    \expandafter\@HHbase@endgroupandparseinner%
  \fi%
}
\def\@HHbase@endgroupandparseinner{\endgroup\@HHbase@parseinner}
\newcommand\@HHbase@parseinner[1][]{%  arg: state
  \def\HH@tmpstore@state{#1}%
  \@HHbase@parseinner@%
}
\newcommand\@HHbase@parseinner@[2][]{% arg: epsilon and target system
  \def\HH@tmpstore@epsilon{#1}%
  \def\HH@tmpstore@system{#2}%
  \@HHbase@parseinner@@%
}
\newcommand\@HHbase@parseinner@@[1][]{% arg: conditioning system
  \def\HH@tmpstore@condsys{#1}%
  \@HHbase@do@inner%
}
\newtoks\HH@tmp@toks
\def\HH@addtoks#1\@HH@END@ADD@TOKS{\HH@tmp@toks=\expandafter{\the\HH@tmp@toks#1}}%
\def\@HHbase@do@inner{%
  ^{\HH@tmpstore@epsilon}%
  \expandafter\notblank\expandafter{\HH@tmpstore@system}{%
    \HH@tmp@toks={}%
    \expandafter\HH@addtoks\HH@tmpstore@system\@HH@END@ADD@TOKS%
    \expandafter\notblank\expandafter{\HH@tmpstore@condsys}{%
      \HH@addtoks\mathclose{}\,\delimsize\vert\,\mathopen{}\@HH@END@ADD@TOKS%
      \expandafter\HH@addtoks\HH@tmpstore@condsys\@HH@END@ADD@TOKS%
    }{}%
    \edef\tmp@args{\expandonce{\HH@tmp@sizearg}{\the\HH@tmp@toks}}%
    \expandafter\phfqit@inner@parens\tmp@args%
    _{\HH@tmpstore@state}%
    %
  }{}%
  %
}
\newcommand\HH{\@HHbase{\HHSym}{}}
\newcommand\Hzero{\@HHbase{\HHSym}{\mathrm{max},0}}
\newcommand\Hmin{\@HHbase{\HHSym}{\mathrm{min}}}
\newcommand\Hmaxf{\@HHbase{\HHSym}{\mathrm{max}}}
\DeclareRobustCommand\Hfunc{%
  \begingroup\mathcode`\`="0060\relax%
  \gdef\Hfunc@tmp@sizearg{}%
  \@ifnextchar`\Hfunc@withsize\Hfunc@next%
}
\def\Hfunc@withsize`#1{%
  \def\@tmp@arg{#1}%
  \def\@tmp@star{*}%
  \ifx\@tmp@arg\@tmp@star\relax%
    \gdef\Hfunc@tmp@sizearg{*}%
    \endgroup%
    \expandafter\Hfunc@inner%
  \else%
    \gdef\Hfunc@tmp@sizearg{[#1]}%
    \endgroup%
    \expandafter\Hfunc@inner%
  \fi%
}
\def\Hfunc@next{\endgroup\Hfunc@inner}
\def\Hfunc@inner(#1){%
  \HHSym%  ({#1})%
  \expandafter\phfqit@inner@parens\Hfunc@tmp@sizearg{#1}%
}
\newcommand\DDSym{D}
\DeclarePairedDelimiterX\@DDbase@inner[2]{(}{)}{%
  #1\mathclose{}\,\delimsize\Vert\,\mathopen{}#2%
}
\def\@DDbase#1#2#3{%
  #1_{#2}^{#3}%
  \@DDbase@parsesize%
}
\robustify\@DDbase
\def\@DDbase@parsesize{%
  \@ifnextchar`\@DDbase@withsize\@DDbase@inner%
}
\def\@DDbase@withsize`#1{%
  \def\@tmp@arg{#1}%
  \def\@tmp@star{*}%
  \ifx\@tmp@arg\@tmp@star\relax%
    \def\tmp@cmd{\@DDbase@inner*}%
    \expandafter\tmp@cmd%
  \else%
    \def\tmp@cmd{\@DDbase@inner[#1]}%
    \expandafter\tmp@cmd%
  \fi%
}
\DeclareRobustCommand\DD{%
  \def\DD@tmp@sub{}%
  \def\DD@tmp@sup{}%
  \DD@%
}
\def\DD@{%
  \@ifnextchar_\DD@parsesub\DD@@%
}
\def\DD@@{%
  \@ifnextchar^\DD@parsesup\DD@@@%
}
\def\DD@@@{% sub/super-scripts have been parsed, move on to rest of command
  \@DDbase{\DDSym}{\DD@tmp@sub}{\DD@tmp@sup}%
}
\def\DD@parsesub_#1{%
  \def\DD@tmp@sub{#1}%
  \DD@% continue parsing maybe another sub or superscript
}
\def\DD@parsesup^#1{%
  \def\DD@tmp@sup{#1}%
  \DD@% continue parsing maybe another sub or superscript
}
\DeclareRobustCommand\Dminz[1][]{%
  \@DDbase{\DDSym}{\mathrm{min,0}}{#1}%
}

\DeclareRobustCommand\Dminf[1][]{%
  \@DDbase{\DDSym}{\mathrm{min}}{#1}%
}
\DeclareRobustCommand\Dmax[1][]{%
  \@DDbase{\DDSym}{\mathrm{max}}{#1}%
}
\DeclareRobustCommand\Dr[1][]{%
  \@DDbase{\DDSym}{\mathrm{r}}{#1}%
}
\DeclareRobustCommand\DHyp[1][\eta]{%
  \@DDbase{\DDSym}{\mathrm{H}}{#1}%
}
\DeclarePairedDelimiterX\DC@inner[3]{(}{)}{%
  #1\mathclose{}\,\delimsize\Vert\,\mathopen{}#2\mathclose{},\mathopen{}#3%
}
\newcommand\DCSym{\bar\DDSym}
\def\emptysystem{\ensuremath{\emptyset}}
\newcommand\DCoh[1][]{%
  \def\DC@tmp@sup{#1}%
  %\message{*********|\detokenize{#1}|*********}%
  \begingroup\mathcode`\`="0060\relax
  \DC@parsesize%
}
\def\DC@parsesize#1{%
  \gdef\DC@tmp@sizeargs{}%
  \ifstrequal{#1}{`}\DC@withsize{\endgroup\DC@rest{#1}}%
}
\def\DC@withsize#1{%
  %\message{*********\detokenize{#1}********}%
  \def\@tmp@arg{#1}%
  \def\@tmp@star{*}%
  \ifx\@tmp@arg\@tmp@star\relax%
    \gdef\DC@tmp@sizeargs{*}%
    \endgroup%
    \expandafter\DC@rest%
  \else%
    \gdef\DC@tmp@sizeargs{[#1]}%
    \endgroup%
    \expandafter\DC@rest%
  \fi%
}
\def\DC@rest#1#2#3#4#5{%
  %\message{*********\detokenize{#1}|\detokenize{#2}|\detokenize{#3}%
  %    |\detokenize{#4}|\detokenize{#5}|********}%
  \def\DC@tmp@rho{\DC@fmtrhosub#1\DC@ENDSTATE{#2}{#3}}%
  \DCSym_{#2\to #3}^{\DC@tmp@sup}%
  \expandafter\DC@inner\DC@tmp@sizeargs{\DC@tmp@rho}{#4}{#5}%
}
\def\DC@fmtrhosub{%
  \@ifnextchar*\DC@fmtrhosub@nosub\DC@fmtrhosub@wsub%
}
\def\DC@fmtrhosub@nosub*#1\DC@ENDSTATE#2#3{%
  #1%
}
\def\DC@fmtrhosub@wsub#1\DC@ENDSTATE#2#3{%
  \begingroup%
    \let\emptysystem\relax%
    #1_{#3#2}%
  \endgroup%
}
\endinput
%%
%% End of file `phfqit.sty'.
