%%
%% This is file `paresse.sty',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% paresse.dtx  (with options: `package,MAIN')
%% 
%% Do not distribute this file without also distributing the
%% source files specified above.
%% 
%% Do not distribute a modified version of this file.
%% 
%% File: paresse.dtx
%% Copyright (C) 2020 Yvon Henel aka Le TeXnicien de surface
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
\RequirePackage{expl3}[2020/09/24]
\GetIdInfo$Id: paresse.dtx 5.0.1 2020-10-06 TdS $
  {}
\ProvidesExplPackage
  {\ExplFileName}{\ExplFileDate}{\ExplFileVersion}{\ExplFileDescription}
\RequirePackage{xparse}
\RequirePackage{l3keys2e}
\RequirePackage{iftex}
\keys_define:nn {paresse}
{
  encoding_is_legacy .bool_set:N = \g__paresse_encoding_is_legacy_bool,
  encoding_is_levi .bool_set_inverse:N =
    \g__paresse_encoding_is_legacy_bool,
  legacy .meta:n = {
    encoding_is_legacy = #1
  },
  legacy .default:n = {true},
  legacy .initial:n = {true},
  levi .meta:n = {
    encoding_is_levi = #1
  },
  levi .default:n = {true},
  levi .initial:n = {false},

  mood_is_wild .bool_set:N = \g__paresse_mood_is_wild_bool,
  mood_is_tame .bool_set_inverse:N =
    \g__paresse_mood_is_wild_bool,
  wild .meta:n = {
    mood_is_wild = #1
  },
  wild .default:n = {true},
  wild .initial:n = {true},
  tame .meta:n = {
    mood_is_tame = #1
  },
  tame .default:n = {true},
  tame .initial:n = {false},

  letter_t_is_theta .bool_set:N = \g__paresse_letter_t_is_theta_bool,
  letter_t_is_tau .bool_set_inverse:N =
    \g__paresse_letter_t_is_theta_bool,
  ttheta .meta:n = {
    letter_t_is_theta = #1
  },
  ttheta .default:n = {true},
  ttheta .initial:n = {true},
  ttau .meta:n = {
    letter_t_is_tau = #1
  },
  ttau .default:n = {true},
  ttau .initial:n = {false},

  letter_theta_is_theta .bool_set:N = \g__paresse_letter_theta_is_theta_bool,
  letter_theta_is_vartheta .bool_set_inverse:N =
    \g__paresse_letter_theta_is_theta_bool,
  theta .meta:n = {
    letter_theta_is_theta = #1
  },
  theta .default:n = {true},
  theta .initial:n = {true},
  vartheta .meta:n = {
    letter_theta_is_vartheta = #1
  },
  vartheta .default:n = {true},
  vartheta .initial:n = {false},

  letter_pi_is_pi .bool_set:N = \g__paresse_letter_pi_is_pi_bool,
  letter_pi_is_varpi .bool_set_inverse:N =
    \g__paresse_letter_pi_is_pi_bool,
  pi .meta:n = {
    letter_pi_is_pi = #1
  },
  pi .default:n = {true},
  pi .initial:n = {true},
  varpi .meta:n = {
    letter_pi_is_varpi = #1
  },
  varpi .default:n = {true},
  varpi .initial:n = {false},

  letter_rho_is_rho .bool_set:N = \g__paresse_letter_rho_is_rho_bool,
  letter_rho_is_varrho .bool_set_inverse:N =
    \g__paresse_letter_rho_is_rho_bool,
  rho .meta:n = {
    letter_rho_is_rho = #1
  },
  rho .default:n = {true},
  rho .initial:n = {true},
  varrho .meta:n = {
    letter_rho_is_varrho = #1
  },
  varrho .default:n = {true},
  varrho .initial:n = {false},

  letter_sigma_is_sigma .bool_set:N = \g__paresse_letter_sigma_is_sigma_bool,
  letter_sigma_is_varsigma .bool_set_inverse:N =
    \g__paresse_letter_sigma_is_sigma_bool,
  sigma .meta:n = {
    letter_sigma_is_sigma = #1
  },
  sigma .default:n = {true},
  sigma .initial:n = {true},
  varsigma .meta:n = {
    letter_sigma_is_varsigma = #1
  },
  varsigma .default:n = {true},
  varsigma .initial:n = {false},

  letter_epsilon_is_epsilon .bool_set:N =
    \g__paresse_letter_epsilon_is_epsilon_bool,
  letter_epsilon_is_varepsilon .bool_set_inverse:N =
    \g__paresse_letter_epsilon_is_epsilon_bool,
  epsilon .meta:n = {
    letter_epsilon_is_epsilon = #1
  },
  epsilon .default:n = {true},
  epsilon .initial:n = {false},
  varepsilon .meta:n = {
    letter_epsilon_is_varepsilon = #1
  },
  varepsilon .default:n = {true},
  varepsilon .initial:n = {true},

  letter_phi_is_phi .bool_set:N = \g__paresse_letter_phi_is_phi_bool,
  letter_phi_is_varphi .bool_set_inverse:N =
    \g__paresse_letter_phi_is_phi_bool,
  phi .meta:n = {
    letter_phi_is_phi = #1
  },
  phi .default:n = {true},
  phi .initial:n = {false},
  varphi .meta:n = {
    letter_phi_is_varphi = #1
  },
  varphi .default:n = {true},
  varphi .initial:n = {true},
}
\ProcessKeysOptions {paresse}
\bool_if:nTF {\g__paresse_letter_epsilon_is_epsilon_bool}
{\cs_new:Npn \__paresse_epsilon {\epsilon}}
{\cs_new:Npn \__paresse_epsilon {\varepsilon}}

\bool_if:nTF {\g__paresse_letter_theta_is_theta_bool}
{\cs_new:Npn \__paresse_theta {\theta}}
{\cs_new:Npn \__paresse_theta {\vartheta}}

\bool_if:nTF {\g__paresse_letter_pi_is_pi_bool}
{\cs_new:Npn \__paresse_pi {\pi}}
{\cs_new:Npn \__paresse_pi {\varpi}}

\bool_if:nTF {\g__paresse_letter_rho_is_rho_bool}
{\cs_new:Npn \__paresse_rho {\rho}}
{\cs_new:Npn \__paresse_rho {\varrho}}

\bool_if:nTF {\g__paresse_letter_sigma_is_sigma_bool}
{\cs_new:Npn \__paresse_sigma {\sigma}}
{\cs_new:Npn \__paresse_sigma {\varsigma}}

\bool_if:nTF {\g__paresse_letter_phi_is_phi_bool}
{\cs_new:Npn \__paresse_phi {\phi}}
{\cs_new:Npn \__paresse_phi {\varphi}}

\bool_new:c {g__paresse_file_encoding_is_utf8_bool}
\cs_new:Nn \__paresse_main_package_loaded: {}
\ifluatex
\PackageInfo{paresse}{compiling~with~luatex}
\RequirePackageWithOptions{paresse-old}
\else
\ifxetex
\PackageInfo{paresse}{compiling~with~xetex}
\RequirePackageWithOptions{paresse-old}
\else

\PackageInfo{paresse}{compiling~with~tex}

\newcommand\default@encoding@message{
  \bool_gset_true:c {g__paresse_file_encoding_is_utf8_bool}
  \PackageWarningNoLine{paresse}{
    The~package~"paresse"~expects~a~"utf8"~encoded~file.~
    In~case~of~an~8~bits~encoding,~
    please~use~inputenc~with~the~correct~option}
}

\newcommand\find@encoding{
  \begingroup
  \def\utf@encoding{utf8}
  \def\temp@a{
    \bool_gset_false:c {g__paresse_file_encoding_is_utf8_bool}
    \PackageInfo{paresse}{8-bit~encoding~expected\@gobble}
  }
  \ifx\utf@encoding\inputencodingname
  \def\temp@a{
    \bool_gset_true:c {g__paresse_file_encoding_is_utf8_bool}
    \PackageInfo{paresse}{utf8~encoding~detected\@gobble}
  }
  \fi
  \expandafter\endgroup\temp@a}

\@ifpackageloaded{inputenc}
{
  \PackageInfo{paresse}{inputenc~loaded}
}
{
  \PackageInfo{paresse}{inputenc~not~loaded,~utf8~expected\@gobble}
}

\AtBeginDocument
{
  \@ifpackageloaded{inputenc} \find@encoding \default@encoding@message
  \ExplSyntaxOn
  \makeatletter
  \bool_if:nTF {\use:c{g__paresse_file_encoding_is_utf8_bool}}
  {
    \PackageInfo{paresse}{charge~utf8}
    \RequirePackageWithOptions{paresse-utf8}
  }
  {
    \PackageInfo{paresse}{charge~vieux}
    \RequirePackageWithOptions{paresse-old}
  }
  \makeatother
  \ExplSyntaxOff
}

\fi % END OF ifxetex
\fi % END OF ifluatex
\endinput
%%
%% End of file `paresse.sty'.
