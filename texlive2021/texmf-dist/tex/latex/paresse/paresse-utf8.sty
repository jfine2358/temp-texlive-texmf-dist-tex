%%
%% This is file `paresse-utf8.sty',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% paresse.dtx  (with options: `package,UTF')
%% 
%% Do not distribute this file without also distributing the
%% source files specified above.
%% 
%% Do not distribute a modified version of this file.
%% 
%% File: paresse.dtx
%% Copyright (C) 2020 Yvon Henel aka Le TeXnicien de surface
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
\RequirePackage{expl3}[2020/09/24]
\GetIdInfo$Id: paresse.dtx 5.0.1 2020-10-06 TdS $
  {}
\ProvidesExplPackage
  {\ExplFileName-utf8}{\ExplFileDate}{\ExplFileVersion}{\ExplFileDescription}
\RequirePackage{xparse}
\RequirePackage{l3keys2e}
\cs_if_exist:NF \__paresse_main_package_loaded:
{
\keys_define:nn {paresse}
{
  encoding_is_legacy .bool_set:N = \g__paresse_encoding_is_legacy_bool,
  encoding_is_levi .bool_set_inverse:N =
    \g__paresse_encoding_is_legacy_bool,
  legacy .meta:n = {
    encoding_is_legacy = #1
  },
  legacy .default:n = {true},
  legacy .initial:n = {true},
  levi .meta:n = {
    encoding_is_levi = #1
  },
  levi .default:n = {true},
  levi .initial:n = {false},

  mood_is_wild .bool_set:N = \g__paresse_mood_is_wild_bool,
  mood_is_tame .bool_set_inverse:N =
    \g__paresse_mood_is_wild_bool,
  wild .meta:n = {
    mood_is_wild = #1
  },
  wild .default:n = {true},
  wild .initial:n = {true},
  tame .meta:n = {
    mood_is_tame = #1
  },
  tame .default:n = {true},
  tame .initial:n = {false},

  letter_t_is_theta .bool_set:N = \g__paresse_letter_t_is_theta_bool,
  letter_t_is_tau .bool_set_inverse:N =
    \g__paresse_letter_t_is_theta_bool,
  ttheta .meta:n = {
    letter_t_is_theta = #1
  },
  ttheta .default:n = {true},
  ttheta .initial:n = {true},
  ttau .meta:n = {
    letter_t_is_tau = #1
  },
  ttau .default:n = {true},
  ttau .initial:n = {false},

  letter_theta_is_theta .bool_set:N = \g__paresse_letter_theta_is_theta_bool,
  letter_theta_is_vartheta .bool_set_inverse:N =
    \g__paresse_letter_theta_is_theta_bool,
  theta .meta:n = {
    letter_theta_is_theta = #1
  },
  theta .default:n = {true},
  theta .initial:n = {true},
  vartheta .meta:n = {
    letter_theta_is_vartheta = #1
  },
  vartheta .default:n = {true},
  vartheta .initial:n = {false},

  letter_pi_is_pi .bool_set:N = \g__paresse_letter_pi_is_pi_bool,
  letter_pi_is_varpi .bool_set_inverse:N =
    \g__paresse_letter_pi_is_pi_bool,
  pi .meta:n = {
    letter_pi_is_pi = #1
  },
  pi .default:n = {true},
  pi .initial:n = {true},
  varpi .meta:n = {
    letter_pi_is_varpi = #1
  },
  varpi .default:n = {true},
  varpi .initial:n = {false},

  letter_rho_is_rho .bool_set:N = \g__paresse_letter_rho_is_rho_bool,
  letter_rho_is_varrho .bool_set_inverse:N =
    \g__paresse_letter_rho_is_rho_bool,
  rho .meta:n = {
    letter_rho_is_rho = #1
  },
  rho .default:n = {true},
  rho .initial:n = {true},
  varrho .meta:n = {
    letter_rho_is_varrho = #1
  },
  varrho .default:n = {true},
  varrho .initial:n = {false},

  letter_sigma_is_sigma .bool_set:N = \g__paresse_letter_sigma_is_sigma_bool,
  letter_sigma_is_varsigma .bool_set_inverse:N =
    \g__paresse_letter_sigma_is_sigma_bool,
  sigma .meta:n = {
    letter_sigma_is_sigma = #1
  },
  sigma .default:n = {true},
  sigma .initial:n = {true},
  varsigma .meta:n = {
    letter_sigma_is_varsigma = #1
  },
  varsigma .default:n = {true},
  varsigma .initial:n = {false},

  letter_epsilon_is_epsilon .bool_set:N =
    \g__paresse_letter_epsilon_is_epsilon_bool,
  letter_epsilon_is_varepsilon .bool_set_inverse:N =
    \g__paresse_letter_epsilon_is_epsilon_bool,
  epsilon .meta:n = {
    letter_epsilon_is_epsilon = #1
  },
  epsilon .default:n = {true},
  epsilon .initial:n = {false},
  varepsilon .meta:n = {
    letter_epsilon_is_varepsilon = #1
  },
  varepsilon .default:n = {true},
  varepsilon .initial:n = {true},

  letter_phi_is_phi .bool_set:N = \g__paresse_letter_phi_is_phi_bool,
  letter_phi_is_varphi .bool_set_inverse:N =
    \g__paresse_letter_phi_is_phi_bool,
  phi .meta:n = {
    letter_phi_is_phi = #1
  },
  phi .default:n = {true},
  phi .initial:n = {false},
  varphi .meta:n = {
    letter_phi_is_varphi = #1
  },
  varphi .default:n = {true},
  varphi .initial:n = {true},
}
\ProcessKeysOptions {paresse}
\bool_if:nTF {\g__paresse_letter_epsilon_is_epsilon_bool}
{\cs_new:Npn \__paresse_epsilon {\epsilon}}
{\cs_new:Npn \__paresse_epsilon {\varepsilon}}

\bool_if:nTF {\g__paresse_letter_theta_is_theta_bool}
{\cs_new:Npn \__paresse_theta {\theta}}
{\cs_new:Npn \__paresse_theta {\vartheta}}

\bool_if:nTF {\g__paresse_letter_pi_is_pi_bool}
{\cs_new:Npn \__paresse_pi {\pi}}
{\cs_new:Npn \__paresse_pi {\varpi}}

\bool_if:nTF {\g__paresse_letter_rho_is_rho_bool}
{\cs_new:Npn \__paresse_rho {\rho}}
{\cs_new:Npn \__paresse_rho {\varrho}}

\bool_if:nTF {\g__paresse_letter_sigma_is_sigma_bool}
{\cs_new:Npn \__paresse_sigma {\sigma}}
{\cs_new:Npn \__paresse_sigma {\varsigma}}

\bool_if:nTF {\g__paresse_letter_phi_is_phi_bool}
{\cs_new:Npn \__paresse_phi {\phi}}
{\cs_new:Npn \__paresse_phi {\varphi}}

\bool_new:c {g__paresse_file_encoding_is_utf8_bool}
}
\begingroup
\catcode`\"=12
\catcode`\<=12
\catcode`\.=12
\catcode`\,=12
\catcode`\;=12
\catcode`\!=12
\catcode`\~=13
\global\let\GA@parse@UTFviii@a=\parse@UTFviii@a
\global\let\GA@parse@UTFviii@b=\parse@UTFviii@b
\gdef\declareunicodecharacter#1#2{
   \count@"#1\relax
   \wlog{\space\space Redefining~Unicode~char~U+#1~(decimal~\the\count@)}
   \begingroup
    \GA@parse@XML@charref
    \def\UTFviii@two@octets##1##2{\csname u8:##1\string##2\endcsname}
    \def\UTFviii@three@octets##1##2##3{\csname u8:##1
      \string##2\string##3\endcsname}
    \def\UTFviii@four@octets##1##2##3##4{\csname u8:##1
      \string##2\string##3\string##4\endcsname}
    \expandafter\expandafter\expandafter
    \expandafter\expandafter\expandafter
    \expandafter
    \gdef\UTFviii@tmp{\IeC{#2}}
    \endgroup}
\gdef\GA@parse@XML@charref{
  \ifnum\count@<"A0\relax
     \PackageError{inputenc}{Cannot\space define\space Unicode\space
       char\space value\space <\space 00A0}\@eha
  \else\ifnum\count@<"800\relax
     \GA@parse@UTFviii@a,
     \GA@parse@UTFviii@b C\UTFviii@two@octets.,
  \else\ifnum\count@<"10000\relax
     \GA@parse@UTFviii@a;
     \GA@parse@UTFviii@a,
     \GA@parse@UTFviii@b E\UTFviii@three@octets.{,;}
   \else
     \GA@parse@UTFviii@a;
     \GA@parse@UTFviii@a,
     \GA@parse@UTFviii@a!
     \GA@parse@UTFviii@b F\UTFviii@four@octets.{!,;}
    \fi
  \fi
\fi}
\endgroup
\newcommand{\makeparesseletter}{\DeclareUnicodeCharacter{00A7}\S}
\newcommand{\makeparesseother}{
  \PackageWarning{paresse}{
    Command \string\makeparesseother disabled}{
    The command \string\makeparesseother would have been meaningless
    in the current context}}
\newcommand{\ActiveLaParesse}{\declareunicodecharacter{00A7}\@paresse}
\newenvironment{ParesseActive}{\ActiveLaParesse}{}
\ActiveLaParesse
\def\@paresse{\futurelet\@toks\@i@paresse}
\def\@i@paresse{
  \csname\ifcat a\@toks @ii@paresse\else S\fi\endcsname}
\def\@ii@paresse#1{
  \ifcsname @paresse@#1\endcsname
    \csname @paresse@#1\endcsname\expandafter\@gobble
  \else
    \expandafter\@firstofone
  \fi{\S#1}}
\def\define@paresse@car#1#2{
  \expandafter\def\csname @paresse@#1\endcsname{\ensuremath{#2}}}

\define@paresse@car Z\S
\define@paresse@car a\alpha
\define@paresse@car b\beta
\define@paresse@car g\gamma
\define@paresse@car d\delta
\define@paresse@car e\__paresse_epsilon
\define@paresse@car z\zeta
\define@paresse@car h\eta
\define@paresse@car i\iota
\define@paresse@car k\kappa
\define@paresse@car l\lambda
\define@paresse@car m\mu
\define@paresse@car n\nu
\define@paresse@car x\xi
\define@paresse@car p\__paresse_pi
\define@paresse@car r\__paresse_rho
\define@paresse@car s\__paresse_sigma
\define@paresse@car u\upsilon
\define@paresse@car f\__paresse_phi
\define@paresse@car w\omega

\bool_if:nTF {\g__paresse_encoding_is_legacy_bool}
{
  \define@paresse@car j\varsigma
  \define@paresse@car v\__paresse_theta
  \define@paresse@car y\tau
  \define@paresse@car c\chi
  \define@paresse@car q\psi

  \bool_if:nTF {\g__paresse_letter_t_is_theta_bool}
  {
    \define@paresse@car t\__paresse_theta
  }
  {
    \define@paresse@car t\tau
  }
}
{
  \define@paresse@car j\__paresse_theta
  \define@paresse@car t\tau
  \define@paresse@car q\chi
  \define@paresse@car y\psi
  \define@paresse@car c\varsigma
}
\define@paresse@car G\Gamma
\define@paresse@car D\Delta
\define@paresse@car L\Lambda
\define@paresse@car P\Pi
\define@paresse@car S\Sigma
\define@paresse@car U\Upsilon
\define@paresse@car F\Phi
\define@paresse@car X\Xi
\define@paresse@car W\Omega

\bool_if:nTF {\g__paresse_encoding_is_legacy_bool}
{
  \define@paresse@car V\Theta
  \define@paresse@car T\Theta
  \define@paresse@car Q\Psi
}
{
  \define@paresse@car J\Theta
  \define@paresse@car Y\Psi
}

\bool_if:nF {\g__paresse_mood_is_wild_bool}{\makeparesseletter}
\endinput
%%
%% End of file `paresse-utf8.sty'.
