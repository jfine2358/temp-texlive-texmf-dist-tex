%%
%% This is file `tagpdf-mc-code-lua.sty',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% tagpdf-mc.dtx  (with options: `luamode')
%% 
%% Copyright (C) 2019 Ulrike Fischer
%% 
%% It may be distributed and/or modified under the conditions of
%% the LaTeX Project Public License (LPPL), either version 1.3c of
%% this license or (at your option) any later version.  The latest
%% version of this license is in the file:
%% 
%%    https://www.latex-project.org/lppl.txt
%% 
%% This file is part of the "tagpdf bundle" (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%% 
%% File: tagpdf-mc.dtx
\ProvidesExplPackage {tagpdf-mc-code-lua} {2021/02/23} {0.80}
  {tagpdf - mc code only for the luamode }





\hook_gput_code:nnn{begindocument}{tagpdf/mc}
  {
    \bool_if:NT\g__tag_active_mc_bool
      {
        \directlua
          {
            if~luatexbase.callbacktypes.pre_shipout_filter~then~
              luatexbase.add_to_callback("pre_shipout_filter", function(TAGBOX)~
              ltx.__tag.func.mark_shipout(TAGBOX)~return~true~
              end, "tagpdf")~
            end
          }
       \directlua
         {
           if~luatexbase.callbacktypes.pre_shipout_filter~then~
           token.get_next()~
           end
         }\@secondoftwo\@gobble
           {
             \hook_gput_code:nnn{shipout/before}{tagpdf/lua}
               {
                 \directlua
                   { ltx.__tag.func.mark_shipout (tex.box["ShipoutBox"]) }
               }
           }
      }
  }

\prg_new_conditional:Nnn \__tag_mc_if_in: {p,T,F,TF}
  {
    \int_compare:nNnTF { -2147483647 }={ \l__tag_mc_type_attr }
      { \prg_return_false:  }
      { \prg_return_true: }
  }

\prg_new_eq_conditional:NNn \tag_mc_if_in: \__tag_mc_if_in: {p,T,F,TF}

\prg_new_eq_conditional:NNn \uftag_mc_if_in: \__tag_mc_if_in: {p,T,F,TF}

\tl_new:N \l__tag_mc_key_tag_tl
\tl_new:N \l__tag_mc_key_label_tl
\tl_new:N \l__tag_mc_key_properties_tl

\keys_define:nn { __tag / mc }
  {
    tag .code:n = %
      {%%????????? \pdfescapename??
        \tl_set:Nx  \l__tag_mc_key_tag_tl { #1 }
        \directlua
          {
            ltx.__tag.func.store_mc_data(\__tag_get_mc_abs_cnt:,"tag","#1")
          }
      },
    raw .code:n =
      {
        \tl_put_right:Nx \l__tag_mc_key_properties_tl { #1 }
        \directlua
          {
            ltx.__tag.func.store_mc_data(\__tag_get_mc_abs_cnt:,"raw","#1")
          }
      },
    alttext .code:n      = % Alt property
      {
        \str_set_convert:Nnon
          \l__tag_tmpa_str
          { #1 }
          { default }
          { utf16/hex }
        \tl_put_right:Nn \l__tag_mc_key_properties_tl { /Alt~< }
        \tl_put_right:No \l__tag_mc_key_properties_tl { \l__tag_tmpa_str>~ }
        \directlua
          {
            ltx.__tag.func.store_mc_data
              (
                 \__tag_get_mc_abs_cnt:,"alt","/Alt~<\str_use:N \l__tag_tmpa_str>"
              )
          }
      },
    alttext-o .code:n      = % Alt property
      {
        \str_set_convert:Noon
          \l__tag_tmpa_str
          { #1 }
          { default }
          { utf16/hex }
        \tl_put_right:Nn \l__tag_mc_key_properties_tl { /Alt~< }
        \tl_put_right:No \l__tag_mc_key_properties_tl { \l__tag_tmpa_str>~ }
        \directlua
          {
            ltx.__tag.func.store_mc_data
              (
                \__tag_get_mc_abs_cnt:,"alt","/Alt~<\str_use:N \l__tag_tmpa_str>"
              )
          }
      },
    actualtext .code:n      = % Alt property
      {
        \str_set_convert:Nnon
          \l__tag_tmpa_str
          { #1 }
          { default }
          { utf16/hex }
        \tl_put_right:Nn \l__tag_mc_key_properties_tl { /Alt~< }
        \tl_put_right:No \l__tag_mc_key_properties_tl { \l__tag_tmpa_str>~ }
        \directlua
          {
            ltx.__tag.func.store_mc_data
              (
                \__tag_get_mc_abs_cnt:,"actualtext","/ActualText~<\str_use:N \l__tag_tmpa_str>"
              )
         }
      },
    actualtext-o .code:n      = % Alt property
      {
        \str_set_convert:Noon
          \l__tag_tmpa_str
          { #1 }
          { default }
          { utf16/hex }
        \tl_put_right:Nn \l__tag_mc_key_properties_tl { /Alt~< }
        \tl_put_right:No \l__tag_mc_key_properties_tl { \l__tag_tmpa_str>~ }
        \directlua
          {
            ltx.__tag.func.store_mc_data
              (
                \__tag_get_mc_abs_cnt:,
                "actualtext",
                "/ActualText~<\str_use:N \l__tag_tmpa_str>"
              )
          }
      },
    label .code:n =
      {
        \tl_set:Nn\l__tag_mc_key_label_tl { #1 }
        \directlua
          {
            ltx.__tag.func.store_mc_data
              (
                \__tag_get_mc_abs_cnt:,"label","#1"
              )
          }
      },
    __artifact-store .code:n =
      {
        \directlua
          {
            ltx.__tag.func.store_mc_data
              (
                \__tag_get_mc_abs_cnt:,"artifact","#1"
              )
          }
      },
    artifact .code:n       =
      {
        \exp_args:Nnx
          \keys_set:nn
            { __tag / mc}
            { artifact-bool, artifact-type=#1, tag=Artifact }
        \exp_args:Nnx
          \keys_set:nn
            { __tag / mc }
            { __artifact-store=\l__tag_mc_artifact_type_tl }
      },
    artifact .default:n    = { notype }
  }


\cs_set_protected:Npn \__tag_attribute_gset:Nn #1 #2
  {
    \tex_global:D \setattribute #1 #2
  }

\cs_set_protected:Npn \__tag_attribute_set:Nn #1 #2
  {
    \setattribute #1 #2
  }

\cs_set_protected:Npn \__tag_attribute_gunset:N #1
  {
    \tex_global:D \unsetattribute #1
  }

\cs_set_protected:Npn \__tag_attribute_unset:N #1
  {
    \unsetattribute #1
  }

\cs_new:Nn \__tag_mc_lua_set_mc_type_attr:n % #1 is a tag name
  {
    \__tag_attribute_set:Nn \l__tag_mc_type_attr
      {
        \directlua { ltx.__tag.func.output_num_from ("#1") }
      }
    \__tag_attribute_set:Nn \l__tag_mc_cnt_attr  { \__tag_get_mc_abs_cnt: }
  }

\cs_generate_variant:Nn\__tag_mc_lua_set_mc_type_attr:n { o }

\cs_new:Nn \__tag_mc_lua_unset_mc_type_attr:
  {
    \__tag_attribute_unset:N \l__tag_mc_type_attr
    \__tag_attribute_unset:N \l__tag_mc_cnt_attr
  }

\cs_new:Nn \__tag_mc_insert_mcid_kids:n
  {
    \directlua { ltx.__tag.func.mc_insert_kids (#1,0) }
  }

\cs_new:Nn \__tag_mc_insert_mcid_single_kids:n
  {
    \directlua {ltx.__tag.func.mc_insert_kids (#1,1) }
  }


\cs_new:Nn \__tag_mc_handle_stash:n %1 mcidnum
  {
    \__tag_check_mc_used:n { #1 }
    \seq_gput_right:cn % Don't fill a lua table due to the command in the item,
                       % so use the kernel command
      { g__tag_struct_kids_\g__tag_struct_stack_current_tl _seq }
      {
        \__tag_mc_insert_mcid_kids:n {#1}%
      }
    \directlua
      {
        ltx.__tag.func.store_struct_mcabs
          (
            \g__tag_struct_stack_current_tl,#1
          )
      }
    \prop_gput:Nxx
      \g__tag_mc_parenttree_prop
      { #1 }
      { \g__tag_struct_stack_current_tl }
  }

\cs_generate_variant:Nn \__tag_mc_handle_stash:n { o }

\cs_new_protected:Nn \tag_mc_begin:n
  {
    %\group_begin:
    %\__tag_check_mc_if_nested:
    %\bool_gset_true:N \g__tag_in_mc_bool
    \bool_set_false:N\l__tag_mc_artifact_bool
    \int_gincr:N \c@g__tag_MCID_abs_int
    \tl_clear:N \l__tag_mc_key_properties_tl
    \keys_set:nn { __tag / mc }{ label={}, #1 }
    %check that a tag or artifact has been used
    \__tag_check_mc_tag:N \l__tag_mc_key_tag_tl
    %set the attributes:
    \__tag_mc_lua_set_mc_type_attr:o  { \l__tag_mc_key_tag_tl }
    \bool_if:NF \l__tag_mc_artifact_bool
      { % store the absolute num name in a label:
        \tl_if_empty:NF {\l__tag_mc_key_label_tl}
          {
            \__tag_mc_handle_mc_label:n { \l__tag_mc_key_label_tl }
          }
       % if not stashed record the absolute number
        \bool_if:NF \l__tag_mc_key_stash_bool
          {
            \exp_args:Nx \__tag_mc_handle_stash:n { \__tag_get_mc_abs_cnt: }
          }
      }
    %\bool_set_false:N\l__tag_mc_artifact_bool
    %\group_end:
  }

\cs_set_eq:NN \uftag_mc_begin:n \tag_mc_begin:n

\cs_new_protected:Nn \tag_mc_end:
  {
    %\__tag_check_mc_if_open:
    %\bool_gset_false:N \g__tag_in_mc_bool
    \bool_set_false:N\l__tag_mc_artifact_bool
    \__tag_mc_lua_unset_mc_type_attr:
    \tl_set:Nn  \l__tag_mc_key_tag_tl { }
  }

\cs_set_eq:NN \uftag_mc_end: \tag_mc_end:

\cs_new_protected:Nn \tag_mc_use:n %#1: label name
  {
    \tl_set:Nx  \l_tmpa_tl { \__tag_ref_value:enn{tagpdf-#1}{tagmcabs}{} }
    \tl_if_empty:NTF\l_tmpa_tl
      {
        \msg_warning:nnn {tag} {mc-label-unknown} { #1 }
      }
      {
        \__tag_mc_handle_stash:o { \l_tmpa_tl }
      }
  }

\cs_set_eq:NN \uftag_mc_use:n \tag_mc_use:n

\cs_new:Nn \__tag_get_data_mc_tag: { \l__tag_mc_key_tag_tl }
%% 
%%
%% End of file `tagpdf-mc-code-lua.sty'.
