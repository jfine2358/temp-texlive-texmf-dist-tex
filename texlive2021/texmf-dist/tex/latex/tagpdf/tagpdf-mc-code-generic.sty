%%
%% This is file `tagpdf-mc-code-generic.sty',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% tagpdf-mc.dtx  (with options: `generic')
%% 
%% Copyright (C) 2019 Ulrike Fischer
%% 
%% It may be distributed and/or modified under the conditions of
%% the LaTeX Project Public License (LPPL), either version 1.3c of
%% this license or (at your option) any later version.  The latest
%% version of this license is in the file:
%% 
%%    https://www.latex-project.org/lppl.txt
%% 
%% This file is part of the "tagpdf bundle" (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%% 
%% File: tagpdf-mc.dtx
\ProvidesExplPackage {tagpdf-mc-code-generic} {2021/02/23} {0.80}
 {part of tagpdf - code related to marking chunks - generic mode}


\__tag_prop_new:N \g__tag_MCID_byabspage_prop

\bool_new:N \g__tag_in_mc_bool

\prg_new_conditional:Nnn \__tag_mc_if_in: {p,T,F,TF}
  {
    \bool_if:NTF \g__tag_in_mc_bool
      { \prg_return_true:  }
      { \prg_return_false: }
  }

\prg_new_eq_conditional:NNn \tag_mc_if_in: \__tag_mc_if_in: {p,T,F,TF}

\prg_new_eq_conditional:NNn \uftag_mc_if_in: \__tag_mc_if_in: {p,T,F,TF}

\cs_new_protected:Nn \__tag_mc_bmc:n
  {
    \pdf_bmc:n {#1}
  }

\cs_new_protected:Nn \__tag_mc_emc:
  {
    \pdf_emc:
    %\__tag_pdfliteral_page:n
  }

\cs_new_protected:Nn \__tag_mc_bdc:nn
  {
    \pdf_bdc:nn { #1 } { #2 }
  }

\cs_generate_variant:Nn \__tag_mc_bdc:nn {nx}

\tl_new:N \l__tag_mc_ref_abspage_tl %will store the abspage value of label
\tl_new:N \l__tag_mc_tmp_tl

\cs_new:Nn \__tag_mc_bdc_mcid:nn
  {
    \int_gincr:N \c@g__tag_MCID_abs_int
    \tl_set:Nx \l__tag_mc_ref_abspage_tl
      {
        \__tag_ref_value:enn %3 args
          {
            mcid-\int_use:N \c@g__tag_MCID_abs_int
          }
          { tagabspage }
          {-1}
      }
    \prop_get:NoNTF
      \g__tag_MCID_byabspage_prop
      {
        \l__tag_mc_ref_abspage_tl
      }
      \l__tag_mc_tmp_tl
      {
        %key already present, use value for MCID and add 1 for the next
        \int_gset:Nn \g__tag_MCID_tmp_bypage_int { \l__tag_mc_tmp_tl }
        \__tag_prop_gput:Nxx
          \g__tag_MCID_byabspage_prop
          { \l__tag_mc_ref_abspage_tl }
          { \int_eval:n {\l__tag_mc_tmp_tl +1} }
      }
      {
        %key not present, set MCID to 0 and insert 1
        \int_gzero:N \g__tag_MCID_tmp_bypage_int
        \__tag_prop_gput:Nxx
          \g__tag_MCID_byabspage_prop
          { \l__tag_mc_ref_abspage_tl }
          {1}
      }
    \__tag_ref_label:en
      {
        mcid-\int_use:N \c@g__tag_MCID_abs_int
      }
      { mc }
   %\exp_args:Nnx
     \__tag_mc_bdc:nx
       {#1}
       { /MCID~\int_eval:n { \g__tag_MCID_tmp_bypage_int }~ \exp_not:n { #2 } }
 }

\cs_new:Nn \__tag_mc_bdc_mcid:n
  {
    \__tag_mc_bdc_mcid:nn {#1} {}
  }

\cs_new:Nn  \__tag_mc_bmc_artifact:
  {
    \__tag_mc_bmc:n {Artifact}
  }

\cs_new:Nn \__tag_mc_bmc_artifact:n
  {
    \__tag_mc_bdc:nn {Artifact}{/Type/#1}
  }



\tl_new:N \l__tag_mc_key_tag_tl
\tl_new:N \g__tag_mc_key_tag_tl %for "outside" queries
\tl_new:N \l__tag_mc_key_properties_tl

\keys_define:nn { __tag / mc }
  {
    tag .code:n = % the name (H,P,Spa) etc
      {
         %%????????? \pdfescapename??
        \tl_set:Nx   \l__tag_mc_key_tag_tl { #1 }
        \tl_gset:Nx  \g__tag_mc_key_tag_tl { #1 }
      },
    raw  .code:n =
      {
        \tl_put_right:Nx \l__tag_mc_key_properties_tl { #1 }
      },
    alttext .code:n = % Alt property
      {
        \str_set_convert:Nnon
          \l__tag_tmpa_str
          { #1 }
          { default }
          { utf16/hex }
        \tl_put_right:Nn \l__tag_mc_key_properties_tl { /Alt~< }
        \tl_put_right:No \l__tag_mc_key_properties_tl { \l__tag_tmpa_str>~ }
      },
    alttext-o .code:n      = % Alt property
      {
        \str_set_convert:Noon
          \l__tag_tmpa_str
          { #1 }
          { default }
          { utf16/hex }
        \tl_put_right:Nn \l__tag_mc_key_properties_tl { /Alt~< }
        \tl_put_right:No \l__tag_mc_key_properties_tl { \l__tag_tmpa_str>~ }
      },
    actualtext .code:n      = % ActualText property
      {
        \str_set_convert:Nnon
          \l__tag_tmpa_str
          { #1 }
          { default }
          { utf16/hex }
        \tl_put_right:Nn \l__tag_mc_key_properties_tl { /ActualText~< }
        \tl_put_right:No \l__tag_mc_key_properties_tl { \l__tag_tmpa_str>~ }
      },
    actualtext-o .code:n      = % ActualText property
      {
        \str_set_convert:Noon
          \l__tag_tmpa_str
          { #1 }
          { default }
          { utf16/hex }
        \tl_put_right:Nn \l__tag_mc_key_properties_tl { /ActualText~< }
        \tl_put_right:No \l__tag_mc_key_properties_tl { \l__tag_tmpa_str>~ }
      },
    label .tl_set:N        = \l__tag_mc_key_label_tl,
    artifact .code:n       =
      {
        \exp_args:Nnx
          \keys_set:nn
            { __tag / mc }
            { artifact-bool, artifact-type=#1 }
      },
    artifact .default:n    = {notype}
  }

\cs_new:Nn \__tag_mc_handle_artifact:N %#1 contains the artifact type
  {
    \tl_if_empty:NTF #1
      { \__tag_mc_bmc_artifact: }
      { \exp_args:No\__tag_mc_bmc_artifact:n {#1} }
  }

\cs_new:Nn \__tag_mc_handle_mcid:nn %#1 tag, #2 properties
  {
    \__tag_mc_bdc_mcid:nn {#1} {#2}
  }

\cs_generate_variant:Nn \__tag_mc_handle_mcid:nn {VV}

\cs_new:Nn \__tag_mc_handle_stash:n %1 mcidnum
  {
    \__tag_check_mc_used:n {#1}
    \__tag_struct_kid_mc_gput_right:nn
      { \g__tag_struct_stack_current_tl }
      {#1}
   \prop_gput:Nxx \g__tag_mc_parenttree_prop
     {#1}
     { \g__tag_struct_stack_current_tl }
  }

\cs_new_protected:Nn \tag_mc_begin:n
  {
    \group_begin: %hm
    \__tag_check_mc_if_nested:
    \bool_gset_true:N \g__tag_in_mc_bool
    \keys_set:nn { __tag / mc } {#1}
    \bool_if:NTF \l__tag_mc_artifact_bool
      { %handle artifact
        \__tag_mc_handle_artifact:N \l__tag_mc_artifact_type_tl
      }
      { %handle mcid type
        \__tag_check_mc_tag:N  \l__tag_mc_key_tag_tl
        \__tag_mc_handle_mcid:VV
           \l__tag_mc_key_tag_tl
           \l__tag_mc_key_properties_tl
        \tl_if_empty:NF {\l__tag_mc_key_label_tl}
          {
            \__tag_mc_handle_mc_label:n { \l__tag_mc_key_label_tl }
          }
        \bool_if:NF \l__tag_mc_key_stash_bool
          {
            \__tag_mc_handle_stash:n { \int_use:N \c@g__tag_MCID_abs_int }
          }
      }
    \group_end:
  }

\cs_set_eq:NN \uftag_mc_begin:n \tag_mc_begin:n

\cs_new_protected:Nn \tag_mc_end:
  {
    \__tag_check_mc_if_open:
    \bool_gset_false:N \g__tag_in_mc_bool
    \tl_gset:Nn  \g__tag_mc_key_tag_tl { }
    \__tag_mc_emc:
  }

\cs_set_eq:NN \uftag_mc_end: \tag_mc_end:

\cs_new_protected:Nn \tag_mc_use:n %#1: label name
  {
    \tl_set:Nx  \l_tmpa_tl { \__tag_ref_value:enn{tagpdf-#1}{tagmcabs}{} }
    \tl_if_empty:NTF\l_tmpa_tl
      {
        \msg_warning:nnn {tag} {mc-label-unknown} {#1}
      }
      {
        \prop_gput:Nxx
          \g__tag_mc_parenttree_prop
          {
            \__tag_ref_value:enn {tagpdf-#1} {tagmcabs} {}
          }
          {
            \g__tag_struct_stack_current_tl
          }
        \__tag_struct_kid_mc_gput_right:nn
          {
            \g__tag_struct_stack_current_tl
          }
          {
            \__tag_ref_value:enn {tagpdf-#1} {tagmcabs} {}
          }
       }
  }

\cs_set_eq:NN \uftag_mc_use:n \tag_mc_use:n

\cs_new:Nn \__tag_get_data_mc_tag: { \g__tag_mc_key_tag_tl }

%% 
%%
%% End of file `tagpdf-mc-code-generic.sty'.
