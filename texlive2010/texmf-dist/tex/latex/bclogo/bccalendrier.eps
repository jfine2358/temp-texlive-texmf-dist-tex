%!PS-Adobe-2.0 EPSF-2.0
%%Creator: dvips(k) 5.96dev Copyright 2007 Radical Eye Software
%%Title: CompileEps.dvi
%%CreationDate: Wed Sep 23 14:45:25 2009
%%BoundingBox: 71 700 90 721
%%DocumentFonts: LMMono10-Regular LMMono8-Regular
%%EndComments
%DVIPSWebPage: (www.radicaleye.com)
%DVIPSCommandLine: dvips -E -o
%+ C:\Users\Alain_2\Documents\LaTeX\bclogo\Logos\bccalendrier.eps
%+ CompileEps.dvi
%DVIPSParameters: dpi=600
%DVIPSSource:  TeX output 2009.09.23:1445
%%BeginProcSet: tex.pro 0 0
%!
/TeXDict 300 dict def TeXDict begin/N{def}def/B{bind def}N/S{exch}N/X{S
N}B/A{dup}B/TR{translate}N/isls false N/vsize 11 72 mul N/hsize 8.5 72
mul N/landplus90{false}def/@rigin{isls{[0 landplus90{1 -1}{-1 1}ifelse 0
0 0]concat}if 72 Resolution div 72 VResolution div neg scale isls{
landplus90{VResolution 72 div vsize mul 0 exch}{Resolution -72 div hsize
mul 0}ifelse TR}if Resolution VResolution vsize -72 div 1 add mul TR[
matrix currentmatrix{A A round sub abs 0.00001 lt{round}if}forall round
exch round exch]setmatrix}N/@landscape{/isls true N}B/@manualfeed{
statusdict/manualfeed true put}B/@copies{/#copies X}B/FMat[1 0 0 -1 0 0]
N/FBB[0 0 0 0]N/nn 0 N/IEn 0 N/ctr 0 N/df-tail{/nn 8 dict N nn begin
/FontType 3 N/FontMatrix fntrx N/FontBBox FBB N string/base X array
/BitMaps X/BuildChar{CharBuilder}N/Encoding IEn N end A{/foo setfont}2
array copy cvx N load 0 nn put/ctr 0 N[}B/sf 0 N/df{/sf 1 N/fntrx FMat N
df-tail}B/dfs{div/sf X/fntrx[sf 0 0 sf neg 0 0]N df-tail}B/E{pop nn A
definefont setfont}B/Cw{Cd A length 5 sub get}B/Ch{Cd A length 4 sub get
}B/Cx{128 Cd A length 3 sub get sub}B/Cy{Cd A length 2 sub get 127 sub}
B/Cdx{Cd A length 1 sub get}B/Ci{Cd A type/stringtype ne{ctr get/ctr ctr
1 add N}if}B/CharBuilder{save 3 1 roll S A/base get 2 index get S
/BitMaps get S get/Cd X pop/ctr 0 N Cdx 0 Cx Cy Ch sub Cx Cw add Cy
setcachedevice Cw Ch true[1 0 0 -1 -.1 Cx sub Cy .1 sub]{Ci}imagemask
restore}B/D{/cc X A type/stringtype ne{]}if nn/base get cc ctr put nn
/BitMaps get S ctr S sf 1 ne{A A length 1 sub A 2 index S get sf div put
}if put/ctr ctr 1 add N}B/I{cc 1 add D}B/bop{userdict/bop-hook known{
bop-hook}if/SI save N @rigin 0 0 moveto/V matrix currentmatrix A 1 get A
mul exch 0 get A mul add .99 lt{/QV}{/RV}ifelse load def pop pop}N/eop{
SI restore userdict/eop-hook known{eop-hook}if showpage}N/@start{
userdict/start-hook known{start-hook}if pop/VResolution X/Resolution X
1000 div/DVImag X/IEn 256 array N 2 string 0 1 255{IEn S A 360 add 36 4
index cvrs cvn put}for pop 65781.76 div/vsize X 65781.76 div/hsize X}N
/p{show}N/RMat[1 0 0 -1 0 0]N/BDot 260 string N/Rx 0 N/Ry 0 N/V{}B/RV/v{
/Ry X/Rx X V}B statusdict begin/product where{pop false[(Display)(NeXT)
(LaserWriter 16/600)]{A length product length le{A length product exch 0
exch getinterval eq{pop true exit}if}{pop}ifelse}forall}{false}ifelse
end{{gsave TR -.1 .1 TR 1 1 scale Rx Ry false RMat{BDot}imagemask
grestore}}{{gsave TR -.1 .1 TR Rx Ry scale 1 1 false RMat{BDot}
imagemask grestore}}ifelse B/QV{gsave newpath transform round exch round
exch itransform moveto Rx 0 rlineto 0 Ry neg rlineto Rx neg 0 rlineto
fill grestore}B/a{moveto}B/delta 0 N/tail{A/delta X 0 rmoveto}B/M{S p
delta add tail}B/b{S p tail}B/c{-4 M}B/d{-3 M}B/e{-2 M}B/f{-1 M}B/g{0 M}
B/h{1 M}B/i{2 M}B/j{3 M}B/k{4 M}B/w{0 rmoveto}B/l{p -4 w}B/m{p -3 w}B/n{
p -2 w}B/o{p -1 w}B/q{p 1 w}B/r{p 2 w}B/s{p 3 w}B/t{p 4 w}B/x{0 S
rmoveto}B/y{3 2 roll p a}B/bos{/SS save N}B/eos{SS restore}B end

%%EndProcSet
%%BeginProcSet: pstricks.pro 0 0
% $Id: pstricks.pro 34 2008-06-25 17:20:01Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 1.05, 2008/06/25
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
% Define the follwing gs-functions if not known, eg when using distiller
%
systemdict /.setopacityalpha known not {/.setopacityalpha { pop } def } if
systemdict /.setblendmode known not {/.setblendmode { pop } def } if
systemdict /.setshapealpha known not {/.setshapealpha { pop } def } if
%
/tx@Dict 200 dict def 				% the main PSTricks dictionary
tx@Dict begin
/ADict 25 dict def				% The arrow dictionaray
/CM { matrix currentmatrix } bind def
/SLW /setlinewidth load def
/CLW /currentlinewidth load def
/CP /currentpoint load def
/ED { exch def } bind def
/L /lineto load def
/T /translate load def
/TMatrix { } def
/RAngle { 0 } def
/Sqrt { dup 0 lt { pop 0 } { sqrt } ifelse } def  % return 0 for negative arguments 
/Atan { /atan load stopped { pop pop 0 } if } def % return 0 if atan not known
/ATAN1 {neg -1 atan 180 sub } def		% atan(x) (only one parameter)
/Div { dup 0 eq { pop } { div } ifelse } def  	% control the division
/tan { dup cos abs 1.e-10 lt 
  { pop 1.e10 } 				% return 1.e10 as infinit
  { dup sin exch cos div } ifelse 		% default sin/cos
} def
/Tan { dup sin exch cos Div } def 		% sin(x)/cos(x) x in degrees
/Acos {dup dup mul neg 1 add dup 0 lt {		% arc cos, returns 0 when negative root
  pop pop 0 }{ sqrt exch atan} ifelse } def
/NET { neg exch neg exch T } def	      	% change coordinate system to the negative one		
/Pyth { dup mul exch dup mul add sqrt } def   	% Pythagoras, expects 2 parameter
/Pyth2 {					% Pythagoras, xA yA xB yB
  3 -1 roll 		% xA xB yB yA
  sub			% xA xB yB-yA
  3 1 roll 		% yB-yA xA xB
  sub			% yB-yA xA-xB
  Pyth } def
/PtoC { 2 copy cos mul 3 1 roll sin mul } def 	% Polar to Cartesian
/Rand { rand 4294967295 div } def		% a real random number
%----------------- hv added 20050516 ---------------
/PiDiv2 1.57079632680 def
/Pi 3.14159265359 def 
/TwoPi 6.28318530718 def
/Euler 2.71828182846 def 
%/e Euler bind def
/RadtoDeg { 180 mul Pi div } bind def 		% convert from radian to degrees
/DegtoRad { Pi mul 180 div } bind def 		% viceversa
%----------------- hv end---------------------------
/PathLength@ { /z z y y1 sub x x1 sub Pyth add def /y1 y def /x1 x def } def
/PathLength { 
  flattenpath /z 0 def 
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def }
  { /y ED /x ED PathLength@ } 
  {} 
  { /y y2 def /x x2 def PathLength@ }
  /pathforall load stopped { pop pop pop pop } if 
  z 
} def
%
/STP { .996264 dup scale } def			% BP/PT scaling
/STV { SDict begin normalscale end STP  } def	% 
%
%%-------------- DG begin patch 15 ---------------%%
%/DashLine { dup 0 gt { /a .5 def PathLength exch div } { pop /a 1 def
%PathLength } ifelse /b ED /x ED /y ED /z y x add def b a .5 sub 2 mul y
%mul sub z Div round z mul a .5 sub 2 mul y mul add b exch Div dup y mul
%/y ED x mul /x ED x 0 gt y 0 gt and { [ y x ] 1 a sub y mul } { [ 1 0 ]
%0 } ifelse setdash stroke } def
/DashLine {
  dup 0 gt { /a .5 def PathLength exch div } { pop /a 1 def PathLength } ifelse
  /b ED /x1 ED /y1 ED /x ED /y ED 
  /z y x add y1 add x1 add def
  /Coef b a .5 sub 2 mul y mul sub z Div round 
    z mul a .5 sub 2 mul y mul add b exch Div def 
  /y y Coef mul def 
  /x x Coef mul def 
  /y1 y1 Coef mul def 
  /x1 x1 Coef mul def
  x1 0 gt y1 0 gt or x 0 gt or y 0 gt and 
    { [ y x y1 x1 ] 1 a sub y mul }
    { [ 1 0 ] 0 } ifelse 
  setdash stroke
} def
%%-------------- DG end patch 15 ---------------%%
/DotLine { 
  /b PathLength def 
  /a ED /z ED /y CLW def 
  /z y z add def 
  a 0 gt { 
    /b b a div def 
  }{ 
    a 0 eq { 
      /b b y sub def 
    }{ a -3 eq { 
      /b b y add def } if 
    } ifelse 
  } ifelse 
  [ 0 b b z Div round Div dup 0 le { pop 1 } if ] 
  a 0 gt { 0 }{ y 2 div a -2 gt { neg }if } ifelse 
  setdash 1 setlinecap stroke 
} def
%
/LineFill { % hv ------------ patch 7 -------------
  gsave 
  abs /hatchWidthInc ED
  abs /hatchSepInc ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  2 setlinecap 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  x2 x1 sub 1 add { 
    x1 a mul y1 moveto 0 y2 rlineto stroke 
    /x1 x1 1 add 
      hatchWidthInc 0 gt { CLW add } if 
    def 
    hatchSepInc 0 gt hatchWidthInc 0 gt or { 
      /a a hatchSepInc add def
      CLW hatchWidthInc add SLW 
    } if
  } repeat 
  grestore 
  pop pop } def
%
/PenroseFill {%	 on stack: scaling factor
  dup dup scale
  1 exch div round /penroseFactor ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  /I/S/L/W/G/+/Z/F/E/D[/def/exch/for{E D}/add{s E get mul}
 { Z -36.2001 1 33 }{25 E S rlineto}{/q Z dup q G E q 1 + G}{Z 2 2}]{cvx def}forall
  [0 72 1008 {dup sin E cos }F ]1 setlinejoin/s W{/a W{/b I 10{/i I 4{/m I moveto
  i m +/j I 10{/l Z b m l + G a l G sub s m get div .2 + floor .3 + 25
  mul j l + S rmoveto}F i L j L stroke }F}F}F}F 
  grestore 
  pop pop 
} def
%
%gsave abs CLW add /a ED a 0 dtransform round exch round exch
%2 copy idtransform exch Atan rotate idtransform pop /a ED .25 .25
%% DG/SR modification begin - Dec. 12, 1997 - Patch 2
%%itransform translate pathbbox /y2 ED a Div ceiling cvi /x2 ED /y1 ED a
%itransform pathbbox /y2 ED a Div ceiling cvi /x2 ED /y1 ED a
%% DG/SR modification end
%Div cvi /x1 ED /y2 y2 y1 sub def clip newpath 2 setlinecap systemdict
%/setstrokeadjust known { true setstrokeadjust } if x2 x1 sub 1 add { x1
%% DG/SR modification begin - Jun.  1, 1998 - Patch 3 (from Michael Vulis)
%% a mul y1 moveto 0 y2 rlineto stroke /x1 x1 1 add def } repeat grestore }
%% def
%a mul y1 moveto 0 y2 rlineto stroke /x1 x1 1 add def } repeat grestore
%pop pop } def
%% DG/SR modification end
%
/BeginArrow { 
  ADict begin 			% hold it local, for end see EndArrow
  /@mtrx CM def 
  gsave 
  2 copy T 
  2 index sub neg exch 
  3 index sub exch Atan 
  rotate newpath 
} def
%
/EndArrow { @mtrx setmatrix CP grestore end } def % end the ADict
%
/Arrow { 
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /a ED 
  { 0 h T 1 -1 scale } if 
  w neg h moveto 
  0 0 L w h L w neg a neg rlineto 
  gsave fill grestore 
} def
%
/ArrowD { % the sides are drawn as curves (hv 20071211)
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /Inset ED 
  { 0 h T 1 -1 scale } if % changes the direction
% we use y=w/h^2 * x^2 as equation for the control points
% for the coordinates the arrow is seen from top to bottom
% the bottom (tip) is (0;0)
  w neg h moveto % lower left of >
  w 9 div 4 mul neg h 3 div 2 mul
  w 9 div neg       h 3 div  
  0 0 curveto    % tip of >
  w 9 div        h 3 div  
  w 9 div 4 mul  h 3 div 2 mul
  w h curveto % upper left of >
  w neg Inset neg rlineto % move to x=0 and inset
  gsave fill grestore 
} def 
%
/Tbar { 
  CLW mul add /z ED 
  z -2 div CLW 2 div moveto 
  z 0 rlineto stroke 
  0 CLW moveto 
} def
%
/Bracket { 
  CLW mul add dup CLW sub 2 div 
  /x ED mul CLW add /y ED /z CLW 2 div def 
  x neg y moveto 
  x neg CLW 2 div L x CLW 2 div L x y L stroke 
  0 CLW moveto 
} def
%
/RoundBracket { 
  CLW mul add dup 2 div 
  /x ED mul /y ED /mtrx CM def 
  0 CLW 2 div T x y mul 0 ne { x y scale } if 
  1 1 moveto 
  .85 .5 .35 0 0 0 curveto 
  -.35 0 -.85 .5 -1 1 curveto 
  mtrx setmatrix stroke 0 CLW moveto 
} def
%
/SD { 0 360 arc fill } def
%
/EndDot { % DS is the dot size 
  { /z DS def } { /z 0 def } ifelse 
  /b ED 0 z DS SD b { 0 z DS CLW sub SD } if 
  0 DS z add CLW 4 div sub moveto } def
%
/Shadow { [ { /moveto load } { /lineto load } { /curveto load } {
  /closepath load } /pathforall load stopped { pop pop pop pop CP /moveto
  load } if ] cvx newpath 3 1 roll T exec } def
%
%/NArray { 
%   aload length 2 div dup dup cvi eq not { exch pop } if /n exch
%   cvi def 
%} def
%
/NArray { % holds the coordinates and on top of stack the showpoints boolean
  /showpoints ED 
  counttomark 2 div dup cvi /n ED 
  n eq not { exch pop } if
  showpoints { ] aload /Points ED } { n 2 mul 1 add -1 roll pop } ifelse 
} def
%
/Line { 
  NArray n 0 eq not 
    { n 1 eq { 0 0 /n 2 def } if ArrowA /n n 2 sub def 
      n { Lineto } repeat 
      CP 4 2 roll ArrowB L pop pop 
    } if 
} def
%
/Arcto { 
  /a [ 6 -2 roll ] cvx def 
  a r 
  /arcto load stopped { 5 } { 4 } ifelse { pop } repeat 
  a 
} def
%
/CheckClosed { dup n 2 mul 1 sub index eq 2 index n 2 mul 1 add index eq
  and { pop pop /n n 1 sub def } if } def
/Polygon { NArray n 2 eq { 0 0 /n 3 def } if n 3 lt { n { pop pop }
  repeat } { n 3 gt { CheckClosed } if n 2 mul -2 roll /y0 ED /x0 ED /y1
  ED /x1 ED x1 y1 /x1 x0 x1 add 2 div def /y1 y0 y1 add 2 div def x1 y1
  moveto /n n 2 sub def n { Lineto } repeat x1 y1 x0 y0 6 4 roll Lineto
  Lineto pop pop closepath } ifelse } def
/Diamond { 
  /mtrx CM def 
  T rotate 
  /h ED 
  /w ED 
  dup 0 eq { pop } { CLW mul neg 
    /d ED 
    /a w h Atan def 
    /h d a sin Div h add def 
    /w d a cos Div w add def } ifelse 
  mark w 2 div h 2 div w 0 0 h neg w neg 0 0 h w 2 div h 2 div 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false Line 
  closepath mtrx setmatrix } def
% DG modification begin - Jan. 15, 1997
%/Triangle { /mtrx CM def translate rotate /h ED 2 div /w ED dup 0 eq {
%pop } { CLW mul /d ED /h h d w h Atan sin Div sub def /w w d h w Atan 2
%div dup cos exch sin Div mul sub def } ifelse mark 0 d w neg d 0 h w d 0
%d /ArrowA { moveto } def /ArrowB { } def false Line closepath mtrx
%setmatrix } def
/Triangle { /mtrx CM def translate rotate /h ED 2 div /w ED dup
CLW mul /d ED /h h d w h Atan sin Div sub def /w w d h w Atan 2
div dup cos exch sin Div mul sub def mark 0 d w neg d 0 h w d 0
d /ArrowA { moveto } def /ArrowB { } def false Line closepath mtrx
% DG/SR modification begin - Jun.  1, 1998 - Patch 3 (from Michael Vulis)
% setmatrix } def
setmatrix pop } def
% DG/SR modification end
%
/CCA { 
  /y ED /x ED 
  2 copy y sub /dy1 ED 
  x sub /dx1 ED 
  /l1 dx1 dy1 Pyth def 
} def
%
/CC { 
  /l0 l1 def 
  /x1 x dx sub def 
  /y1 y dy sub def 
  /dx0 dx1 def 
  /dy0 dy1 def 
  CCA 
  /dx dx0 l1 c exp mul dx1 l0 c exp mul add def 
  /dy dy0 l1 c exp mul dy1 l0 c exp mul add def 
  /m dx0 dy0 Atan dx1 dy1 Atan sub 2 div cos abs b exp a mul dx dy Pyth Div 2 div def 
  /x2 x l0 dx mul m mul sub def
  /y2 y l0 dy mul m mul sub def 
  /dx l1 dx mul m mul neg def 
  /dy l1 dy mul m mul neg def 
} def
%
/IC { 
  /c c 1 add def 
  c 0 lt { /c 0 def } { c 3 gt { /c 3 def } if } ifelse 
  /a a 2 mul 3 div 45 cos b exp div def 
  CCA 
  /dx 0 def 
  /dy 0 def 
} def
%
/BOC { IC CC x2 y2 x1 y1 ArrowA CP 4 2 roll x y curveto } def
/NC { CC x1 y1 x2 y2 x y curveto } def
/EOC { x dx sub y dy sub 4 2 roll ArrowB 2 copy curveto } def
/BAC { IC CC x y moveto CC x1 y1 CP ArrowA } def
/NAC { x2 y2 x y curveto CC x1 y1 } def
/EAC { x2 y2 x y ArrowB curveto pop pop } def
%
/OpenCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { BOC /n n 3 sub def n { NC } repeat EOC } ifelse 
} def
%
/AltCurve { 
  { false NArray n 2 mul 2 roll 
    [ n 2 mul 3 sub 1 roll ] aload
    /Points ED 
    n 2 mul -2 roll } 
  { false NArray } ifelse 
  n 4 lt { n { pop pop } repeat } { BAC /n n 4 sub def n { NAC } repeat EAC } ifelse 
} def
%
/ClosedCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      6 copy n 2 mul 6 add 6 roll 
      IC CC x y moveto n { NC } repeat 
      closepath pop pop 
    } ifelse 
} def
%
/SQ { /r ED r r moveto r r neg L r neg r neg L r neg r L fill } def
/ST { /y ED /x ED x y moveto x neg y L 0 x L fill } def
/SP { /r ED gsave 0 r moveto 4 { 72 rotate 0 r L } repeat fill grestore }
def
/FontDot { DS 2 mul dup matrix scale matrix concatmatrix exch matrix
rotate matrix concatmatrix exch findfont exch makefont setfont } def
/Rect { x1 y1 y2 add 2 div moveto x1 y2 lineto x2 y2 lineto x2 y1 lineto
x1 y1 lineto closepath } def
/OvalFrame { x1 x2 eq y1 y2 eq or { pop pop x1 y1 moveto x2 y2 L } { y1
y2 sub abs x1 x2 sub abs 2 copy gt { exch pop } { pop } ifelse 2 div
exch { dup 3 1 roll mul exch } if 2 copy lt { pop } { exch pop } ifelse
/b ED x1 y1 y2 add 2 div moveto x1 y2 x2 y2 b arcto x2 y2 x2 y1 b arcto
x2 y1 x1 y1 b arcto x1 y1 x1 y2 b arcto 16 { pop } repeat closepath }
ifelse } def
/Frame { CLW mul /a ED 3 -1 roll 2 copy gt { exch } if a sub /y2 ED a add
/y1 ED 2 copy gt { exch } if a sub /x2 ED a add /x1 ED 1 index 0 eq {
pop pop Rect } { OvalFrame } ifelse } def
%
/BezierNArray { 
  /f ED 
  counttomark 2 div dup cvi /n ED 
  n eq not { exch pop } if 
  n 1 sub neg 3 mod 3 add 3 mod { 0 0 /n n 1 add def } repeat 
  f { ] aload /Points ED } { n 2 mul 1 add -1 roll pop } ifelse 
} def
%
/OpenBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { ArrowA n 4 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      6 2 roll 4 2 roll ArrowB curveto } ifelse 
} def
%
/ClosedBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { moveto n 1 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      closepath } ifelse 
} def
%
/BezierShowPoints { 
  gsave 
  Points aload length 2 div cvi /n ED 
  moveto 
  n 1 sub { lineto } repeat 
  CLW 2 div SLW [ 4 4 ] 0 setdash stroke 
  grestore 
} def
%
/Parab { 
  /y0 ED /x0 ED /y1 ED /x1 ED 
  /dx x0 x1 sub 3 div def 
  /dy y0 y1 sub 3 div def 
  x0 dx sub y0 dy add x1 y1 ArrowA
  x0 dx add y0 dy add x0 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 x0 y0 x0 2 mul x1 sub y1 ] def 
} def
%
/Grid { 
  newpath 
  /a 4 string def 
  /b ED /c ED /n ED 
  cvi dup 1 lt { pop 1 } if 
  /s ED 
  s div dup 0 eq { pop 1 } if 
  /dy ED s div dup 0 eq { pop 1 } if
  /dx ED dy div round dy mul 
  /y0 ED dx div round dx mul 
  /x0 ED dy div round cvi 
  /y2 ED dx div round cvi 
  /x2 ED dy div round cvi 
  /y1 ED dx div round cvi 
  /x1 ED 
  /h y2 y1 sub 0 gt { 1 } { -1 } ifelse def 
  /w x2 x1 sub 0 gt { 1 } { -1 } ifelse def 
  b 0 gt { 
    /z1 b 4 div CLW 2 div add def
%    /Helvetica findfont b scalefont setfont 
    /b b .95 mul CLW 2 div add def } if 
  systemdict /setstrokeadjust known 
    { true setstrokeadjust /t { } def }
    { /t { transform 0.25 sub round 0.25 add exch 0.25 sub round 0.25 add
       exch itransform } bind def } ifelse 
  gsave n 0 gt { 1 setlinecap [ 0 dy n div ] dy n div 2 div setdash } { 2 setlinecap } ifelse 
  /i x1 def 
  /f y1 dy mul n 0 gt { dy n div 2 div h mul sub } if def 
  /g y2 dy mul n 0 gt { dy n div 2 div h mul add } if def 
  x2 x1 sub w mul 1 add dup 1000 gt { pop 1000 } if 
  { i dx mul dup y0 moveto 
    b 0 gt 
      { gsave c i a cvs dup stringwidth pop 
        /z2 ED w 0 gt {z1} {z1 z2 add neg} ifelse 
	h 0 gt {b neg}{z1} ifelse 
        rmoveto show grestore } if 
    dup t f moveto 
    g t L stroke 
    /i i w add def 
  } repeat 
  grestore 
  gsave 
  n 0 gt
  % DG/SR modification begin - Nov. 7, 1997 - Patch 1
  %{ 1 setlinecap [ 0 dx n div ] dy n div 2 div setdash }
    { 1 setlinecap [ 0 dx n div ] dx n div 2 div setdash }
  % DG/SR modification end
    { 2 setlinecap } ifelse 
  /i y1 def 
  /f x1 dx mul n 0 gt { dx n div 2 div w mul sub } if def 
  /g x2 dx mul n 0 gt { dx n div 2 div w mul add } if def 
  y2 y1 sub h mul 1 add dup 1000 gt { pop 1000 } if 
  { newpath i dy mul dup x0 exch moveto 
    b 0 gt { gsave c i a cvs dup stringwidth pop 
      /z2 ED 
      w 0 gt {z1 z2 add neg} {z1} ifelse 
      h 0 gt {z1} {b neg} ifelse 
      rmoveto show grestore } if 
    dup f exch t moveto 
    g exch t L stroke 
    /i i h add def 
  } repeat 
  grestore 
} def
%
/ArcArrow { 
  /d ED /b ED /a ED 
  gsave 
  newpath 0 -1000 moveto clip 
  newpath 
  0 1 0 0 b 
  grestore 
  c mul 
  /e ED 
  pop pop pop r a e d PtoC y add exch x add
  exch r a PtoC y add exch x add exch b pop pop pop pop a e d CLW 8 div c
  mul neg d 
} def
%
/Ellipse { /mtrx CM def T scale 0 0 1 5 3 roll arc mtrx setmatrix } def
%
/ArcAdjust { %%%% Vincent Guirardel
% given a target length (targetLength) and an initial angle (angle0) [in the stack],
% let  M(angle0)=(rx*cos(angle0),ry*sin(angle0))=(x0,y0).
% This computes an angle t such that (x0,y0) is at distance 
% targetLength from the point M(t)=(rx*cos(t),ry*sin(t)).
% NOTE: this an absolute angle, it does not have to be added or substracted to angle0
% contrary to TvZ's code.
% To achieve, this, one iterates the following process: start with some angle t,
% compute the point M' at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)].
% Now take t' (= new angle) so that (0,0) M(t') and M' are aligned.
%
% Another difference with TvZ's code is that we need d (=add/sub) to be defined.
% the value of d = add/sub is used to know on which side we have to move.
% It is only used in the initialisation of the angle before the iteration.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Input stack:  1: target length 2: initial angle
% variables used : rx, ry, d (=add/sub)
%
  /targetLength ED /angle0 ED
  /x0 rx angle0 cos mul def
  /y0 ry angle0 sin mul def
% we are looking for an angle t such that (x0,y0) is at distance targetLength 
% from the point M(t)=(rx*cos(t),ry*sin(t)))
%initialisation of angle (using 1st order approx = TvZ's code)
  targetLength 57.2958 mul
  angle0 sin rx mul dup mul
  angle0 cos ry mul dup mul
  add sqrt div 
% if initialisation angle is two large (more than 90 degrees) set it to 90 degrees
% (if the ellipse is very curved at the point where we draw the arrow, %
% the value can be much more than 360 degrees !)
% this should avoid going on the wrong side (more than 180 degrees) or go near
% a bad attractive point (at 180 degrees)
  dup 90 ge { pop 90 } if 
  angle0 exch d % add or sub
% maximum number of times to iterate the iterative procedure:
% iterative procedure: takes an angle t on top of stack, computes a 
% better angle (and put it on top of stack)
  30 { dup
% compute distance D between (x0,y0) and M(t)
    dup cos rx mul x0 sub dup mul exch sin ry mul y0 sub dup mul add sqrt
% if D almost equals targetLength, we stop
    dup targetLength sub abs 1e-5 le { pop exit } if
% stack now contains D t
% compute the point M(t') at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)]:
% M(t')= ( (x(t)-x0)*targetLength/d+x0 , (y(t)-y0)*targetLength/d+y0 )
    exch dup cos rx mul x0 sub  exch sin ry mul y0 sub
% stack contains:  y(t)-y0, x(t)-x0, d
    2 index Div targetLength mul y0 add ry Div exch
    2 index Div targetLength mul x0 add rx Div
% stack contains x(t')/rx , y(t')/ry , d
% now compute t', and remove D from stack
    atan exch pop
  } repeat
% we don't look at what happened... in particular, if targetLength is greater 
% than the diameter of the ellipse...
% the final angle will be around /angle0 + 180. maybe we should treat this pathological case...
% after iteration, stack contains an angle t such that M(t) is the tail of the arrow
% to give back the result as a an angle relative to angle0 we could add the following line:
% angle0 sub 0 exch d
%
% begin bug fix 2006-01-11
% we want to adjust the new angle t' by a multiple of 360 so that  | t'-angle0 | <= 180
%(we don't want to make the ellipse turn more or less than it should)...
dup angle0 sub dup abs 180 gt { 180 add 360 div floor 360 mul sub } { pop } ifelse
% end bug fix
} def
%
/EllipticArcArrow {
  /d ED      % is add or sub
  /b ED      % arrow procedure
  /a1 ED     % angle
  gsave
  newpath
  0 -1000 moveto
  clip                  % Set clippath far from arrow.
  newpath
  0 1 0 0 b             % Draw arrow to determine length.
  grestore
% Length of arrow is on top of stack. Next 3 numbers are junk.
%
  a1 exch ArcAdjust   % Angular position of base of arrow.
  /a2 ED
  pop pop pop
  a2 cos rx mul xOrig add % hv 2007-08-29   x->xOrig
  a2 sin ry mul yOrig add % hv 2007-08-29   y->yOrig
  a1 cos rx mul xOrig add % 
  a1 sin ry mul yOrig add % 
% Now arrow tip coor and base coor are on stack.
  b pop pop pop pop       % Draw arrow, and discard coordinates.
  a2 CLW 8 div
% change value of d (test it by looking if  `` 1 1 d '' gives 2 or not )
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse
  ArcAdjust
% resets original value of d
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse  % Adjust angle to give overlap.
} def
%%------------------ tvz/DG/hv (2004-05-10) end -------------------%%
%
/Rot { CP CP translate 3 -1 roll neg rotate NET  } def
%
/RotBegin { 
  tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 } def } if 
  /TMatrix [ TMatrix CM ] cvx def 
  /a ED 
  a Rot /RAngle [ RAngle dup a add ] cvx def 
} def
%
/RotEnd { /TMatrix [ TMatrix setmatrix ] cvx def /RAngle [ RAngle pop ] cvx def } def
%
/PutCoor { gsave CP T CM STV exch exec moveto setmatrix CP grestore } def
/PutBegin { /TMatrix [ TMatrix CM ] cvx def CP 4 2 roll T moveto } def
/PutEnd { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
/Uput { /a ED add 2 div /h ED 2 div /w ED /s a sin def /c a cos def /b s
abs c abs 2 copy gt dup /q ED { pop } { exch pop } ifelse def /w1 c b
div w mul def /h1 s b div h mul def q { w1 abs w sub dup c mul abs } {
h1 abs h sub dup s mul abs } ifelse } def
/UUput { /z ED abs /y ED /x ED q { x s div c mul abs y gt } { x c div s
mul abs y gt } ifelse { x x mul y y mul sub z z mul add sqrt z add } { q
{ x s div } { x c div } ifelse abs } ifelse a PtoC h1 add exch w1 add
exch } def
/BeginOL { dup (all) eq exch TheOL eq or { IfVisible not { Visible
/IfVisible true def } if } { IfVisible { Invisible /IfVisible false def
} if } ifelse } def
/InitOL { /OLUnit [ 3000 3000 matrix defaultmatrix dtransform ] cvx def
/Visible { CP OLUnit idtransform T moveto } def /Invisible { CP OLUnit
neg exch neg exch idtransform T moveto } def /BOL { BeginOL } def
/IfVisible true def } def
end
%-----------------------------------------------------------------------------%

% END pstricks.pro

%%EndProcSet
%%BeginProcSet: pst-algparser.pro 0 0
% $Id: pst-algparser.pro 26 2008-06-14 11:50:02Z herbert $
%%
%% PostScript prologue for PSTricks algorithm parser
%% Version 0.01, 2008/01/01
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%%-----------------------------------------------------------------------------%
%
/AlgParser { tx@AlgToPs begin AlgToPs end } def  % Dominique Rodriguez
%
/tx@CoreAnalyzerDict 100 dict def tx@CoreAnalyzerDict begin
%
% PS ANALYZER FOR ALGEBRAIC EXPRESSION V1.12
% E->T|E+T
% T->FS|T*FS
% FS -> F | +FS | -FS
% F->P|F^SF
% P->(E)|literal
% literal->number|var|var[E]|func(params)
% params->E|E,param
% number->TOBEFINISHED
%
%% E expression, T term, SF signed factor, F factor, P power
%
%% parser
%
%% str
%
%% C->E<condition_operators>E
%% STR index -> STR index+lenExpr
/AnalyzeCond { AnalyzeExpr ReadCondOp AnalyzeExpr EvalCondOp  } def
%
%% analyze Expression List (separator , or | )
%% STR index -> STR index+lenExpr
%% /AnalyzeListOfE {
%%   { NextNonBlankChar pop AnalyzeExpr%%dup Strlen eq { exit } if NextNonBlankChar
%%     NextNonBlankChar dup 0 eq { pop exit } if
%%     dup 44 ne 1 index 124 ne and { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse } if
%%     pop NextNonBlankChar dup 0 eq { exit } if 124 ne { PROBLEMCONTACTBILLOU } if 1 add NextNonBlankChar 0 eq {toto} if } loop
%%   AnalyzeListOfEPostHook
%% } def
/AnalyzeListOfE {
  /NotFirst false def
  { NextNonBlankChar pop AnalyzeExpr
    NotFirst { EvalListOfExpr } { /NotFirst true def } ifelse
    dup Strlen eq { exit } if NextNonBlankChar
    dup 44 ne 1 index 124 ne and
    { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse }
    if  pop 1 add } loop
  AnalyzeListOfEPostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% E->T|E+T
%% STR index -> STR index+lenExpr
/AnalyzeExpr {
  AnalyzePreHook AnalyzeTerm IsEndingExpr
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeTerm PreEvalHook EvalAddSub IsEndingExpr { pop exit } if } loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% T->FS|T*FS
%% STR index
/AnalyzeTerm {
  AnalyzePreHook AnalyzeSignedFactor IsEndingTerm
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor PreEvalHook EvalMulDiv IsEndingTerm { pop exit } if} loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% FS -> F | +FS | -FS
%% STR index
/AnalyzeSignedFactor {
  AnalyzePreHook 2 copy get dup IsUnaryOp
  { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor EvalUnaryOp }
  { pop AnalyzeFactor }
  ifelse AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% F->P|F^P
%% STR index
/AnalyzeFactor {
  AnalyzePreHook AnalyzePower IsEndingFactor
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzePower PreEvalHook EvalPower IsEndingFactor { pop exit } if} loop }
  ifelse  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% P->(E)|literal
%% STR index
/AnalyzePower {
  %% depending of first char either a number, or a literal
  2 copy get dup 40 eq%%an open par
  { pop 1 add NextNonBlankChar pop AnalyzeExpr 1 add NextNonBlankChar pop }
  { AnalyzeLiteral }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index STR[index] -> STR index
%/AnalyzeLiteral { IsNumber { EvalNumber } { EvalLiteral } ifelse } def
/AnalyzeLiteral { dup IsUnaryOp exch IsNumber or { EvalNumber } { EvalLiteral } ifelse } def%%dr 09102006
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% recognize + or -
%% chr -> T/F
/IsUnaryOp { dup 43 eq exch 45 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsNumber { dup 48 ge exch dup 57 le 3 -1 roll and exch 46 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadNumber {
  exch dup 3 -1 roll dup 3 1 roll
  %%read mantissa
  { 1 add  2 copy dup Strlen eq { pop pop 0 exit } if get dup IsNumber not { exit } if pop } loop
  dup 101 eq exch 69 eq or
  %%% there is a "e" or "E" -> read exponant
  { 1 add 2 copy get dup IsUnaryOp
    { pop 1 add 2 copy get } if
    { IsNumber not { exit } if 1 add 2 copy get } loop }
  if
  dup 4 1 roll
  3 -1 roll exch 1 index sub getinterval
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsCondOp { dup 30 eq exch dup 60 ge exch 62 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadCondOp {
  NextNonBlankChar 1 index 4 1 roll
  { IsCondOp not { exit } if 1 add  2 copy get } loop
  2 copy 5 -1 roll
  exch 1 index sub getinterval 3 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can contain only : 0123456789.
%% chr -> T/F
/IsLiteral {%
  dup 48 ge exch dup  57 le 3 -1 roll and exch
  dup 65 ge exch dup  90 le 3 -1 roll and 3 -1 roll or exch
  dup 97 ge exch     122 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can be of the form [a-zA-Z][a-zA-Z0-9]*\(\((Expression)\)|\(\[Expression\]\)\)?
%% STR index -> literal STR index' nextchr
/ReadLiteral {
  exch dup 3 -1 roll dup 3 1 roll
  %%read literal core
  { 2 copy dup Strlen eq { pop pop 0 exit } if get dup IsLiteral not { exit } if pop 1 add } loop
  4 1 roll dup 5 1 roll 3 -1 roll exch 1 index sub getinterval 4 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a clpar
%% STR index -> STR index STR[index] T/F
/IsEndingExpr {%
  2 copy dup Strlen eq
  %% if end of str is reached -> end !
  { pop pop 0 true }
  %% ending chr -> clpar, comma, |, <, >, =, !,
  {get dup  dup  41 eq
       exch dup 124 eq
       exch dup  93 eq
       exch dup  44 eq
       exch dup  30 eq
       exch dup  60 ge exch 62 le and or or or or or}
  ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a +-
%% STR index -> STR index STR[index] T/F
/IsEndingTerm { IsEndingExpr { true } { dup dup 43 eq exch 45 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or */
%% STR index -> STR index STR[index] T/F
/IsEndingFactor { IsEndingTerm { true } { dup dup 42 eq exch 47 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or ^
%% STR index -> STR index STR[index] T/F
/IsEndingPower { IsEndingFactor { true } { dup 94 eq } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index STR[index]
/NextNonBlankChar { { dup Strlen eq { 0 exit } if 2 copy get dup neBlkChar { exit } if pop 1 add } loop } bind def
/neBlkChar { dup 32 ne exch dup 10 ne exch 9 ne and and } bind def
%%%%%%%%%%%%%%%%%%%%%%%%
%% DEBUG
/BRK {false} def
/BRKtrue {/BRK true def} def
/BRKStop {BRK {BRKtoto} if } def
/BRKEvalStop {BRK exch if } def
/BRKBRK2true {BRK {BRK2true} if } def
/BRK2 {false} def
/BRK2true {/BRK2 true def} def
/BRK2Stop {BRK2 {BRK2toto} if } def/BRK {false} def
end
%
%-------------------------------------------------------------------------------%
%
/tx@AlgToPs 12 dict def tx@AlgToPs begin
%
%% algExpr -> PSVector
/AlgToPs { tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE pop pop EndingSequence end } def
/EndingSequence { ExpressionVector aload length /end cvx exch 1 add array astore } def
/InitParser { /ExpressionVector [ /tx@AddMathFunc cvx /begin cvx ] def dup length /Strlen exch def 0 } def
/Strlen 0 def
/EvalListOfExpr {} def%
/EvalNumber {%
    ReadNumber  cvr /ExpressionVector ExpressionVector aload length dup 3 add -1 roll cvx
    exch 1 add array astore def NextNonBlankChar pop } def
/EvalAddSub {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  43 eq { /add } { /sub } ifelse cvx exch 1 add array astore def
} def
/EvalMulDiv {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  42 eq { /mul } { /div } ifelse cvx exch 1 add array astore def
} def
/EvalPower {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  pop /exp cvx exch 1 add array astore def
} def
/EvalLiteral {%
  ReadLiteral
  dup 40 eq%%% there is an open par -> function call
  { pop 2 index
    dup (Sum) eq { EvalSum }
    { dup (IfTE) eq { EvalCond }
      { dup (Derive) eq { pop EvalDerive }
	{ pop 1 add NextNonBlankChar pop AnalyzeListOfE 2 index TrigoFunc
          /ExpressionVector ExpressionVector aload length dup 5 add -1 roll cvn cvx
	  exch 1 add array astore def 1 add NextNonBlankChar pop } ifelse } ifelse} ifelse }
  { /ExpressionVector ExpressionVector aload length dup 6 add -1 roll cvn cvx exch 1 add array astore def
    dup 91 eq%%% there is an open bracket -> vector element
    { pop 1 add NextNonBlankChar pop AnalyzeExpr
      /ExpressionVector ExpressionVector aload length /cvi cvx exch /get cvx exch 2 add array astore def 1 add }
    { pop NextNonBlankChar pop }
    ifelse}
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% the derive function : Derive(n,f(x))
%% firstparindex lastparindex ->
/EvalDerive {
  %% manage the function descripiton
  1 add ReadNumber 3 1 roll NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  1 add NextNonBlankChar pop
  3 -1 roll cvi
  dup 0 eq
  { pop AnalyzeExpr 3 -1 roll pop 1 add }
  { 1 sub 3 1 roll (x)  exch tx@Derive begin DeriveIndexed end 4 -1 roll
    { (x) tx@Derive begin Derive end } repeat
    ExpressionVector exch /ExpressionVector [] def
    AlgToPs aload length
    /ExpressionVector 1 index 3 add -1 roll aload length dup 3 add -1 roll  /l2 exch def /l1 exch def
    l1 l2 add 1 add l2 neg roll l1 l2 add array astore def 3 -1 roll pop 1 add
    1 index length /Strlen exch def } ifelse
} def
/EvalSum {%
  pop 1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  /ExpressionVector ExpressionVector aload length dup 7 add -3 roll 0 4 1 roll
  5 -1 roll 4 add array astore def
  %% keep ExpressionVector for later and create a new one for internal Sum computation
  ExpressionVector 3 1 roll /ExpressionVector [ 6 -1 roll cvn /exch cvx /def cvx ] def
  1 add NextNonBlankChar pop AnalyzeExpr
  %% add each term
  /ExpressionVector ExpressionVector aload length 1 add /add cvx exch array astore def
  /ExpressionVector 4 -1 roll aload length ExpressionVector cvx /for cvx 3 -1 roll 2 add
  array astore def 3 -1 roll pop 1 add
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length Pi /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
/EvalCond {%
  pop 1 add AnalyzeCond NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  ExpressionVector 3 1 roll /ExpressionVector [] def
  1 add AnalyzeExpr ExpressionVector 3 1 roll /ExpressionVector [] def
  NextNonBlankChar 44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add AnalyzeExpr
  NextNonBlankChar 41 ne { ANALYZER_ERROR_missing_ending parenthesis_in_IfTE } if
  ExpressionVector
  /ExpressionVector 6 -1 roll aload length dup
  6 add -1 roll cvx exch dup 4 add -1 roll cvx /ifelse cvx 3 -1 roll 3 add array astore def
  1 add 3 -1 roll pop
} def
%% CondOp STR index
/EvalCondOp {%
  3 -1 roll
  dup (=) eq  { /eq } {%
  dup (<) eq  { /lt } {%
  dup (>) eq  { /gt } {%
  dup (>=) eq { /ge } {%
  dup (<=) eq { /ge } {%
  dup (!=) eq { /ne } { ERROR_non_valid_conditional_operator }
  ifelse } ifelse } ifelse } ifelse } ifelse } ifelse
  cvx exch pop
  /ExpressionVector ExpressionVector aload length dup 3 add -1 roll exch 1 add array astore def } def
/EvalUnaryOp {
  3 -1 roll 45 eq { /ExpressionVector ExpressionVector aload length /neg cvx exch 1 add array astore def } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook {} bind def
/PreEvalHook {} bind def
/AnalyzeListOfEPostHook {} bind def
/AnalyzePostHook {} def
/RollOp { 3 1 roll } bind def
end   %tx@CoreAnalyzerDict
%
%--------------------------------------------------------------------%
%
/tx@Derive 41 dict def tx@Derive begin
%%increase ^^ for each function added
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable -> PSVector
/Derive {%
  10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE end
} def
/Strlen 0 def
/InitParser { dup length /Strlen exch def 0 } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable index -> PSVector
/DeriveIndexed {%
  3 1 roll 10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser pop 4 -1 roll AnalyzeExpr 4 -2 roll pop pop 4 -2 roll exch pop end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u,v)'=-(u',v')
/EvalListOfExpr {%
  4 2 roll 2 copy 9 -1 roll dup length 4 1 roll putinterval add AddPipe
           2 copy 7 -1 roll dup length 4 1 roll putinterval add
  6 -2 roll pop pop
  2 copy pop 0 6 2 roll GetIntervalNewStr 5 1 roll 2 copy 0 exch getinterval 6 1 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (-u)'=-(u')
/EvalUnaryOp {
  4 -2 roll 4 index (0) eq
  { (0) StrConcat 7 -1 roll pop }
  { 7 -1 roll 45 eq
    { AddSub AddOpPar true } { false } ifelse
    3 1 roll 5 index StrConcat 3 -1 roll { AddClPar } if } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  7 -2 roll pop pop 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (number)'=0
/EvalNumber { ReadNumber (0) 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u+v)'=u'+v'
/EvalAddSub {%
  7 index dup (0) eq
  { pop true }%% du=0 nothing added
  { dup length exch 5 index 5 index 3 -1 roll putinterval 4 -1 roll add 3 1 roll false }
  ifelse
  5 index dup (0) eq
  { pop { (0) } { 4 -2 roll 2 copy pop 0  6 2 roll GetIntervalNewStr } ifelse }%%dv=0
  { exch
    { 5 -2 roll 7 index 45 eq { AddSub } if false } %%nothing yet added
    { 5 -2 roll 7 index 43 eq%%something yet added
      { AddAdd false } { AddSub AddOpPar true } ifelse }
    ifelse 11 1 roll
    3 -1 roll StrConcat 10 -1 roll { AddClPar } if
    2 copy pop 0 6 2 roll GetIntervalNewStr }
  ifelse
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)' or (u/v)'
/EvalMulDiv { 6 index 42 eq {EvalMul} {EvalDiv} ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)'=u'*v+u*v'
/EvalMul {%
  4 -2 roll 7 index dup (0) eq
  { pop false }%%du=0
  { (1) eq%%du=1
    { false }
    { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
    3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if
    true }%%du!=0
  ifelse
  5 1 roll 5 index (0) eq
  { 5 -1 roll not { (0) StrConcat } if }%%dv=0
  { 5 -1 roll { AddAdd } if
    4 index (1) eq
    { 8 index StrConcat }
    { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
    ifelse
  }%%dv!=0
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u/v)'=(u'*v-u*v')/v^2
/EvalDiv {%
  4 -2 roll
  4 index (0) eq%%dv=0 -> u'/v
  { 7 index (0) eq { (0) StrConcat } { AddOpPar 7 index StrConcat AddClPar AddDiv 5 index StrConcat } ifelse }
  { 7 index dup (0) eq
    { pop }%%du=0
    { (1) eq%%du=1
      { false }
      { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
      3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if}%%du!=0
    ifelse
      AddSub
      4 index (1) eq
      { 8 index StrConcat }
      { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
      ifelse
    %}%%dv!=0
    2 copy GetIntervalNewStr 3 1 roll pop 0 AddOpPar 3 -1 roll StrConcat AddClPar
    AddDiv AddOpPar 5 index StrConcat AddClPar 2 copy (^2) putinterval 2 add }
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str1 index str2 -> str1 index
/StrConcat { dup length 4 2 roll 2 copy 6 -1 roll putinterval 3 -1 roll add } bind def
/GetIntervalNewStr { 0 exch getinterval dup length string copy } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u^v)'=(u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
/EvalPower {%
  4 -2 roll 7 index (0) eq
  {%%if du=0 then (u^v)'=v'ln(u)u^v
    4 index (0) eq
    { (0) StrConcat }%%if dv=0 then (u^v)'=0
    { 4 index (1) ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if
      8 index (e) ne { (ln\() StrConcat 8 index StrConcat (\)*) StrConcat } if
      AddOpPar 8 index StrConcat (\)^\() StrConcat 5 index StrConcat AddClPar } ifelse
  }
  {%%du!=0
    4 index (0) eq
    {%%if dv=0 then (u^v)'=vu'u^(v-1)
      5 index dup IsStrNumber
      { dup (0) eq
        { StrConcat }
        { dup dup (1) eq exch (1.0) eq or
          { StrConcat  }
	  { StrConcat
	    7 index dup (1) ne exch (1.0) ne and%%%dr 09102006 insert du if <> 1
	    { (*\() StrConcat 7 index StrConcat (\)) StrConcat } if%%%dr 09102006
            (*\() StrConcat 8 index StrConcat (\)) StrConcat
            5 index  dup dup (2) eq exch (2.0) eq or
	    { pop } { cvr 1 sub 20 string cvs 3 1 roll (^) StrConcat 3 -1 roll StrConcat } ifelse } ifelse } ifelse }
      { pop AddOpPar 5 index StrConcat (\)*\() StrConcat 8 index StrConcat (\)^\() StrConcat
        5 index StrConcat (-1\)) StrConcat } ifelse
    }
    {%%if dv!=0 and du!=0 then (u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
      7 index (1) ne { AddOpPar 7 index StrConcat (\)*) StrConcat } if
      AddOpPar 5 index StrConcat (\)*\() StrConcat
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (-1\)+\() StrConcat
      4 index (1) ne { 4 index StrConcat (\)*\() StrConcat } if
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (\)*ln\() StrConcat
      8 index StrConcat AddClPar
    } ifelse
  } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str -> true/false
/IsStrNumber {%
  true exch
  { dup 48 lt exch dup 57 gt 3 -1 roll or
    exch dup 46 ne%%.
    exch dup 43 ne%%+
    exch 45 ne%%-
    and and and { pop false } if } forall
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalLiteral {%
  ReadLiteral dup 40 eq%%% there is an open par -> function call
  { pop (EvalFunc_             ) 9 4 index StrConcat 0 exch getinterval cvn cvx exec }
  { dup 91 eq%%% there is an open bracket -> vector element
    { ERROR_vector_not_yet_implemented }
    { pop EvalVariable }
    ifelse }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% first last parpos Expr[first:parpos-1] ->
/EvalVariable { 2 index Variable eq { (1) } { (0) } ifelse 4 -1 roll exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (f(u))'=u'f'(u)
/EvalFunc {
  4 2 roll 4 index (1) ne
  { AddOpPar 4 index StrConcat (\)*) StrConcat } if
  (Eval             ) 4 8 index StrConcat 0 exch getinterval cvn cvx exec
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Func derivative -> Eval<func>
/EvalFunc_sin {%
  PreCommonFunc
  { (cos\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_cos {%
  PreCommonFunc
  { (\(-sin\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_tan {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/cos\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_asin {%
  PreCommonFunc
  { (1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_acos {%
  PreCommonFunc
  { (-1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_atg {%
  PreCommonFunc
  { (1/\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_ln {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_exp {%
  PreCommonFunc
  {  (exp\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_sqrt {%
  PreCommonFunc
  { dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\(2*sqrt\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Fact {%
  PreCommonFunc { ERROR_no_variable_expression_in_Fact } if
  PostCommonFunc } def
/EvalFunc_sh {%
  PreCommonFunc
  { (ch\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_ch {%
  PreCommonFunc
  { (sh\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_th {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/ch\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argsh {%
  PreCommonFunc
  { (1/sqrt\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argch {%
  PreCommonFunc
  { (1/sqrt\(\() StrConcat 5 index StrConcat (\)^2-1\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argth {%
  PreCommonFunc
  { (1/\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/PreCommonFunc {
  1 add NextNonBlankChar pop 3 -1 roll 5 1 roll AnalyzeExpr 1 add NextNonBlankChar pop
  4 2 roll 4 index (0) eq
  { (0) StrConcat false }
  { 4 index (1)  ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if true } ifelse
} def
/PostCommonFunc {
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
/EvalFunc_Derive {%
  1 add ReadNumber cvi 1 add dup cvr log 1 add cvi string cvs
  4 -1 roll pop 5 1 roll 1 add NextNonBlankChar pop AnalyzeExpr 1 add
  4 -2 roll (Derive\() StrConcat 7 -1 roll StrConcat (,) StrConcat 6 -1 roll StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr 6 -1 roll pop 2 index 6 index dup 4 index exch sub getinterval
  exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_Sum {%
  1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop 3 -1 roll pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_third_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_fourth_comma_in_Sum } if
  1 add NextNonBlankChar pop dup 6 1 roll 3 -1 roll pop AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 8 index dup 9 index exch sub getinterval StrConcat
  4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_IfTE {%
  3 -1 roll pop 1 add NextNonBlankChar pop SkipCond
  NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  1 add NextNonBlankChar pop dup 5 1 roll
  AnalyzeExpr NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add NextNonBlankChar pop
  AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 10 index dup 11 index exch sub getinterval StrConcat
  6 index StrConcat (,) StrConcat 4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% advance in str until a comma is found (no error detection!)
%% str index -> str index'
/SkipCond { { 1 add 2 copy get 44 eq {exit } if } loop } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length Pi /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for condition....
/EvalCondOp { 3 -1 roll pop } bind def
/PutIntervalOneAdd {putinterval 1 add} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddOpPar {2 copy (\() PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add close parenthesis in string at the given index
%% str index -> str index+1
/AddClPar {2 copy (\)) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add 0 in string at the given index
%% str index -> str index+1
/AddZero {2 copy (0) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddMul {2 copy (*) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddDiv {2 copy (/) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a plus sign in string at the given index
%% str index -> str index+1
/AddAdd {2 copy (+) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a minus sign in string at the given index
%% str index -> str index+1
/AddSub {2 copy (-) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a pipe sign in string at the given index
%% str index -> str index+1
/AddPipe {2 copy (|) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook { dup 5 1 roll } bind def
/PreEvalHook {} def
/AnalyzePostHook { 7 -1 roll pop } bind def
/AnalyzeListOfEPostHook { 6 -1 roll mark 6 1 roll cleartomark } bind def
/RollOp { 5 1 roll } bind def
end%%%tx@CoreAnalyzerDict
/tx@AddMathFunc 12 dict def tx@AddMathFunc begin
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% NEW FUNC
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% function arcsine in radians asin(x)=atan(x/sqrt(1-x^2))
%% x -> theta
/asin {%
  dup abs 1 gt { EQDFasinrangeerror  } if
  dup dup dup mul 1 exch sub sqrt atan exch 0 lt { 360 sub } if DegtoRad
} def
%% function arccosine in radians acos(x)=atan(sqrt(1-x^2)/x)
%% x -> theta
/acos {%
  dup abs 1 gt { EQDFacosrangeerror  } if
  dup dup mul 1 exch sub sqrt exch atan DegtoRad
} def
%% function arctangent in radians
%% x -> theta
/atg { 1 atan dup 90 gt { 360 sub } if DegtoRad } bind def
%% HYPERBOLIC FUNCTIONS
/sh { dup Ex exch neg Ex sub 2 div } def
/ch { dup Ex exch neg Ex add 2 div } def
/th { dup sh exch ch div } def
/Argsh { dup dup mul 1 add sqrt add ln } def
/Argch { dup dup mul 1 sub sqrt add ln } def
/Argth { dup 1 add exch 1 exch sub div ln 2 div } def
%% modified exponential funtion for 0
%% x n -> x^n
/Exp { dup 0 eq { pop pop 1 } { exp } ifelse } bind def
%% modified exponential funtion for 0
%% x -> e^x
/Ex { Euler exch exp } bind def
%%
%% factorial function
%% n -> n!
/Fact { 1 exch 2 exch 1 exch { mul } for } bind def
/fact { Fact } bind def
end

% END pstricks.pro

%%EndProcSet
%%BeginProcSet: pst-dots.pro 0 0
% $Id: pst-dots.pro 26 2008-06-14 11:50:02Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 2.02,  2008/04/18
%%
%% For distribution, see pstricks.tex.
%%
%% Timothy Van Zandt <tvz@Princeton.EDU>
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%% Modified by Etienne Riga  - Dec. 16, 1999
%% Modified by Etienne Riga  - 2005/01/01 (er)
%% to add /Diamond, /SolidDiamond and /BoldDiamond
%% Modified by Herbert Voss (hv) - 2008/04/17 
%
10 dict dup begin			% hold local
  /FontType 3 def
  /FontMatrix [.001 0 0 .001 0 0] def
  /FontBBox [-571.5 -742.5 571.5 742.5] def
%  /FontBBox [-1000 -1000 1000 1000] def  % See end of file in /BuildGlyph
  /Encoding 256 array def
  0 1 255 {Encoding exch /.notdef put} for % fill the array with /.notdef
  Encoding				   % replace with given dot names
    dup (b) 0 get /Bullet put		   % get the numerical position of b in ASCII
%					   % and save /Bullet at this place in Encoding 
    dup (c) 0 get /Circle put
    dup (C) 0 get /BoldCircle put	% 67
    dup (u) 0 get /SolidTriangle put
    dup (t) 0 get /Triangle put
    dup (T) 0 get /BoldTriangle put
    dup (r) 0 get /SolidSquare put
    dup (s) 0 get /Square put
    dup (S) 0 get /BoldSquare put
    dup (q) 0 get /SolidPentagon put
    dup (p) 0 get /Pentagon put
    dup (P) 0 get /BoldPentagon put
%%%		  
    dup (k) 0 get /Asterisk put
    dup (K) 0 get /BoldAsterisk put
    dup (J) 0 get /SolidAsterisk put
    dup (h) 0 get /Hexagon put
    dup (H) 0 get /BoldHexagon put
    dup (G) 0 get /SolidHexagon put
    dup (f) 0 get /Octogon put		% 2008-04-18 hv
    dup (F) 0 get /BoldOctogon put	% 2008-04-18 hv
    dup (g) 0 get /SolidOctogon put	% 2008-04-18 hv
    dup (a) 0 get /Add put
    dup (A) 0 get /BoldAdd put 		% 65
    dup (x) 0 get /Mul put
    dup (X) 0 get /BoldMul put
    dup (m) 0 get /Oplus put
    dup (M) 0 get /BOplus put
    dup (e) 0 get /SolidOplus put
    dup (n) 0 get /Otimes put
    dup (N) 0 get /BOtimes put
    dup (E) 0 get /SolidOtimes put
    dup (i) 0 get /Bar put
    dup (I) 0 get /BoldBar put
    dup (l) 0 get /SolidDiamond put
    dup (d) 0 get /Diamond put
        (D) 0 get /BoldDiamond put
%%%  
/CharProcs 47 dict def
CharProcs begin
  /CirclePath {0 0 500 0 360 arc closepath} def
  /Bullet {CirclePath fill} def
  /Circle {CirclePath .9 .9 scale CirclePath eofill} def
  /BoldCircle {CirclePath .8 .8 scale CirclePath eofill} def
  /TrianglePath {0 660 moveto -571.5 -330 lineto 571.5 -330 lineto closepath} def
  /SolidTriangle {TrianglePath fill} def
  /Triangle {TrianglePath .85 .85 scale TrianglePath eofill} def
  /BoldTriangle {TrianglePath .7 .7 scale TrianglePath eofill} def
  /SquarePath {-450 450 moveto 450 450 lineto 450 -450 lineto -450 -450 lineto closepath} def
  /SolidSquare {SquarePath fill} def
  /Square {SquarePath .89 .89 scale SquarePath eofill} def
  /BoldSquare {SquarePath .78 .78 scale SquarePath eofill} def
  /PentagonPath {
    -337.8 -465 moveto 337.8 -465 lineto 546.6 177.6 lineto
    0 574.7 lineto -546.6 177.6 lineto closepath
  } def
  /SolidPentagon {PentagonPath fill} def
  /Pentagon {PentagonPath .89 .89 scale PentagonPath eofill} def
  /BoldPentagon {PentagonPath .78 .78 scale PentagonPath eofill} def
%-------------- hv begin 2004/07/25   from: er 2003/03/24
  /HexagonPath {
    0 550 moveto -476 275 lineto -476 -275 lineto
    0 -550 lineto 476 -275 lineto 476 275 lineto closepath
  } def
  /SolidHexagon {HexagonPath fill} def
  /Hexagon {HexagonPath .89 .89 scale HexagonPath eofill} def
  /BoldHexagon {HexagonPath .79 .79 scale HexagonPath eofill} def
%					2008-04-18 hv
  /OctogonPath { 
     550 dup 22.5 tan mul dup neg dup add /xMove exch def 
     exch moveto 7 { xMove 0 rlineto 45 rotate } repeat closepath } def 
  /SolidOctogon { OctogonPath fill                             } def
  /Octogon {      OctogonPath .89 .89 scale OctogonPath eofill } def
  /BoldOctogon {  OctogonPath .79 .79 scale OctogonPath eofill } def
%
  /AsteriskPath {
    20 0 moveto 10 250 180 500 0 500 curveto
    -180 500 -10 250 -20 0 curveto closepath
  } def
  /Asterisk {
    AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath
    60 rotate AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath fill
  } def
%
  /Basterp {50 250 220 500 0 500 curveto -220 500 -50 250 -50 30 cos 100 mul curveto} def
  /BoldAsteriskPath {
    50 30 cos 100 mul moveto  Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp closepath
  } def
  /BoldAsterisk {BoldAsteriskPath fill} def
  /SolidAsterisk {CirclePath .9 .9 scale BoldAsteriskPath eofill} def
  /CrossPath {
    40 550 moveto -40 550 lineto -40 40 lineto -550 40 lineto
    -550 -40 lineto -40 -40 lineto -40 -550 lineto 40 -550 lineto 
    40 -40 lineto 550 -40 lineto 550 40 lineto 40 40 lineto closepath
  } def
  /BoldCrossPath {80 550 moveto -80 550 lineto -80 80 lineto -550 80 lineto
    -550 -80 lineto -80 -80 lineto -80 -550 lineto 80 -550 lineto 
    80 -80 lineto 550 -80 lineto 550 80 lineto 80 80 lineto closepath
  } def
  /Add {CrossPath fill} def
  /Mul {45 rotate CrossPath fill} def
  /BoldAdd {BoldCrossPath fill} def
  /BoldMul {45 rotate BoldCrossPath fill} def
  /Oplus {CirclePath .9 .9 scale CirclePath eofill .775 .775 scale CrossPath fill } def 
  /SolidOplus {CirclePath .775 .775 scale BoldCrossPath eofill} def 
  /BOplus {CirclePath .8 .8 scale CirclePath eofill .775 .775 scale BoldCrossPath fill} def 
  /Otimes {CirclePath .9 .9 scale CirclePath eofill 45 rotate .775 .775 scale CrossPath fill} def 
  /BOtimes {CirclePath .8 .8 scale CirclePath eofill 45 rotate .775 .775 scale BoldCrossPath fill } def 
  /SolidOtimes {CirclePath 45 rotate .775 .775 scale BoldCrossPath eofill} def 
  /BarPath {40 660 moveto -40 660 lineto -40 -660 lineto 40 -660 lineto closepath} def
  /Bar {BarPath fill} def
  /BoldBarPath {80 660 moveto -80 660 lineto -80 -660 lineto 80 -660 lineto closepath} def
  /BoldBar {BoldBarPath fill} def
  /DiamondPath {0 742.5 moveto -428.5 0 lineto 0 -742.5 lineto 428.5 0 lineto closepath} def
  /SolidDiamond {DiamondPath fill} def
  /Diamond {DiamondPath .865 .865 scale DiamondPath eofill} def
  /BoldDiamond {DiamondPath .73 .73 scale DiamondPath eofill} def
%%%
  /.notdef { } def
end
%
/BuildGlyph {
  exch
  begin 		
%  Metrics 1 index get exec 0
    0 0
%      BBoxes 3 index get exec
    -1000 -1000 1000 1000
%     -571.5 -742.5 571.5 742.5
    setcachedevice
    CharProcs begin load exec end
  end
} def
%
/BuildChar {
  1 index /Encoding get exch get
  1 index /BuildGlyph get exec
} bind def

end
/PSTricksDotFont exch definefont pop

%% end

%%EndProcSet
%%BeginProcSet: pst-node.pro 0 0
% $Id: pst-node.pro 26 2008-06-14 11:50:02Z herbert $
%%
%% PostScript prologue for pst-node.tex.
%% Version 1.00, 2008/01/01.
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
/tx@NodeDict 400 dict def tx@NodeDict begin
tx@Dict begin 			% from main pstricks dict
 /T /translate load def 
end
/NewNode { % on stack: { x y } boolean N@name type InitXnode 
  gsave 
  /next ED 			% { x y } boolean N@name type  
  dict dup 			% { x y } boolean N@name dict dict
  3 1 roll def 			% { x y } boolean dict N@name dict def
  exch { dup 3 1 roll def } if  % { x y } dict boolean
  begin 			% { x y } dict begin
  tx@Dict begin 
    STV CP T exec 		% set scaling
  end 
  /NodeMtrx CM def 		% save CM
  next 				% InitXNode
  end
  grestore 
} def
%
/InitPnode { 
  /Y ED /X ED 
  /NodePos { NodeSep Cos mul NodeSep Sin mul } def
} def
%
/InitCnode { 
  /r ED /Y ED /X ED 
  /NodePos { NodeSep r add dup Cos mul exch Sin mul } def 
} def
%
/GetRnodePos { 
  Cos 0 gt { /dx r NodeSep add def } { /dx l NodeSep sub def } ifelse 
  Sin 0 gt { /dy u NodeSep add def } { /dy d NodeSep sub def } ifelse 
  dx Sin mul abs dy 
  Cos mul abs gt { dy Cos mul Sin div dy } { dx dup Sin mul Cos Div } ifelse 
} def
%
/InitRnode { 
  /Y ED /X ED X sub /r ED /l X neg def Y add neg /d ED Y sub /u ED 
  /NodePos { GetRnodePos } def 
} def
%
/DiaNodePos { 
  w h mul w Sin mul abs h Cos mul abs add Div NodeSep add dup
  Cos mul exch Sin mul 
} def
%
/TriNodePos { Sin s lt { d NodeSep sub dup Cos mul Sin Div exch } { w h
mul w Sin mul h Cos abs mul add Div NodeSep add dup Cos mul exch Sin mul
} ifelse } def
/InitTriNode { sub 2 div exch 2 div exch 2 copy T 2 copy 4 index index /d
ED pop pop pop pop -90 mul rotate /NodeMtrx CM def /X 0 def /Y 0 def d
sub abs neg /d ED d add /h ED 2 div h mul h d sub Div /w ED /s d w Atan
sin def /NodePos { TriNodePos } def } def
/OvalNodePos { /ww w NodeSep add def /hh h NodeSep add def Sin ww mul Cos
hh mul Atan dup cos ww mul exch sin hh mul } def
/GetCenter { begin X Y NodeMtrx transform CM itransform end } def
%
/XYPos { dup sin exch cos Do /Cos ED /Sin ED /Dist ED Cos 0 gt { Dist
  Dist Sin mul Cos div } { Cos 0 lt { Dist neg Dist Sin mul Cos div neg }
  { 0 Dist Sin mul } ifelse } ifelse Do 
} def
/GetEdge { dup 0 eq { pop begin 1 0 NodeMtrx dtransform CM idtransform
  exch atan sub dup sin /Sin ED cos /Cos ED /NodeSep ED NodePos NodeMtrx
  dtransform CM idtransform end } { 1 eq {{exch}} {{}} ifelse /Do ED pop
  XYPos } ifelse 
} def
/AddOffset { 1 index 0 eq { pop pop } { 2 copy 5 2 roll cos mul add 4 1
roll sin mul sub exch } ifelse } def
/GetEdgeA { NodeSepA AngleA NodeA NodeSepTypeA GetEdge OffsetA AngleA
AddOffset yA add /yA1 ED xA add /xA1 ED } def
/GetEdgeB { NodeSepB AngleB NodeB NodeSepTypeB GetEdge OffsetB AngleB
AddOffset yB add /yB1 ED xB add /xB1 ED } def
/GetArmA { ArmTypeA 0 eq { /xA2 ArmA AngleA cos mul xA1 add def /yA2 ArmA
AngleA sin mul yA1 add def } { ArmTypeA 1 eq {{exch}} {{}} ifelse /Do ED
ArmA AngleA XYPos OffsetA AngleA AddOffset yA add /yA2 ED xA add /xA2 ED
} ifelse } def
/GetArmB { ArmTypeB 0 eq { /xB2 ArmB AngleB cos mul xB1 add def /yB2 ArmB
AngleB sin mul yB1 add def } { ArmTypeB 1 eq {{exch}} {{}} ifelse /Do ED
ArmB AngleB XYPos OffsetB AngleB AddOffset yB add /yB2 ED xB add /xB2 ED
} ifelse } def
/InitNC { 
  /b ED /a ED % second and first node
  /NodeSepTypeB ED /NodeSepTypeA ED 
  /NodeSepB ED /NodeSepA ED 
  /OffsetB ED /OffsetA ED 
  tx@NodeDict a known tx@NodeDict b known and dup { 
    /NodeA a load def 
    /NodeB b load def 
    NodeA GetCenter /yA ED /xA ED 
    NodeB GetCenter /yB ED /xB ED } if 
} def
%
/LPutLine { 4 copy 3 -1 roll sub neg 3 1 roll sub Atan /NAngle ED 1 t sub
mul 3 1 roll 1 t sub mul 4 1 roll t mul add /Y ED t mul add /X ED } def
/LPutLines { mark LPutVar counttomark 2 div 1 sub /n ED t floor dup n gt
{ pop n 1 sub /t 1 def } { dup t sub neg /t ED } ifelse cvi 2 mul { pop
} repeat LPutLine cleartomark } def
/BezierMidpoint { /y3 ED /x3 ED /y2 ED /x2 ED /y1 ED /x1 ED /y0 ED /x0 ED
/t ED /cx x1 x0 sub 3 mul def /cy y1 y0 sub 3 mul def /bx x2 x1 sub 3
mul cx sub def /by y2 y1 sub 3 mul cy sub def /ax x3 x0 sub cx sub bx
sub def /ay y3 y0 sub cy sub by sub def ax t 3 exp mul bx t t mul mul
add cx t mul add x0 add ay t 3 exp mul by t t mul mul add cy t mul add
y0 add 3 ay t t mul mul mul 2 by t mul mul add cy add 3 ax t t mul mul
mul 2 bx t mul mul add cx add atan /NAngle ED /Y ED /X ED } def
/HPosBegin { yB yA ge { /t 1 t sub def } if /Y yB yA sub t mul yA add def
} def
/HPosEnd { /X Y yyA sub yyB yyA sub Div xxB xxA sub mul xxA add def
/NAngle yyB yyA sub xxB xxA sub Atan def } def
/HPutLine { HPosBegin /yyA ED /xxA ED /yyB ED /xxB ED HPosEnd  } def
/HPutLines { HPosBegin yB yA ge { /check { le } def } { /check { ge } def
} ifelse /xxA xA def /yyA yA def mark xB yB LPutVar { dup Y check { exit
} { /yyA ED /xxA ED } ifelse } loop /yyB ED /xxB ED cleartomark HPosEnd 
} def
/VPosBegin { xB xA lt { /t 1 t sub def } if /X xB xA sub t mul xA add def
} def
/VPosEnd { /Y X xxA sub xxB xxA sub Div yyB yyA sub mul yyA add def
/NAngle yyB yyA sub xxB xxA sub Atan def } def
/VPutLine { VPosBegin /yyA ED /xxA ED /yyB ED /xxB ED VPosEnd  } def
/VPutLines { VPosBegin xB xA ge { /check { le } def } { /check { ge } def
} ifelse /xxA xA def /yyA yA def mark xB yB LPutVar { 1 index X check {
exit } { /yyA ED /xxA ED } ifelse } loop /yyB ED /xxB ED cleartomark
VPosEnd  } def
/HPutCurve { gsave newpath /SaveLPutVar /LPutVar load def LPutVar 8 -2
roll moveto curveto flattenpath /LPutVar [ {} {} {} {} pathforall ] cvx
def grestore exec /LPutVar /SaveLPutVar load def } def
/NCCoor { /AngleA yB yA sub xB xA sub Atan def /AngleB AngleA 180 add def
GetEdgeA GetEdgeB /LPutVar [ xB1 yB1 xA1 yA1 ] cvx def /LPutPos {
LPutVar LPutLine } def /HPutPos { LPutVar HPutLine } def /VPutPos {
LPutVar VPutLine } def LPutVar } def
/NCLine { NCCoor tx@Dict begin ArrowA CP 4 2 roll ArrowB lineto pop pop
end } def
/NCLines { false NArray n 0 eq { NCLine } { 2 copy yA sub exch xA sub
Atan /AngleA ED n 2 mul dup index exch index yB sub exch xB sub Atan
/AngleB ED GetEdgeA GetEdgeB /LPutVar [ xB1 yB1 n 2 mul 4 add 4 roll xA1
yA1 ] cvx def mark LPutVar tx@Dict begin false Line end /LPutPos {
LPutLines } def /HPutPos { HPutLines } def /VPutPos { VPutLines } def }
ifelse } def
/NCCurve { GetEdgeA GetEdgeB xA1 xB1 sub yA1 yB1 sub Pyth 2 div dup 3 -1
roll mul /ArmA ED mul /ArmB ED /ArmTypeA 0 def /ArmTypeB 0 def GetArmA
GetArmB xA2 yA2 xA1 yA1 tx@Dict begin ArrowA end xB2 yB2 xB1 yB1 tx@Dict
begin ArrowB end curveto /LPutVar [ xA1 yA1 xA2 yA2 xB2 yB2 xB1 yB1 ]
cvx def /LPutPos { t LPutVar BezierMidpoint } def /HPutPos { { HPutLines
} HPutCurve } def /VPutPos { { VPutLines } HPutCurve } def } def
%
/NCAngles { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def 
  xA2 yA2 mtrx transform pop 
  xB2 yB2 mtrx transform exch pop 
  mtrx itransform 
  /y0 ED /x0 ED 
  mark ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 x0 y0 xA2 yA2 
  ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 x0 y0 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def } def
%
/NCAngle { GetEdgeA GetEdgeB GetArmB /mtrx AngleA matrix rotate def xB2
yB2 mtrx itransform pop xA1 yA1 mtrx itransform exch pop mtrx transform
/y0 ED /x0 ED mark ArmB 0 ne { xB1 yB1 } if xB2 yB2 x0 y0 xA1 yA1
tx@Dict begin false Line end /LPutVar [ xB1 yB1 xB2 yB2 x0 y0 xA1 yA1 ]
cvx def /LPutPos { LPutLines } def /HPutPos { HPutLines } def /VPutPos {
VPutLines } def } def
/NCBar { GetEdgeA GetEdgeB GetArmA GetArmB /mtrx AngleA matrix rotate def
xA2 yA2 mtrx itransform pop xB2 yB2 mtrx itransform pop sub dup 0 mtrx
transform 3 -1 roll 0 gt { /yB2 exch yB2 add def /xB2 exch xB2 add def }
{ /yA2 exch neg yA2 add def /xA2 exch neg xA2 add def } ifelse mark ArmB
0 ne { xB1 yB1 } if xB2 yB2 xA2 yA2 ArmA 0 ne { xA1 yA1 } if tx@Dict
begin false Line end /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx
def /LPutPos { LPutLines } def /HPutPos { HPutLines } def /VPutPos {
VPutLines } def } def
/NCDiag { GetEdgeA GetEdgeB GetArmA GetArmB mark ArmB 0 ne { xB1 yB1 } if
xB2 yB2 xA2 yA2 ArmA 0 ne { xA1 yA1 } if tx@Dict begin false Line end
/LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def /LPutPos {
LPutLines } def /HPutPos { HPutLines } def /VPutPos { VPutLines } def }
def
/NCDiagg { GetEdgeA GetArmA yB yA2 sub xB xA2 sub Atan 180 add /AngleB ED
GetEdgeB mark xB1 yB1 xA2 yA2 ArmA 0 ne { xA1 yA1 } if tx@Dict begin
false Line end /LPutVar [ xB1 yB1 xA2 yA2 xA1 yA1 ] cvx def /LPutPos {
LPutLines } def /HPutPos { HPutLines } def /VPutPos { VPutLines } def }
def
/NCLoop { GetEdgeA GetEdgeB GetArmA GetArmB /mtrx AngleA matrix rotate
def xA2 yA2 mtrx transform loopsize add /yA3 ED /xA3 ED /xB3 xB2 yB2
mtrx transform pop def xB3 yA3 mtrx itransform /yB3 ED /xB3 ED xA3 yA3
mtrx itransform /yA3 ED /xA3 ED mark ArmB 0 ne { xB1 yB1 } if xB2 yB2
xB3 yB3 xA3 yA3 xA2 yA2 ArmA 0 ne { xA1 yA1 } if tx@Dict begin false
Line end /LPutVar [ xB1 yB1 xB2 yB2 xB3 yB3 xA3 yA3 xA2 yA2 xA1 yA1 ]
cvx def /LPutPos { LPutLines } def /HPutPos { HPutLines } def /VPutPos {
VPutLines } def } def
% DG/SR modification begin - May 9, 1997 - Patch 1
%/NCCircle { 0 0 NodesepA nodeA \tx@GetEdge pop xA sub 2 div dup 2 exp r
%r mul sub abs sqrt atan 2 mul /a ED r AngleA 90 add PtoC yA add exch xA add
%exch 2 copy /LPutVar [ 4 2 roll r AngleA ] cvx def /LPutPos { LPutVar t 360
%mul add dup 5 1 roll 90 sub \tx@PtoC 3 -1 roll add /Y ED add /X ED /NAngle ED
/NCCircle { NodeSepA 0 NodeA 0 GetEdge pop 2 div dup 2 exp r
r mul sub abs sqrt atan 2 mul /a ED r AngleA 90 add PtoC yA add exch xA add
exch 2 copy /LPutVar [ 4 2 roll r AngleA ] cvx def /LPutPos { LPutVar t 360
mul add dup 5 1 roll 90 sub PtoC 3 -1 roll add /Y ED add /X ED /NAngle ED
% DG/SR modification end
} def /HPutPos { LPutPos } def /VPutPos { LPutPos } def r AngleA 90 sub a add
AngleA 270 add a sub tx@Dict begin /angleB ED /angleA ED /r ED /c 57.2957 r
Div def /y ED /x ED } def
/NCBox { /d ED /h ED /AngleB yB yA sub xB xA sub Atan def /AngleA AngleB
180 add def GetEdgeA GetEdgeB /dx d AngleB sin mul def /dy d AngleB cos
mul neg def /hx h AngleB sin mul neg def /hy h AngleB cos mul def
/LPutVar [ xA1 hx add yA1 hy add xB1 hx add yB1 hy add xB1 dx add yB1 dy
add xA1 dx add yA1 dy add ] cvx def /LPutPos { LPutLines } def /HPutPos
{ xB yB xA yA LPutLine } def /VPutPos { HPutPos } def mark LPutVar
tx@Dict begin false Polygon end } def
/NCArcBox { /l ED neg /d ED /h ED /a ED /AngleA yB yA sub xB xA sub Atan
def /AngleB AngleA 180 add def /tA AngleA a sub 90 add def /tB tA a 2
mul add def /r xB xA sub tA cos tB cos sub Div dup 0 eq { pop 1 } if def
/x0 xA r tA cos mul add def /y0 yA r tA sin mul add def /c 57.2958 r div
def /AngleA AngleA a sub 180 add def /AngleB AngleB a add 180 add def
GetEdgeA GetEdgeB /AngleA tA 180 add yA yA1 sub xA xA1 sub Pyth c mul
sub def /AngleB tB 180 add yB yB1 sub xB xB1 sub Pyth c mul add def l 0
eq { x0 y0 r h add AngleA AngleB arc x0 y0 r d add AngleB AngleA arcn }
{ x0 y0 translate /tA AngleA l c mul add def /tB AngleB l c mul sub def
0 0 r h add tA tB arc r h add AngleB PtoC r d add AngleB PtoC 2 copy 6 2
roll l arcto 4 { pop } repeat r d add tB PtoC l arcto 4 { pop } repeat 0
0 r d add tB tA arcn r d add AngleA PtoC r h add AngleA PtoC 2 copy 6 2
roll l arcto 4 { pop } repeat r h add tA PtoC l arcto 4 { pop } repeat }
ifelse closepath /LPutVar [ x0 y0 r AngleA AngleB h d ] cvx def /LPutPos
{ LPutVar /d ED /h ED /AngleB ED /AngleA ED /r ED /y0 ED /x0 ED t 1 le {
r h add AngleA 1 t sub mul AngleB t mul add dup 90 add /NAngle ED PtoC }
{ t 2 lt { /NAngle AngleB 180 add def r 2 t sub h mul t 1 sub d mul add
add AngleB PtoC } { t 3 lt { r d add AngleB 3 t sub mul AngleA 2 t sub
mul add dup 90 sub /NAngle ED PtoC } { /NAngle AngleA 180 add def r 4 t
sub d mul t 3 sub h mul add add AngleA PtoC } ifelse } ifelse } ifelse
y0 add /Y ED x0 add /X ED } def /HPutPos { LPutPos } def /VPutPos {
LPutPos } def } def
/Tfan { /AngleA yB yA sub xB xA sub Atan def GetEdgeA w xA1 xB sub yA1 yB
sub Pyth Pyth w Div CLW 2 div mul 2 div dup AngleA sin mul yA1 add /yA1
ED AngleA cos mul xA1 add /xA1 ED /LPutVar [ xA1 yA1 m { xB w add yB xB
w sub yB } { xB yB w sub xB yB w add } ifelse xA1 yA1 ] cvx def /LPutPos
{ LPutLines } def /VPutPos@ { LPutVar flag { 8 4 roll pop pop pop pop }
{ pop pop pop pop 4 2 roll } ifelse } def /VPutPos { VPutPos@ VPutLine }
def /HPutPos { VPutPos@ HPutLine } def mark LPutVar tx@Dict begin
/ArrowA { moveto } def /ArrowB { } def false Line closepath end } def

/LPutCoor { NAngle tx@Dict begin /NAngle ED end gsave CM STV CP Y sub neg
exch X sub neg exch moveto setmatrix CP grestore } def

/LPut { tx@NodeDict /LPutPos known { LPutPos } { CP /Y ED /X ED /NAngle 0
def } ifelse LPutCoor  } def
/HPutAdjust { Sin Cos mul 0 eq { 0 } { d Cos mul Sin div flag not { neg }
if h Cos mul Sin div flag { neg } if 2 copy gt { pop } { exch pop }
ifelse } ifelse s add flag { r add neg } { l add } ifelse X add /X ED }
def
/VPutAdjust { Sin Cos mul 0 eq { 0 } { l Sin mul Cos div flag { neg } if
r Sin mul Cos div flag not { neg } if 2 copy gt { pop } { exch pop }
ifelse } ifelse s add flag { d add } { h add neg } ifelse Y add /Y ED }
def
end
% END pst-node.pro

%%EndProcSet
%%BeginProcSet: pstricks-add.pro 0 0
%% $Id: pstricks-add.pro 49 2008-10-13 10:59:27Z herbert $
% PostScript prologue for pstricks-add.tex.
% Version 0.21, 2008/10/15
% For distribution, see pstricks.tex.
%
%       HISTORY -> see file Changes
%
/tx@addDict 410 dict def tx@addDict begin
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/GTriangle {
  gsave
  /mtrx CM def
  /colorA ED /colorB ED /colorC ED 	% save the colors
  /yA ED /xA ED               		% save the origin
  xA yA translate
  rotate       		        	% \psk@gangle
  /yB ED /xB ED /yC ED /xC ED   	% save other coordinates
  /ds [                % save data in a array
     0 0 0 colorA aload pop     	% fd x y xr xg xb
     0 xB xA sub yB yA sub colorB aload pop
     0 xC xA sub yC yA sub colorC aload pop
%     1 xC xB add yB colorA aload pop  	% for use with 4 points ABCD
  ] def
  newpath
  <<
  /ShadingType 4           % single Gouraud
  /ColorSpace [ /DeviceRGB ]
  /DataSource ds
  >> 
  shfill
  closepath
  mtrx
  setmatrix grestore} def
%
/RGBtoCMYK {    % on stack r g b -> C M Y K
  3 dict begin
  /Blue ED /Green ED /Red ED
  1 Red sub     % Cyan
  1 Green sub   % Magenta
  1 Blue sub    % Yellow
  0   		% Black  
  end
} def
%
/CMYKtoGRAY { % on stack c m y k -> gray
  exch 0.11 mul add
  exch 0.59 mul add
  exch 0.3 mul add
  dup 1 gt { pop 1 }  if 
  neg 1 add 
} def
%
/RGBtoGRAY { % on stack r g b -> gray
  0.11 mul
  exch 0.59 mul add
  exch 0.3 mul add 
} def
%
/HSBtoGRAY { 
  6 dict begin
  /b exch def 
  /s exch def 6 mul dup cvi dup 
  /i exch def sub 
  /f exch def
  /F [[0 1 f sub 1][f 0 1][1 0 1 f sub][1 f 0][1 f sub 1 0][0 1 f][0 1 1]] def
  F i get { s mul neg 1 add b mul} forall
  0.11 mul
  exch 0.59 mul add
  exch 0.3 mul add 
  end
} def
%
%% convertisseur longueur d'onde ->R,G,B       Manuel Luque
%% lambda max=780 nanometres
%% lambda min=380 nanometres
%% adaptation de :
%% http://www.physics.sfasu.edu/astro/color.html
%% www.efg2.com/lab
%
/Gamma 0.8 def
/calculateRGB {
  lambda 379 le {/Red 0 def /Green 0 def /Blue 0 def} if
  lambda 781 ge {/Red 0 def /Green 0 def /Blue 0 def} if
  lambda 380 ge {lambda 439 le {
    /R {lambda 440 sub neg 440 380 sub div} def
    /Red R factor mul Gamma exp def
    /G 0 def
    /Green G factor mul Gamma exp def
    /B 1 def
    /Blue B factor mul Gamma exp def} if
  } if
  lambda 440 ge { lambda 489 le {
    /G {lambda 440 sub 490 440 sub div} def
    /Green G factor mul Gamma exp def
    /R 0 def /Red 0 def
    /B 1 def
    /Blue B factor mul Gamma exp def } if
  } if
  lambda 490 ge {lambda 509 le {
    /B {lambda 510 sub neg 510 490 sub div} def
    /Blue B factor mul Gamma exp def
    /R 0 def /Red 0 def
    /G 1 def
    /Green G factor mul Gamma exp def } if
  } if
  lambda 510 ge {lambda 579 le {
    /R {lambda 510 sub 580 510 sub div } def
    /Red R factor mul Gamma exp def
    /Blue 0 def
    /G 1 def
    /Green G factor mul Gamma exp def } if
  } if
  lambda 580 ge {lambda 644 le {
    /G {lambda 645 sub neg 645 580 sub div } def
    /Green G factor mul Gamma exp def
    /Blue 0 def
    /R 1 def
    /Red R factor mul Gamma exp def } if
  } if
  lambda 645 ge { lambda 780 le {
    /Red 1 factor mul Gamma exp def
    /Blue 0 def
    /Green 0 def } if
  } if
} def
%
/factor {
  lambda 380 ge {lambda 419 le { 0.3 0.7 lambda 380 sub mul 420 380 sub div add} if } if
  lambda 420 ge {lambda 700 le { 1 } if } if
  lambda 701 ge {lambda 780 le { 0.3 0.7 780 lambda sub mul 780 700 sub div add} if } if
} def
%
/wavelengthToRGB { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  calculateRGB
} def %  now the colors are saved in Red Green Blue
%
/wavelengthToCMYK { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  gsave
  calculateRGB Red Green Blue RGBtoCMYK 
  /Black ED /Yellow ED /Magenta ED /Cyan ED
  grestore
} def %  now the colors are saved in Cyan Magenta Yellow Black
%
/axfill {
    8 dict begin
    /xw exch def /nl exch def
    /C1 exch def /y1 exch def/x1 exch def
    /C0 exch def /y0 exch def/x0 exch def
    <<  /ShadingType 2
        /ColorSpace /DeviceRGB
        /Coords [ x0 y0 x1 y1 ]
        /EmulatorHints [ xw 2 div dup ]
        /Function <<
            /FunctionType 2
            /Domain [0 1]
            /C0 C0
            /C1 C1
            /N      1
        >>
    >> shfill
    end
} bind def
%
%%%%% ### bubblesort ###
%% syntax : array bubblesort --> array2 trie par ordre croissant
%% code de Bill Casselman
%% http://www.math.ubc.ca/people/faculty/cass/graphics/text/www/
/bubblesort {
4 dict begin
   /a exch def
   /n a length 1 sub def
   n 0 gt {
      % at this point only the n+1 items in the bottom of a remain to
      % the sorted largest item in that blocks is to be moved up into
      % position n
      n {
         0 1 n 1 sub {
            /i exch def
            a i get a i 1 add get gt {
               % if a[i] > a[i+1] swap a[i] and a[i+1]
               a i 1 add
               a i get
               a i a i 1 add get
               % set new a[i] = old a[i+1]
               put
               % set new a[i+1] = old a[i]
               put
            } if
         } for
         /n n 1 sub def
      } repeat
   } if
   a
end
} def
%
end
%
% END pstricks-add.pro


%%EndProcSet
%%BeginProcSet: lm-ec.enc 0 0
% This file belongs to the Latin Modern package. The work is released
% under the GUST Font License. See the MANIFEST-Latin-Modern.txt and
% README-Latin-Modern.txt files for the details. For the most recent version of
% this license see http://www.gust.org.pl/fonts/licenses/GUST-FONT-LICENSE.txt
% or http://tug.org/fonts/licenses/GUST-FONT-LICENSE.txt

/enclmec[
/grave
/acute
/circumflex
/tilde
/dieresis
/hungarumlaut
/ring
/caron
/breve
/macron
/dotaccent
/cedilla
/ogonek
/quotesinglbase
/guilsinglleft
/guilsinglright
/quotedblleft
/quotedblright
/quotedblbase
/guillemotleft
/guillemotright
/endash
/emdash
/cwm
/perthousandzero
/dotlessi
/dotlessj
/ff
/fi
/fl
/ffi
/ffl
/visiblespace
/exclam
/quotedbl
/numbersign
/dollar
/percent
/ampersand
/quoteright
/parenleft
/parenright
/asterisk
/plus
/comma
/hyphen
/period
/slash
/zero
/one
/two
/three
/four
/five
/six
/seven
/eight
/nine
/colon
/semicolon
/less
/equal
/greater
/question
/at
/A
/B
/C
/D
/E
/F
/G
/H
/I
/J
/K
/L
/M
/N
/O
/P
/Q
/R
/S
/T
/U
/V
/W
/X
/Y
/Z
/bracketleft
/backslash
/bracketright
/asciicircum
/underscore
/quoteleft
/a
/b
/c
/d
/e
/f
/g
/h
/i
/j
/k
/l
/m
/n
/o
/p
/q
/r
/s
/t
/u
/v
/w
/x
/y
/z
/braceleft
/bar
/braceright
/asciitilde
/hyphen.alt
/Abreve
/Aogonek
/Cacute
/Ccaron
/Dcaron
/Ecaron
/Eogonek
/Gbreve
/Lacute
/Lcaron
/Lslash
/Nacute
/Ncaron
/Eng
/Ohungarumlaut
/Racute
/Rcaron
/Sacute
/Scaron
/Scedilla
/Tcaron
/Tcedilla
/Uhungarumlaut
/Uring
/Ydieresis
/Zacute
/Zcaron
/Zdotaccent
/IJ
/Idotaccent
/dcroat
/section
/abreve
/aogonek
/cacute
/ccaron
/dcaron
/ecaron
/eogonek
/gbreve
/lacute
/lcaron
/lslash
/nacute
/ncaron
/eng
/ohungarumlaut
/racute
/rcaron
/sacute
/scaron
/scedilla
/tcaron
/tcedilla
/uhungarumlaut
/uring
/ydieresis
/zacute
/zcaron
/zdotaccent
/ij
/exclamdown
/questiondown
/sterling
/Agrave
/Aacute
/Acircumflex
/Atilde
/Adieresis
/Aring
/AE
/Ccedilla
/Egrave
/Eacute
/Ecircumflex
/Edieresis
/Igrave
/Iacute
/Icircumflex
/Idieresis
/Eth
/Ntilde
/Ograve
/Oacute
/Ocircumflex
/Otilde
/Odieresis
/OE
/Oslash
/Ugrave
/Uacute
/Ucircumflex
/Udieresis
/Yacute
/Thorn
/Germandbls
/agrave
/aacute
/acircumflex
/atilde
/adieresis
/aring
/ae
/ccedilla
/egrave
/eacute
/ecircumflex
/edieresis
/igrave
/iacute
/icircumflex
/idieresis
/eth
/ntilde
/ograve
/oacute
/ocircumflex
/otilde
/odieresis
/oe
/oslash
/ugrave
/uacute
/ucircumflex
/udieresis
/yacute
/thorn
/germandbls
] def

%%EndProcSet
%%BeginProcSet: texps.pro 0 0
%!
TeXDict begin/rf{findfont dup length 1 add dict begin{1 index/FID ne 2
index/UniqueID ne and{def}{pop pop}ifelse}forall[1 index 0 6 -1 roll
exec 0 exch 5 -1 roll VResolution Resolution div mul neg 0 0]/Metrics
exch def dict begin Encoding{exch dup type/integertype ne{pop pop 1 sub
dup 0 le{pop}{[}ifelse}{FontMatrix 0 get div Metrics 0 get div def}
ifelse}forall Metrics/Metrics currentdict end def[2 index currentdict
end definefont 3 -1 roll makefont/setfont cvx]cvx def}def/ObliqueSlant{
dup sin S cos div neg}B/SlantFont{4 index mul add}def/ExtendFont{3 -1
roll mul exch}def/ReEncodeFont{CharStrings rcheck{/Encoding false def
dup[exch{dup CharStrings exch known not{pop/.notdef/Encoding true def}
if}forall Encoding{]exch pop}{cleartomark}ifelse}if/Encoding exch def}
def end

%%EndProcSet
%%BeginProcSet: special.pro 0 0
%!
TeXDict begin/SDict 200 dict N SDict begin/@SpecialDefaults{/hs 612 N
/vs 792 N/ho 0 N/vo 0 N/hsc 1 N/vsc 1 N/ang 0 N/CLIP 0 N/rwiSeen false N
/rhiSeen false N/letter{}N/note{}N/a4{}N/legal{}N}B/@scaleunit 100 N
/@hscale{@scaleunit div/hsc X}B/@vscale{@scaleunit div/vsc X}B/@hsize{
/hs X/CLIP 1 N}B/@vsize{/vs X/CLIP 1 N}B/@clip{/CLIP 2 N}B/@hoffset{/ho
X}B/@voffset{/vo X}B/@angle{/ang X}B/@rwi{10 div/rwi X/rwiSeen true N}B
/@rhi{10 div/rhi X/rhiSeen true N}B/@llx{/llx X}B/@lly{/lly X}B/@urx{
/urx X}B/@ury{/ury X}B/magscale true def end/@MacSetUp{userdict/md known
{userdict/md get type/dicttype eq{userdict begin md length 10 add md
maxlength ge{/md md dup length 20 add dict copy def}if end md begin
/letter{}N/note{}N/legal{}N/od{txpose 1 0 mtx defaultmatrix dtransform S
atan/pa X newpath clippath mark{transform{itransform moveto}}{transform{
itransform lineto}}{6 -2 roll transform 6 -2 roll transform 6 -2 roll
transform{itransform 6 2 roll itransform 6 2 roll itransform 6 2 roll
curveto}}{{closepath}}pathforall newpath counttomark array astore/gc xdf
pop ct 39 0 put 10 fz 0 fs 2 F/|______Courier fnt invertflag{PaintBlack}
if}N/txpose{pxs pys scale ppr aload pop por{noflips{pop S neg S TR pop 1
-1 scale}if xflip yflip and{pop S neg S TR 180 rotate 1 -1 scale ppr 3
get ppr 1 get neg sub neg ppr 2 get ppr 0 get neg sub neg TR}if xflip
yflip not and{pop S neg S TR pop 180 rotate ppr 3 get ppr 1 get neg sub
neg 0 TR}if yflip xflip not and{ppr 1 get neg ppr 0 get neg TR}if}{
noflips{TR pop pop 270 rotate 1 -1 scale}if xflip yflip and{TR pop pop
90 rotate 1 -1 scale ppr 3 get ppr 1 get neg sub neg ppr 2 get ppr 0 get
neg sub neg TR}if xflip yflip not and{TR pop pop 90 rotate ppr 3 get ppr
1 get neg sub neg 0 TR}if yflip xflip not and{TR pop pop 270 rotate ppr
2 get ppr 0 get neg sub neg 0 S TR}if}ifelse scaleby96{ppr aload pop 4
-1 roll add 2 div 3 1 roll add 2 div 2 copy TR .96 dup scale neg S neg S
TR}if}N/cp{pop pop showpage pm restore}N end}if}if}N/normalscale{
Resolution 72 div VResolution 72 div neg scale magscale{DVImag dup scale
}if 0 setgray}N/psfts{S 65781.76 div N}N/startTexFig{/psf$SavedState
save N userdict maxlength dict begin/magscale true def normalscale
currentpoint TR/psf$ury psfts/psf$urx psfts/psf$lly psfts/psf$llx psfts
/psf$y psfts/psf$x psfts currentpoint/psf$cy X/psf$cx X/psf$sx psf$x
psf$urx psf$llx sub div N/psf$sy psf$y psf$ury psf$lly sub div N psf$sx
psf$sy scale psf$cx psf$sx div psf$llx sub psf$cy psf$sy div psf$ury sub
TR/showpage{}N/erasepage{}N/copypage{}N/p 3 def @MacSetUp}N/doclip{
psf$llx psf$lly psf$urx psf$ury currentpoint 6 2 roll newpath 4 copy 4 2
roll moveto 6 -1 roll S lineto S lineto S lineto closepath clip newpath
moveto}N/endTexFig{end psf$SavedState restore}N/@beginspecial{SDict
begin/SpecialSave save N gsave normalscale currentpoint TR
@SpecialDefaults count/ocount X/dcount countdictstack N}N/@setspecial{
CLIP 1 eq{newpath 0 0 moveto hs 0 rlineto 0 vs rlineto hs neg 0 rlineto
closepath clip}if ho vo TR hsc vsc scale ang rotate rwiSeen{rwi urx llx
sub div rhiSeen{rhi ury lly sub div}{dup}ifelse scale llx neg lly neg TR
}{rhiSeen{rhi ury lly sub div dup scale llx neg lly neg TR}if}ifelse
CLIP 2 eq{newpath llx lly moveto urx lly lineto urx ury lineto llx ury
lineto closepath clip}if/showpage{}N/erasepage{}N/copypage{}N newpath}N
/@endspecial{count ocount sub{pop}repeat countdictstack dcount sub{end}
repeat grestore SpecialSave restore end}N/@defspecial{SDict begin}N
/@fedspecial{end}B/li{lineto}B/rl{rlineto}B/rc{rcurveto}B/np{/SaveX
currentpoint/SaveY X N 1 setlinecap newpath}N/st{stroke SaveX SaveY
moveto}N/fil{fill SaveX SaveY moveto}N/ellipse{/endangle X/startangle X
/yrad X/xrad X/savematrix matrix currentmatrix N TR xrad yrad scale 0 0
1 startangle endangle arc savematrix setmatrix}N end

%%EndProcSet
%%BeginProcSet: color.pro 0 0
%!
TeXDict begin/setcmykcolor where{pop}{/setcmykcolor{dup 10 eq{pop
setrgbcolor}{1 sub 4 1 roll 3{3 index add neg dup 0 lt{pop 0}if 3 1 roll
}repeat setrgbcolor pop}ifelse}B}ifelse/TeXcolorcmyk{setcmykcolor}def
/TeXcolorrgb{setrgbcolor}def/TeXcolorgrey{setgray}def/TeXcolorgray{
setgray}def/TeXcolorhsb{sethsbcolor}def/currentcmykcolor where{pop}{
/currentcmykcolor{currentrgbcolor 10}B}ifelse/DC{exch dup userdict exch
known{pop pop}{X}ifelse}B/GreenYellow{0.15 0 0.69 0 setcmykcolor}DC
/Yellow{0 0 1 0 setcmykcolor}DC/Goldenrod{0 0.10 0.84 0 setcmykcolor}DC
/Dandelion{0 0.29 0.84 0 setcmykcolor}DC/Apricot{0 0.32 0.52 0
setcmykcolor}DC/Peach{0 0.50 0.70 0 setcmykcolor}DC/Melon{0 0.46 0.50 0
setcmykcolor}DC/YellowOrange{0 0.42 1 0 setcmykcolor}DC/Orange{0 0.61
0.87 0 setcmykcolor}DC/BurntOrange{0 0.51 1 0 setcmykcolor}DC
/Bittersweet{0 0.75 1 0.24 setcmykcolor}DC/RedOrange{0 0.77 0.87 0
setcmykcolor}DC/Mahogany{0 0.85 0.87 0.35 setcmykcolor}DC/Maroon{0 0.87
0.68 0.32 setcmykcolor}DC/BrickRed{0 0.89 0.94 0.28 setcmykcolor}DC/Red{
0 1 1 0 setcmykcolor}DC/OrangeRed{0 1 0.50 0 setcmykcolor}DC/RubineRed{
0 1 0.13 0 setcmykcolor}DC/WildStrawberry{0 0.96 0.39 0 setcmykcolor}DC
/Salmon{0 0.53 0.38 0 setcmykcolor}DC/CarnationPink{0 0.63 0 0
setcmykcolor}DC/Magenta{0 1 0 0 setcmykcolor}DC/VioletRed{0 0.81 0 0
setcmykcolor}DC/Rhodamine{0 0.82 0 0 setcmykcolor}DC/Mulberry{0.34 0.90
0 0.02 setcmykcolor}DC/RedViolet{0.07 0.90 0 0.34 setcmykcolor}DC
/Fuchsia{0.47 0.91 0 0.08 setcmykcolor}DC/Lavender{0 0.48 0 0
setcmykcolor}DC/Thistle{0.12 0.59 0 0 setcmykcolor}DC/Orchid{0.32 0.64 0
0 setcmykcolor}DC/DarkOrchid{0.40 0.80 0.20 0 setcmykcolor}DC/Purple{
0.45 0.86 0 0 setcmykcolor}DC/Plum{0.50 1 0 0 setcmykcolor}DC/Violet{
0.79 0.88 0 0 setcmykcolor}DC/RoyalPurple{0.75 0.90 0 0 setcmykcolor}DC
/BlueViolet{0.86 0.91 0 0.04 setcmykcolor}DC/Periwinkle{0.57 0.55 0 0
setcmykcolor}DC/CadetBlue{0.62 0.57 0.23 0 setcmykcolor}DC
/CornflowerBlue{0.65 0.13 0 0 setcmykcolor}DC/MidnightBlue{0.98 0.13 0
0.43 setcmykcolor}DC/NavyBlue{0.94 0.54 0 0 setcmykcolor}DC/RoyalBlue{1
0.50 0 0 setcmykcolor}DC/Blue{1 1 0 0 setcmykcolor}DC/Cerulean{0.94 0.11
0 0 setcmykcolor}DC/Cyan{1 0 0 0 setcmykcolor}DC/ProcessBlue{0.96 0 0 0
setcmykcolor}DC/SkyBlue{0.62 0 0.12 0 setcmykcolor}DC/Turquoise{0.85 0
0.20 0 setcmykcolor}DC/TealBlue{0.86 0 0.34 0.02 setcmykcolor}DC
/Aquamarine{0.82 0 0.30 0 setcmykcolor}DC/BlueGreen{0.85 0 0.33 0
setcmykcolor}DC/Emerald{1 0 0.50 0 setcmykcolor}DC/JungleGreen{0.99 0
0.52 0 setcmykcolor}DC/SeaGreen{0.69 0 0.50 0 setcmykcolor}DC/Green{1 0
1 0 setcmykcolor}DC/ForestGreen{0.91 0 0.88 0.12 setcmykcolor}DC
/PineGreen{0.92 0 0.59 0.25 setcmykcolor}DC/LimeGreen{0.50 0 1 0
setcmykcolor}DC/YellowGreen{0.44 0 0.74 0 setcmykcolor}DC/SpringGreen{
0.26 0 0.76 0 setcmykcolor}DC/OliveGreen{0.64 0 0.95 0.40 setcmykcolor}
DC/RawSienna{0 0.72 1 0.45 setcmykcolor}DC/Sepia{0 0.83 1 0.70
setcmykcolor}DC/Brown{0 0.81 1 0.60 setcmykcolor}DC/Tan{0.14 0.42 0.56 0
setcmykcolor}DC/Gray{0 0 0 0.50 setcmykcolor}DC/Black{0 0 0 1
setcmykcolor}DC/White{0 0 0 0 setcmykcolor}DC end

%%EndProcSet
%%BeginFont: LMMono8-Regular
%!PS-AdobeFont-1.0: LMMono8-Regular 1.106
%%CreationDate: 22nd January 2008
% Generated by MetaType1 (a MetaPost-based engine)
% Copyright 2003--2008 by B. Jackowski and J.M. Nowacki (on behalf of TeX USERS GROUPS).
% Supported by CSTUG, DANTE eV, GUST, GUTenberg, NTG, and TUG.
% METATYPE1/Type 1 version by B. Jackowski & J. M. Nowacki
% from GUST (http://www.gust.org.pl).
% This work is released under the GUST Font License.
% For the most recent version of this license see
% This work has the LPPL maintenance status `maintained'.
% The Current Maintainer of this work is Bogus\l{}aw Jackowski and Janusz M. Nowacki.
% This work consists of the files listed in the MANIFEST-Latin-Modern.txt file.
% ADL: 778 222 0
%%EndComments
FontDirectory/LMMono8-Regular known{/LMMono8-Regular findfont dup/UniqueID known{dup
/UniqueID get 0 eq exch/FontType get 1 eq and}{pop false}ifelse
{save true}{false}ifelse}{false}ifelse
17 dict begin
/FontInfo 9 dict dup begin
/version(1.106)readonly def
/Notice(Copyright 2003--2008 by B. Jackowski and J.M. Nowacki (on behalf of TeX USERS GROUPS).)readonly def
/FullName(LMMono8-Regular)readonly def
/FamilyName(LMMono8)readonly def
/Weight(Normal)readonly def
/isFixedPitch true def
/ItalicAngle 0 def
/UnderlinePosition -133 def
/UnderlineThickness 61 def
end readonly def
/FontName /LMMono8-Regular def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 0 /.notdef put
readonly def
/PaintType 0 def
/FontType 1 def
/StrokeWidth 0 def
/FontMatrix[0.001 0 0 0.001 0 0]readonly def
%/UniqueID 0 def
/FontBBox{-456 -320 743 1014}readonly def
currentdict end
currentfile eexec
D9D66F633B846A97B686A97E45A3D0AA0525392EECAC163E584A9104D99AD0BC
1B1844A0E222653FA481B8809B26A46F4C483A5D7E95816EA6582584156CFEDE
B994ADCFF4645140E3617E4D7E1B0E4541CB9F562E55829B4DD880AABE2229E9
4A9FA259A734D29BBA91BA1E2055CBEA4339BCBFF98D32CEFF11F296225CAABA
DCA10577A5D431B714726C1278D8101ABD1BD8D0BD0174FFF9148F8C61C241D9
2AD360A28616CB4A0670C1BF105BFA1C4BAA954C1A4935178C1A8D83170E28AC
DAB69F06AA3E48B756686721C14D38161315F37969C634B4F3577ECE895C6566
8D35539B83440079BCEE18E8A01299022FC701D373A96A65121458A851F6B279
FD73DC43B4726E792C719A80C077CA984EF33E1A7EEF3ADE8418A1D33938889D
3EC38630976AECD0F57FE3BA459909DBB874968612943DCEF878CC71DA1DA11B
D7CDE67361D032D485A02996638D482E237B32ADD01457BB4F428C7775E01CFE
D17A68E3118DDE73343B40DDEA548DF7932D97AF81AF5D696FD8A5FC35F9BF80
18E7C96E9C8AB1E7DDF21962F1A70B50E5B079BF553C33AD2B8F53FF62D75363
8952144C9D7C1CD0211508979FAF6DABDB6582E0999DFFA3A1309DB5D00AD611
DB1F6949A2AFA36C7D751D7EC43CB55FBDE79CE6B26A682BA9CA7BCD141E2B90
95B82C7AFEEB7D02B13A1CFEF7F6322D4EB72DA4FF49BFD78811D831B49BF69F
ECAE484519FBBBC76501DBB7BCBB3D3A29C932EDD289E54EA987C1924683EA2E
D4383D5B8E32FAE0BC42B5FFA7FA2F724A5F362DB03D83DC9C975FC851D23CFE
5896C22744D590C0E76357030350B314639C3BB8B40E9F03D7608B6630B996D2
741BE7AB853D7DE4B32BB12C9E3250B9A1C523D00E9FADF4C35BF1D5CB875B2A
43838E84EE8B55B299F7DE5884208F3A480C8030A85C0B4332C6BD451141CAC4
52EE7BE6EBC3D0BFBD63718D39ECA43A2D461F4534FC680164A4D34F9307A86B
81DA3F7ECCF3D8E2B0157BB082E5EB5E4E069D3865B3B3C46F8E9F9B17CDBA5E
B367E9883141CF21B1D502BA67C1F8312CB08F3179160B3555D2E2D2DA4EFEC9
6FB4086BA92A0BF28F15AFA39C5F99B9B74CB9CABDCF62DF163FB9FF43229B74
CE9D0C64C56A927FEB12B9E76FEA5288574DA436F896C6E5F33484C8D266FA91
01DB5FD7B53F01A47C434084695881F997C99E46BC0BF3A4EC2B5CEC1FF8D4F6
C358A712769605D9E32DDC8A2AF6F6A7FC749C54E38BCAC20ED17BF51EAE2C85
21AB6B8FC85ABEEDEAAEB3423E9A88A13229E9843F0EE896ADE39A284DF9EFC8
8D77D02D396C46577715C95A57D76C2C39A36A0320EFC9D45441BEBB7148DADE
2547DB52F38098A03B11EAA856CB690E4D9D6B4452C138A84B53712BD7B63F09
73FFDD625749018A1EC11BE08075931F909D2CA2E5DB900DC43E65D720CB772B
840B1F52CBDB39B6E9E037705608D71FF78077E0118B0B9702ACED9DB6F1156B
5FE3882E8AE45DAB0A4848457A42152F9BCF7C4A5E7EA4AB7D3BB0F9DC7CE31C
AD25EF631C48E3B2431BF4511551B4793C42178514EC183BE32AAE65DC84BBBF
FEAE07A0CDFC782280B8436B909CB12D82ADEEF2560AE491DE4908C94E372BEF
64BB6CA5F0E38B4A157603F4C29E1240F90533E281EEEDCC3F5E4DE80BCCDE28
EA61C710496DD8A4F0AB05ECA72D6DAE2C3C67CB3B4E4A19BC80F638158DDC1B
6DDD5CFAA56386D1764B92BD48CCF7CFA30A7E92FA628D056602E7EADA129167
8E402EC73D4064328E15B8921F38FDB6F24414A757007424641F740EC5307A40
735A718B09064159479685AA9AE8DF53A2A21D951A60E73E67169DC0D53B5B7F
23CD96597C5D225B4C7A3FD940B5B7DAD3C2AAC5B80EC514976A747B8E08E66B
C3DDA8287F550A0681726C4D377CA89ABD1BEE3C9BD84A05DD11C97BB780BB6D
7ADA1E291A67DA9DC8C112D33C10AA8CDCB94DFC5FBFA569DB2DEE9C6F9B59FE
8E849CF8FC24D3AAE7AB25DF8A37E992D8580FF57E5ED0D3627029DDCC2A5D4F
1C948FD5F508EF79A6E58394BD8316E74E486126604BB3082C40A65639E91B97
483486C378BB58A04CCF5560C9BC0F1062E5F9BB623801E5500EB43C05DA8960
309A86FF740C208AD152E12301D4CC5F0E4927B5D413A21080DCFDFED080F13E
5F04E1D4B28BEE5E71772C8921D69D11ACDDE095D43077D47E332D8273DED975
BD53607ED94253CB78FFAD6ED697153C95555805F13A46336CD2171FFC355965
BDD4589064D7950B82F1DE12E1EBB53F8D738E0ECEECB452C7059F491D1C8BE0
38ADD1FA4019E1C78B8C76510D8E883C2A3E8826B5A2A74206C0A2FD237CDA51
8A4D5AD87BC27392D7A101E273541B8FFD8A9F88AF4464F3201708E5E6CCD078
D772DD8B03B8407E5D1395C428BD92DC4EDA5C72C6F813D53F1E9C3734B81C2A
DED2156928CFC8EE865A632AB4A611CAD82809B7204B707CFD45E588F7F0CEA7
717976FBB04E6A3577A3C0A859888B5DC6EDA08D241782F0B701960683AC1376
F4E12449863C38560F4C025E8158D68F71F943AD74C985BA26DD7650B28A326F
8B92F4E100749B38E43EECAA35374EC47A70CB070853165C61C1EE74FF06F22A
CB9624AEB7824D5B0AE928DA1E4073F2400FAF3C00857A57EFDD6BABBB2B1539
76A11DDD81276D76A9549BD550F5600AA8036BC6094AD5D0C723C2131B7FD8B6
C20CD382EB8EEC2982333428081F09F426BE53C87C2C5CAA2F2A5BE02C895D60
E536D3DAB7BF60A75AC6D3B5746051A0E8E152C99FF20214153556441E002375
52934829824046E10E39028ACCCCB0D002853B54BA0DDD6C54A36A495743B1D1
65EA43C14069106589A066E3C09DEF8C946669EF2C286DAB56E327ADED08D5D7
5F78405FA20565E8593A4E99A03A3595EEFAC28BAC01932FF6D3254526D953F2
7586F8CD1056B6969602161C8FA3B0A8335A4D3AE1C38CDB5F176631A69FDABF
8E5FB7ACA43E545C1129D021A5E90BC65020446B3C96FF9C99042164C633B9FF
63BCB644DCC3AE03D656334D7A3E9F845B49E2E0C1B754A6731667C48C39B007
A51A697A4D8A360D401719C5FDD35E2A091350294B1A1AE1533EAAC17EF92DC3
567F61D33816DF7E935CF4233C2614BB02993C18F5228D9C33BDBAC2EE943566
F917B7E3C6B26FF7C075A884DD1EE8AF71499D39CE0567AEA286091BEA9D6A44
3A5892BBD7756CFD54770E2A8D81BD4618D916A30EC70F16A060C09502E182EA
B0E7D0D01ABC1E310F7D2A2CF63FFD0AA111D6B991AB46827F81542BCA6356A3
924969BBBE7F59D359C188F8D6F5D6D67FFAA12B256C0A58AE75843EEC7B5DA6
5FC5113028F5CA15C2FF5C0CE1AD4B3E9909F220E99C367B96C474DF3C2D253C
0F83DA625EF5CC0FC9F75FB7A90677C02630C6B4D5393D9E96E3E09612F99B10
0345D53EDC134D23DCAABF22FCD1AD8EADCFEE7E92637D00097377258E81C9C8
98C8CAE1F50A8D81F244A01498B59AAD06E09E59659F2B7C58BE9909CBFCD273
EF5617183CFA6475788ADB642F09E20933D1022D57370B9BB48DBDF15D0CFAB4
0CCF15567797367A96A03D3AC106E06F828E956E5AB3A47D574A3D68FE38181F
8C09AD6DC1446B3E65065F555A41FA4A0C8ABEA034AE870E385830AFA9886711
7694133A3248571E032FA87046115B70830C4AA68E87D470463759F200DAA04B
33D16DB6B31C5236F099107F153E3FFC70BED6D04DB4820FDAC0024BC58BCAE4
2E376A4BF18143CB463B43B8D35C1AF046275EED4FC60F6AE7BF7BE43085E59A
7E8982198427830820DD196E4EE2631788B5B292CBD205BD8A7EE242C7B965D9
AE82D16F0DDFA0306B260C5CD4D9A58A2AB6B31D984F0072AA303D33D5478995
B5338186408583FCA0C342E95FB053CBDAB825988EF44CA9EB4A2FE8BBE548A8
C92D6D52BBBD815700DDBF74140C32A2AAB5337B999E290BB4078ED610795231
E3FE9BE99117EBF4E753A713F08859480588CA6F6C580A811E48D10296D1AB86
3C95186206F7453C174D514A9C4DF3FB399D621E90E7A0F10941DE0F2AC2D901
074A77981D49919570F2E5F06D721403053F2058E88858E733E7227EC0C4F85C
A74278CE1F76F4545C11F06148915DDB312011F19F94F8BD632589AF0FB8C8BA
BC8A44A5C70008DC13655D7241194A25388FEDA8896ED5785E0D4677DE8945C1
299AFF8554B37C97284940DD33D9D66638FDA8BDD4DE1F10153D551CCD732503
2D027AF5D96EDC72B7B9B4BCC12F4209B1951AF23FF686F6FC48EFBC5C66A86D
A1267EFD0181C65C2F290D74871316D8FAE438A579EBA81C0456BF0297BBD91F
79D3C09D5E90650BC469454D661AF243C250B6193547DEB0F706747EC06BC9FE
94C5B89747B85F1D107E7FBEE52ADFFE31C81FB964E824A7C9994B56C119FA5C
3274FEAAE12CA8D40B40B3B362AA3B778C47E857E4C2AC635DFFA4C9F987EAF1
4699937EC5E60FFB3A13AC9FCE3CC664E3B5C473F46090D631EF06BC9B62A95F
E764579DE0CC5B4E5E15AECA8C66082082F59C3DE71163335BECDDB32B48CAC4
3A4C530DB3EA06EF9672983138D713933F6765EC3CE1B0C7B5C121106509D02C
6FEF286C526C019514EA451987C715206297C0971364CC5B83001B07895F089B
372BBC0F0F89FE477C2413903A61E139B0D0A1F4692D7477AFF41983B1FA5937
DF61E9CCA3BFE943C25C000413A12A4D2A05B5C1F8295AC799CAC6349A8030F0
2D5D2296FBFA1E5C6668641E4C15421F6D812255D98D2E8AAB81E93EE65123A9
456E301532929320D07646B8F4EFA8445799658F955BF73F38B67E1FDD63579E
E3AA4E8985E3C3F61076183D794D012E55C69242F195F75851616E483BE513ED
163242C8A16395C67E4EEAA170C20BB6AD11DBD978F3032D2FC6BD54FD7664FA
F472BBF13868C5D0712B114BB44747C291F571D6E0ED8901F90F6CF84B22474C
84C7C3696AD83CA15099ECDF3A273E8CEF09B0E4AA470CFF413429B3CBDE2628
B4A301C4AEEEF3DB685568D9A4A02AA79B5975C140AABA1B604C266E6FB55E0F
6F6F786A20316B992F547DE9372FEEA0BE4053B07640A4713C65620D09F8EFFE
7766EDBD7CE06A64C2CBA83EA906842C86B5147254A6EB06C3E874B88A2E4C38
098DC1B5EB22D5F83D6A295AB9E01BF45591DFC3BF8B32E5A35132E206921E31
23164FD0AAC0858943DD324F4CF7064627B70B61C638952B9509F7501E561EFD
FB8F1E70B5759D7DEA6A5634D8C408A4217BBD280FAA448F5BF23680C0DA9FF7
E6BF4298E548FE405D01D18D8EBE0269B68A357DDA4E9A4396479FD092AA6766
50FF097D8A100C3CF0C05C0E30F0B3C40E64085640324695590A087E71F8C21B
A46E833E6C0DCF6556C1CC6A1C88E8243FEE108988BE87E309577263E7B3061B
B6599DDE33CF62E3E17CA208450468258082D6400021C593C2475A14648A8087
85ED46B2205D9BCAEA85DAF9DFB14F50FE1D963E9327FB8671DC9F1B6ECB2EC7
EE483531E3DF9BCCC9757D7B51A9DB721193CA8D8B9795BAC734FF40961F4881
12ED925C55E4B0DF0E5BEE4B29E5DA8177D46AE2C7EFD20CB37230AE9012BE8E
990CA41D0EBC56994A3A64EE0A5930150D0AB4682B25D8FBBB10124FFCE47CEE
F2B56DC959DE82E9467C98255B361BFB67AF9124F7510F6853DB8998F9CBE047
2F641CF6660A76C929E5680BFA65C25A312852770DAB7D39E1217619DADD5A52
9F4AAF707B0A9B94E0BEF9D47D21527A3B1D808785CA3493751088D410AEA9CA
C3C1C46158F508D7AB7F99ADD20B351B58302CCC65CB916CBB6C5996C95C98B3
40BCB45BD0239F0F41E86F2D4EEB998520A57985CEEF4463EEDFD8D1802F2EC8
62FB85A143D7B299223ED8525202C1BB1AA20CC2172E8954FE7E4AE6BDDDCCD0
3A3A1B7138B48D6105A0E23FA25DD024213A0F8087A08EFE3C136CFDAD3947E2
93CC426E38653A16E2A7EDF6D500E92372AC26A1209E17F22E4F250B1AD23480
8045A2343483AF580690A1C2394520D09923F16F3816C9775FCE5AEB0B4FD753
6C922E5D54C8528E8A4BEB8FAB9005788A5B01823B27291F2D47B02EC7F91571
FCF8978A464394EA84D2DF962A9E72C29C0B7A875CE92C07241444957DEF22D0
2AE6333848C9658E9E37741A481FF3F7E0CB583C75756CD2F3976186D22F9F05
4D68CB91DE66F19076D8D365CDD8FF305059C2E913B7978671AC30CD51D35385
0158CF3C78E858E34B8CFFDC7A128BEC0947A9E4FF16D3AB8647D6542B4C6CD7
7F4469A676906BA0888497FCABFBDC68C6EB5DA286DA3420805F6205E00B2A2B
A18A1F5E4453A41E2104508C1F0683360F2D36241C76BD7D555403B83025FC25
9D4ABAD69050D64014F1B2D2DB8453CCFADA24266BE73CA1B36B4B2F2784D24C
676AD7F3EEEB60A6554A2CEE9C22560739C926926B73B5A3F17F9B343C3728B2
6AAEF33C0C45D0B3A5A116E52569AA2577DBBD57648E398F5A052751A5B22688
4049A139265531BD241735EFDC419077B3882F31F29C281C2F75B1F1589DE405
A8F821C2EEA5310936F6232750BBF9EF28E722B7CB9131013B77B216FE145E5E
49AF9C313B38BAACA5F6565B966BF65083A9120FC2606A9025D3DB7F074CFD27
28ECD18DDA85175E3CE67FD4A6528AC6E33F43467A18708A41B051F31A13C3EA
3D583D1AA7FBCF211BF0A0B29BFB01DBCF14D4CA5F89463EF6D0CDD0EACD7326
BAC78D75F9B073B562F6812D9491A77D5F75F024E63E4D7235723125FDA6A45D
9B4C62FE9472309F64D20E5DCC5484AD230FBC4EB1D310296E53F69B1CFFA43B
97B9C6282E98DAD2C3ADE7D975F1B658A581597AB3C7962224D4E3873D2DD75B
B1C61281E75298D261E87E2CB6BC949688B30F0B4F3FD3AFC9CAA04A796E5AF9
2FB97784C67E58AB7F8DE615CB09E909AA836C2B4F5DE2E775A3D3261F152EBA
489EC9E5BB44ADFB7558DD953EDE1309B66F009808B3E847A873C89176E74807
8A8DE1F2EA9821454CB759B3D82921AB4B9278E652C2F309C960C042EA679F78
F37398401D0670B1F871F98366F7E8FAB04A0D7F1783EAAB80313773E1AEEA85
7364EFDDB58A3C4FCA7B685CB9BBF818D140C7D6C640672801A45C344BDE1B37
34804F72600587293247C5DB2C5FA1FDF7996A5D843F40FE063935776459C824
FA2F48C9A647FD2AAA67DCB9DC94301EA34C3872A7A145184E7661CBCD39E577
C63265C59F3BD53A8882D82929177263931EB25BB03850ECDAF201BBABA43032
6604E56F26766ABC26A6A10E3A4E2B8A1F5584EB0A7E91A4FCB9BCD2AD4AC306
27BE974490F2C2A1EDF171B5A5F7ED24B33D2C3AA5AA5E846B6302B1D58E2DAB
B37541DF88049C1F1B0E7C3620451636E19BC9CEA795AF21EF3258E5238D15FE
B57C4DBEA8C96CDEAF8149911A78DF6691E34EC130A824549B599829376AB867
F43B2F6320B331A6EA21B51EAE40D3F4F013108405DF82E0D367A0200CEDC0AA
E2ED72D1D214356F2F45DBAEB9560610E8BC8794666459CD5C0A78314EDF4F43
61872DFA2C65EB44D5CB662BE0B2857AB51ABA1CEDC02E319A37EB5CEFDBF364
92D265A429BA518605960ED34E950BEE93FCFFCDA7DC7C5761CF52AA53D2995F
020A0BC9F8959C4ABDF4FE7C245CA0CD2A4127A3FC408EC625E310DA3E7E84BD
A3755FE79337630AA14DA5BD9E017D60FC01124BABE23FF62E75FCA39AC6F394
CD7FA1132EEB0C7442A63B99930B70AF8F83BCC2FE8BC6D819708103BB963F6F
0BDA611B948CBEC8CBEBDB62AE9ED4A5E7039852BE3A89071578898052C2152D
6AD2291E6FA8684619451A3D0928F822846260B8358DECEC977F9C78F5BB0972
7EBC06D1830262FBD400CA217255FBBBA1E86D352FF8A9BC757F9DD3565AC9CA
F908C0880C2DEF08A6B185F274EEB557DF134CA24FD71890C2F11FEE063BF60E
C48ED7A31FA35DBDD6CCD7D1C332F4231C62C5F3370C9D152978760F1E449125
4E666FD8F21F61FC2EE6DF51A16B4969B5619E2B15FEDB0CEE627589FB0EA874
920BAFB89889071729076D755022032D31B6BE9D16367A5FAB1D14D281D3E8D0
9DC525FFBD6D76B627A600BE050E645BEC59B1DB14A6EECC6AF3F799F2581F14
FAA51AE0B81D6AF0602B80FD0E86AC17D1679FFA26F1D282EBC19257DBC8AFC1
D266C3CD4D3B94486D92B811D773B475C03A372183C536651BCD25496516A425
88342850F206E4C631AE0472AE86C7CEF8887B137B7E2D7A8185EB91514A80F8
1FE7226F6720890E2AA399C35791FE45F069B7946B5EB1D7A5CFCC0057DC032D
0A5ED2A5165A9A2EBC4A7516246D99C18A0A61F658CDAE3E8EF86BD5CBD90AAA
608A3F65C0FB12D24CD51A76F2A8ACE261620AA95755D6941EB85166FB6E723F
9B892781BB126FFE6BE23910E7F181D048F238829D47059814DCD688554EFA8D
7F2FC0737E4E6A6C452DDD57FC1BF8B388B207BDEAD9C007BD094F08F395887C
E66F5595AAEEF01AF41FA14D10AB03AF3809856DDE35FBD02E18A45809360329
ACF5B8136EC07CBC550A59BEF7C88A393CD68D78DB2A5DFBF469C3D02FFFD3B2
1DFE7CBA8CB281B4C8002485CB219AD22C6E76503F3FE34DF9CC129525104AD5
A57EC21CF733A46B22C39FBE586A54E53633D9B6B47266B4A1084BE171D03696
A026FA7A544E4D1139CD650B2CEBB80EB68DBC5D82F253F83F629586E89A5540
57B9862A120162EE8B3F4E8DA71604E693340009C324B840252750485AD8A5BE
240B63473C5E2AE22538695899B1F2CC0C69C7195DDA63FFC07231A6AAD8FAFB
68A234C9BECC29AB2EA93D4D4B5A2BCEB8AB14C9730B1E2F1B972B143DA98F5C
F93DB14805DB66731CE5C25800128822C32CD9A82C230C5BCEB0FEB0423C4EC7
CAB638692995EE0690A278917A0BE8BF278B612A84F1B129137B05A079E7C728
D8AE7462A5C4D2D09AC4B8DF83261D7E280371E1F963484EC4796E7CFA879014
528B7D49E25BBD0E75F70B0F06F5417CA5CB3E7BD25031B04F3AA152186EF35D
59BB974980F8D0478935C577AAC93E198CEF273808B048A910329044B0344247
E6C405F168F785C8B0DDF9A3963D0B1161934B23A5C5C87D078FD970074E35E3
5172BEC6F4580AB5F541431E0E308517DEE57FA72987C464D5A507A40F2C061D
1DBBC2F811A719AE4E389BA5D63E8BE4455B35E59BD39AC3F00B126694FF25EF
5CC6B22EDC09857D3E5F676DD05F584CCE1BF61EBB5E4F958D452D448485D7F6
4F8FEE8212CD7722EA8B45D4B0DBF3B4F29F053C44053E14ED09E3E7A0FCACD3
EFEE1980413950EE4337ADCCE3606B1AB98B58BCFA8CD53AE8C12FFB85421943
A78832A4DE2BB999F2EEB33FEF0BDA5CD019A73B7944C9C20553244EEF2BB5B9
D2B8E55DEE1AF58852B50FD3884410A7B77F47D006E6B076E3F920E0E400838F
718712D374D9AED7F0A85A6D7AE6237AB288B5E6B4F9091D3510AA88179260F7
A7B324FB3485903C00361D3E72B126ED17CC167AF71471691ACCBB9903C3A52B
C4DD75B203A7B04921F0B535C66D2EE6E3C8B5345709E0843D17D3C5727AB54D
C757EB0EB7D66FCE28DB743BC92B2EC376370FD355FA08C74EF1419B052D8F22
71585D7BD902F471D99ED216F355139932AFD4B981D3DE3CD424E81DA2094448
67A5E1A79AFC6F702EA3ABCB6D3BCED34EC348D7790A37C975F5D8C322EC3E80
50A97238F88827E75E2F51339FAD5776CBFBFCFA5B299B012DCADFEB8FE99007
AC7E0C796555994EA20B74A252291322ACF12EE7FE8A738607329268F441F869
9608CCA03A3BB26BB18234A5285B5517039417C972EA0903D75CD251701B242F
82E2205AFBF3D4BC3AAF7485AB65E5FEB2374FF8AACD9F9E421646BE14E2BC94
C540E9287085A2AB71783B16A4DFA77B1E74ABF75AAAA0BF73C080BA84A84C9B
C4093E2151EA61F538857EEF1DB2F599C06F191AD74C9BEBB1440692D6B4EC91
B8324C688D606142E4B244E66A85437E20B97683C69DA60A916F0C6BB9167136
A1638B15D4BC9AE7F57F252FCB0CB9E65724EA4468506521BD15E02CB2F4E5B6
02F5521318234DF89B6FB3948163350E034A3CFA568DD26363EE3B3F55D24A4B
D23C04CFE4EC3C5E8F62FB9F8B01DC905C2EBDD36FA9C48822F17C1071C0C7FC
963342019ACE480DF8D7E491950CC7076CEEE71E5A9BA77C4347E35E54D6D7CD
B0C0D4E78DA460FB06216530AA86C1A034689B87BEEA512B1FC55E137D23FE61
B7D69D1EE4836317F350A08A6091BF4B9D6AC543B626847B574F60E61F9B5C26
7A1DB15FA670091B9CF82B633EABD93E2DE097215FAF5D766B378FE86691BB12
83618D234ECFE8B485CE205C8D8735EC6EC9E847FE8D54CEE9CBC3B88AF70F6D
0A4289976428984A7DFACBD3FE28A8903CB42EB0ECB4F53201F904E211AB3D33
62FEA9B831E269C4FC8B2C762304F33EEA48ACCD58D8B69468E67AB377C6BD16
D11FEFCD7621B1E7E9D9AE9AA465942C8C19D915CFC941150298706EA336F898
80CE4C5B805C3C54F112F7AA206FB9B9A623061C6A4784D911FB585269B20E63
0978C45F9436FB436F629EAD2AB3BF6C3781D123D7B13FA066222C6333F3F59A
B471CF2A7D3ABB64199B13F41E579130F7345021B84227ACE310658B076EA7A4
A87509C43CF8698A87B0FF0AA4C418F45F2D92CFEA647A6508A8ED99A86D14E3
7F10FD04479236E61A1F8F270BFD806FACBBDC9B156D594FEA136F2ED0C853EF
819F0A9796DFC3E85E29F8B488B6F5A8EF8D69FEF91E13323FAE6EAAC2E706DA
8555CEDD6B1BDFD5E9ADEEC72918FDDBC8621128B6FD5D6144F4E38ADD0EDC24
0662FB553E583C4694CC3C440DF86ED83F3D39BB928CC90202CF18A994B50C1E
2D1F62FDFF275A0A7A86DDD96474F7F7DD350006200F6C411D5AB3FEA20864A4
90BF977C9C50690DB088FC074EC1152A769B76E0C0329C0FAB54D836A5923D3E
6DA6278A1DBFD8BC7F2661AC6E39CB510EDF4CCABC332ED75D63D33C69225223
7B500D16D93E9EC5E63A2E348BFB23374230C6A08BB4FB0CDEA7D44636102D47
AB90B92EF9CBE42B793B74454BEB72102588169E618E6B2A23E5D984209F1234
B69484C237E2D1E2E64C0D48329329AF97FF99307C50C7D8E3C246E698C6593F
110D2B1C36425DF22F12BAF2EA2AB937056D3B806BA7F408F14F24D9F568F8AF
8CFA76772D207D8683066FD5D51EDEB3149602DC8C8BF53AB40E03103A5A199C
FC46CA3D96BE9DF24140E64E85C73135133A1C84C65793AEF98DA25996EA2237
63B7102FEF09C25D849D7DAE91025A4C6D38DB10100DAEF25DF62093536D23CC
3D95D3D147D7B7F1A1A055C6F365FF184DE2E1877358910BD08EADBB9EBE4B1F
6A5931DAE2BB997196CD7EE878F929BB0ED1195074A23B3CA9BAF76DBFB5783D
B3C0F6D60E34BE594B65D76B13FD7FA372D5CF659CB8BCC3A264110C2C6A3590
9BA4D3B607DC6C0B52D99ECCF89764E3718CF5AAD7E22763615B2307DC67AF67
232A23714071519EA6CAEF429F2A8C8B5CEE544EA7E773049D63C65BD60F8EA4
F783BAA1C39C3DBC1C0D31756164B01C3061C549A475AF4E7F53DBD9B0D01AC8
00091119DE5CA7DA8A6A6D87679CAE83B9AA2F46B49774F8273B5E98BD87426D
2BDDD573535648C174EA2B71F11EE71DCB66501BB4E9E340BFB3CA7146076DD9
E879857B6B39E7DC1FA69943D9D567ABBE7728EF822007395A5D78C698C7366C
1C453FD7CC6E94C5230EEDFCC22B9C02C7B4DC651BC88CB2EE8097A410A2965E
984E69BF65497EDD146516938637D1DDF0F7255E1242EA0CDCB1659C7C1D4462
EE897EB2BBA0A8746AEF4B275D89AC35C5C0CAFF832B64AC2DDCAD7C4F17AA5F
04F22C03D1492C3091905914B27B4FE5D1AB2DCE37925A2F20FCD23AB28D932E
EFF25B5D70F45018920ED597C2668F1B02C9134BA366936CDFD7FCD625790626
2C8A6F19CD328295CF922FF601D69125F828B4B2DB8F0E5CB31FD4278BEA11CC
BD331D01F6A9C361CD5118B5DDB108EDF3AFDC577DF8F4B125C0BAC2EA874D55
8B0F46BE41309ED965A99750A337D1FCB6E77FE5E754546F80AB2D4A6A6DA3E6
70E6D13BC51C01FAFED3D47621376F2D4E5B392102C671FE3892C7AFAA422153
9F3C13CB018543DD10A913779C7DACB01E8E1587D9C2843A426FD737145AAD59
7845887AAFDB061C48AF125E5940927893B0966B57D782416D6696AC8645E10F
DD80D52109B4D0063C8295771DFFCF89E918F1702F5867DF3636C4F5C223051A
D457CD214D05982AE778AEA1330D4DDD264FD3CC4F0B8F4299DD65D7A610D793
1FB4BAB8ED9D6F1DE7DABAF41491FA65C5A183BB8E20C9C72188A83CB6FCB808
AC9E406B7A6D96510D772EB2BED726D5F12B4487AF4496F8C24DD5A6AD833A4B
A6F96FE67FE603F3DE0BC537FEC194A1FFE1162F4B61C257CED6EAB227200220
E95B195F50D653FC3FA379FB4FA0AD9F83269A99D5503669157A69ECFF4F8876
134E5B5D5D1D811F297520B630C1F81D619BC67D712BF7CEC27CE0B7ED8D31A2
9D7F2D8A6C5E3BADC0B6FA3628B1EB9EAA51B861EEC948584C8F3F9FD7BE2DB0
24F9A283E12327A26FFA9F875020231A7DD8E2B830669F8630FB55709D85C29E
7014A84F5926AC7AD368F48FAD6D6556644783FFE23953B99EBFA7AFFB09D5BD
796ABA334160229587F4DC11F6EC986B036E3D06E4BEDEB3910CC58C443610F2
9206047613EFC7DD4A8448B6413766DDE50E614E2022AFC909284A4D43B2A710
8156D4D3249712471E85A059529C7D6101E2D5C83CA4AC3069202557823519C6
22921A615C4F1256B77DD594B71FF1281B0D67D4D3CD375C79603EFA6E08301A
90A2706528524A9FA3EF41B38E2DC4F1D8AE32B1AF84F6C666443D2E7102592E
101CA38B5112E39CC5E243756B81C136DC8767B74025EF5FAF470A272F57F548
D73FA114A849E99BE97280ED370D6909828DE61CA45D557F087B85E408493226
6C621A42B8A3139CE953DFA96871DFE443579A012D18FD7A725B42CBFFA9B024
C740B0ACCD0067AE6499663C88B604B2A8F947700A630BFD6A51E3BA22FC8326
02DC5027B4CDA589D4204A5A5E0722F328E50B89E6C76EA6E4A377AEF9264FA0
3610C2764987AB638505738399691E13A39724DB49888E5D912DC57F96BE7A66
97F6664AC6B6C1F5650255776305892A6E3CE1A9A347B174992DB8D542BEC631
C8069D0DF3B6F3A21747724BD33EF52F6EB0456379A5018902545D6704FA852D
8E3112888B1EEFA597E1623529F8734C0E096F1CF7FDB89D0ABDF10E46CF71C0
5A7C911225D77F40262094D3FB3A9FE077F2E6D4384BE6BC394E71C5DB81E42C
4C52519520CC06361F075BCCC0E4C90A598B0F9E10ABA225DFE775C4064934FB
530B35AD9155EF03D074AB553BB8EA0A5CE7E682B6A859D852D22ADDC8B4AAE9
F227E41BC8B8E3B1270C1BEB1C4042BBA0D34125774CAC72BC59648DA5099658
3B43EBE59F7AA29B4339C799EA817DC570159B5621D374878E63B56C35023AFC
EB539775182D5C958C053897ABA5BB7950FDC9E0867CF4C02FF879AA4FECB20D
7C10A20D83A8223AB771CA61F867D73D257CCFAAEA1E34B8938673AA6D760A80
C38EFAE41268C40BB07933495A954F676F7DFA49F81BA6B221FAB4FA66294EA2
5AA159168EBB2C3776B64C0436F1F67FCEFC7B15787974F7593F2CC8CF006AEF
8B1106D9E42E1BD62809B0C8A6C144DBAC1FC39DB9BAE78383486A34CEE3A0C0
7BBF8FBE60B6F7491BCC79E2531E1715A18BF843AE09DF06EA99B3174459E7BF
82AD59FD366E775F2BDFA9D987DE8A6A3C971A03327FEC53F1F43913282D7DD4
778565A82A1D003242430EB6FF1DBE8C3D96F2BAFCE0A73639C772AB771A74EB
93E3DAC78B1A952BCB3C63AECB598331F31E58AF3A560C46F0F9A0A0E9FA210E
E258A6860492A232441928AFE6C02A531DB33EE368F0F8789AE88F81F85DBFA4
4D2F9C0DE26C2417D362C41DD7F96DE814CFF0AD50200A157151F7625E63296E
325E2C3344042E09112C7A95D887EEFCA9B9A6A03E80DEE3F0D51C50F7E90CD1
2E44EDF8487C1626E9F42099F4D9EFFB1EA6FC5643B5EA52C15F5AEF6F3D61FE
A77636909877E7CCAA97AD291A3032F4198B12D0D7A61B06D63389A665CC6C82
9A4A06AE64852665BCA6B481C1830FFE95E9F6A8347B4F9354DC900685CE73A8
D5738C2BC3A5CAA87A3BAD79429321A8F96E2E1F02AD70E2FDBEEE625BB25AC4
115789C442E6BEFDADB6D2A741F03577E7AA7BB7E0B5B6601794E5B4C81CF3F7
384A29702F0BA28FB2F1F6BB34DB61A325BE0A37CEE6CC1D4C8F3B8D3031204E
510C0C9D7CDDEBEB00524F2A8AA21C85408FA4D85B5C060328723810DAD7CE08
EB085D29AC7925CE02513B497B58746CDC1EC49ED6114400F4724ECFF05FE0BE
D47B370A4643F4B76AB7BF41CDB0A2CFB2CFF7A3E022256BB39745B643CF704F
17BDC1FA8D6B8D4FA4A4E2AB54280CD07742D72880716E925D1E0F1ABBDF7066
30395891A22C5D5C1344B963C22330524564CF6C39C230A6A9FBF53589E001EF
E2B853747CA6CF900D3224297F610CA618F916ED2887C57FDBAB63E602D113C8
1A461ED958FCE2C6496EAB8EF09A09CC7FBBC0008CF2A70C000FC01D32C0F9D6
62FC2E59673DEF563AECCABF724C09CEEB58C44A37DD52DD42EA7B5C52558761
3D335148791C6FB0E33D901A80A18BB3DF60DF1D9C1F0526611190E892DDAC80
10BE3AB1624D36C6C0F3EE53F3F6B2182D887C905C38154924F4739C650A8EF8
D238C73BD6689A0657DE7F20C2A05133861783867EAA0867AD50B7ACCDDA8AFF
B5FA35F3A681733DAE65FD33F5535C1235C62F5FA085FE263442FA852F66E1E2
044AEE7A98C72AA0DF2D07B1BC8CABC9772F8502DD9589879DD872D4747775D5
CDE9E55C8B4911B8C82EA079623BA19E2CD19ACC174A587D687E9F1425C9DA4B
0B2A389C185F7FCB4561656CD37E950097AA2B3B5EA40431A79BB15A93FF08E3
782FA0F6BF2D9554E7D9855E01803A2E4A4A44D467EB26AD61D0E3DBB92F8F73
013AD9CCB7B29C953456EBCF09E56387D51EC7F689EA1119ED5923656F6B6529
5F00A4A4F6B902A679D7CAAB514DDC66C6966D943FC4A489C3155C53626C0ED4
A3681A84D170419B1D9D825F30DF959CEB4AA8FABA1AB7FCA5E3B9A0C63FADBA
FA0F37397279F2A6314B2DBCC1F6C1B64632B2FDBEC9FE7C7B0BD419C0E6FA6A
77AABA48CD601358BFC654F3C7516FBE690A678288FCA7D897D7E9C788459B39
B30321C6ECAE276B63BD885E1CC36E692F4624D84D70949442CA8BB93B63EEB7
7A5C28328970333D68C7090E454AF9E45392F1B4CA755474D97AC659ACB1B0C3
D46B8C6B8C53ADF57D33E989C41FE327B928E4410E361E59D541ECE44496E5D0
B74C3885F0A33C46EC274A77BC37F4CF7C183FA6844ADA69A86EEEAEEC81170F
40C2ADF359D8B6002BA1B01A8F02C86D0299D8043C4F35B031A2488E7B130462
CAC1C618EA8C7050D043B09368E43CEB4EB4ACAB454C6CB74F0E451C38BE3102
83619DCD7B2DFDC9DCC814084EDBCA0DB7034C57DA2EB014C1532DE7B779D265
3784BDF0B0CD29A39B4B06515964BBF8B495D29D7D5ED039B7AA0610FE700DE5
8303F330D4174CFF671246AAF42E01E6C3B9A69746CD8E49514D2144DC84805F
2CC6A06F395F24385312F08ED2A1FD0A5402021BC1CE44C52EB715CB13A293D6
AB8B3A938D628CF0E8FE7DA6F737726336AFFA73F17C135472030108CD0DF3BE
0F813F424364678789109A668E707C52E55E9B0ABA056F165FAF11A279BA06F8
21D24EDF72ECD263C41A49FF5264C650C4EB8D3587528DFF595862B251C232AF
7B4BB76EDC1CEF784F9E51820F0A0E80E0D1A01FE0D5A739D0D9BE2A07D15C2B
58549F6B8E4A54ACC47A66CE4966A116F68304BC2EEA41651A4F0D768E70F1C0
1E4A7AC43C783B6BFFC4E6E7D6E303529915D709497D1D53C0121C177CA7A3AB
A468FA39B093E77D6F2A7D77A990393CA5CBCA996BE2E5186292AE65265E488E
CF3EF7B3069EF25ECDCE357DC6CBCC1EE0B9D7226A0CF6FC0A11C83C4E7AE0B9
95385A56B21FA5766AB617E37CBD332EB57640CA4878CF17E822E395763F474C
E61D7F5B5320DB4E6C7F70B76CB486438D247D073D2CB071C8B15143C0A3A3C2
1733B85D1285B001D05B7DC83D34152E7A950505550B8420A45DB0FDF9B94F0C
0BD6441DAB9EA47FFE2D1A17D780BD338B7A205499FE433BF6795B119EC6803B
D53A8882D82929177263931B1795019B108DE3495306C998EEB3A70D1E457571
8CF2D0DAAB8488A7787CD10ABB9A367CBA8CED2BADB20B549F8310BF6E72FEAA
21C559B945A22203FAF11FD52AC85B5F20BC36287AD77F1645EFCF7B2F0DF91B
2EE14B1BC50CACC11363B9956CF14ED9447063229ACD93D2CF22ED6687A91676
4EC5D7EF84C28DDEB5E13A0EEA14A3E49EE1B9FBA368B8858506DFE6D4234493
111D20121EFF5D72A830B9E2ADD5E26339D2B5A426A1DF64E50C1BBA1841498B
D5A56107790BE7B3C7F5589B6DE7BBE53504F2B08A80874CF0D889281F4761B0
DCF6D0539AE22FD45086F515FDDA17F86B2C3CEF1E2915D5492161A8DCE38246
532ACA149B0F4009A17BF57484A22EB2F9CF2B71058CCD97763B6A3F95EA4700
66F36D9C2AF45A55EA03A132AAA54B5AC1B745CA3E8A11FAF96EB8FDB5F81E5D
42A27D3BC70BB815896C3C727D60EE52D57B04264069FCE544AAD5E290723AA3
5FBB650B123EF9125AC8AB538565E06699AE5D68759A52096B795842BD8D8CF4
1DC6D30C3B8744042875AD434486947FD83FE1C097719A22BFF5D31C9C6C0FF5
6F9B3DF1963730B8C7858A863A9AB484C68F7021E9A1E1CC9750DBB35D327CB0
63615D5CAB61566957AE18AE6ED6C800EC832708EA1B3EC877FAEF37091968B9
DCDF924979BEE3F3B54090554D08F54200A21BEAEE003B83CC929683EA64F833
C552C5B0B6B2F652D5909461F774D36EF277706253A3B785A51BA3F73CDCAD65
BE718C0072A840C5D661E36F3E27FF79F6F5EE718D4A499D90EDC8267492DFC1
6203B423D096EE2A4B193612337A6D180D9FA91E94F85985CE8137E42846577F
66B459169FE19DCF73C5380BDDFB85442351D5CBAD32CCCAF251A9F2C4CF3C02
2BC1A446906276AD0A5D2E23697DC5DFF896EC8C1916D52E30118488C7F45F09
194096200A65571E7C455D56202342024389C7F3A03283BE32C9F7785F8E9842
20443B845D291928AC72D636AE969256DC91944150153C99FBFF33F784442D49
5C241BF0CB3F2CD4CFA7805F434DFBD7B1180FACA51328C628017AC93638DEA1
21647C09131AF640463D49DBB6803FD753A9E426992ED6BC8BEFEEAD4B80FC2D
950DB053BB719CE9B2D2F75106CCA90E75B241810A1BF88AD26FB7EE9A331172
C242FCC8E3D582A3A1FF6EB2DC3B235BB50BFB85FF25992C81E31E226BD21A3D
8DDBAA07A27A116C80E837DC740E86068952F0A57A5A2C46280FDDDFC1EE8102
8E13027F26BABF3AE38AF75E668A3218998113988006CA5FD98D09AC897D19DF
725A4416514A13C7441651605B9CA5DB8F1C9212688E3204F6E065F3449D4A7F
C310108DC95F8A624BC961432A8722EFD97218971819C58624089FE39F416FB3
FC681EB9D735E487C20BB53D87CEF1C564E90FEA605DC6AEC57939BEC2CF893B
0D3DA4B73D66460D19A6BC8AF994F11D16B0AA8636673A031C4EB0CBCA8FE2C5
FA3DA9FACC64D0405ADA3E1BF030E67C7B8BCD803B4C9ED2CA50CD3A3FFC0B77
BB85D026CE39C8A5D9B970AC4A2E427253956B85189D60E0AFA1B871E3F89A7E
6D828400DB7B47D23006C01F9FA087F96A56472D20E36B733F75CF9D508F9312
5DBCC3489C04F227D170EA0C1E8E021294FBF57A8B95DA6F09568FD192E61959
1F4674B74BF4CA9EE4027FB2EB67845910BBCEB2A446111B25F62DC4A7E06974
D78AB9A9E70887177E32CF45F52768B6086C41EBDD68793AFE11526767E2C752
79BCFBAC46D8224E8952DF582AFE472415598E1470196F65230F7B80B54EBAE4
8E2636D375E1C76993260A62D4613D6131B075F03A20EFFFEE9D2EC17787C412
E7273D2D2B39BB55D84E02F4D2E85E087F117A6F028D2F2BB95F7428AAB77EBC
61E052C1A14548B4769A0AED35C6A162A2F8042E0762A9360B261E0B04884EB5
5F2EA19B8C272B6A0DD805B9332C6A5252A2C113C8D2D5BC6FD512165E6A771F
180872D18B0C8D9EB605E0167D24052ADA3213CA5EBCA0F8DB437B044F7793E5
227B06A188677603D1102A8A685ADFDBC16D110FDBDB306D7C787BDFC298BE54
64E1FDE8190F92D3E68257076676FBC638F830426328CF13180FCF1525D44EC1
73C7282DBC800772F15E98CBAF92057BC238246D6E913A7D988627BF757E7E3A
E3BF9D3AA5AD4F5C80A022B82697B96B8E4D4D6DE09E0ACD2F00DDE25D97C704
AF29B499BC8A5A10BA8FA1D34686001ADF08CCB34048963523892CF3C8706F2B
45C0D0E17A30A5F04527192730F09ECB07AFDE14287A32E1F9046A37CDCD8388
542A2B137E896DDFEC3016130BE8F3E7C2E2C0DD526775B3F19351B2B7870AE7
F5774ED4172CFC330E0BDE8871C5F2A5806161D31FB9F7B11D1F3A161B31F707
2115A793E9B530D6C6977137319321BFDB6A526B7AEA07EB64855B7CE6665D8C
4432AFFCBF37F6900013D0DD0D4B50C2010D519DA028D46BD8A6C8689151A105
3F96BD81D88AF20514F88E8FD48F0B675F296A83AC1938FCE2DF9F4A072D2AD2
B24A76AB48A5F30BA8F41A4BC3C8794BDF5AB41E02A128DCC9D51903ED585E15
81310C8DB07D3494342BEDD3B24A29EE505F477B50A2864C72187FB7CD5893A3
4B24F711FF571E75403D111C5EFE83AB5351D182DE4A22CC6D41C71E83A013BC
707547BA0EDF9A1826A13BCD7AA88C4440621D15736E9DFA4315D50D8B93136E
19807F8AFB0BBDB5417E6D852FF038407BC405811F4814A15B11DC762246E3E7
3952EF80E39E1059BA3B8F6C2B2875ECFF84EA5FB1D26743416B6D20BA817AB4
9D1A8CEB59E5E1B9022D2E4700F5F4896B8AFA47B40437DE05FA5E093727714B
F6D938131BFD0940A7628C8CFC1BBB129973FE3E492016FA5C52E9920B3939DD
7709707FDF9939279A093CEA32F30D8B9715C091CAF8D0B985B3CEC1455E18A3
501C33AF14F3D1F63AD8688325E8C9F025DB20C9F233D885BD42C04DC9300D4C
FA004F89A10237375DB5675E54C76D7531F8D41028432E91C7ADB3A718FF0DA8
87E39D1FFCBA9B1336D70BC262D165E99EC7DB780BA17A05A01B74BF8D0AA0BA
DF717AD3D206B08DBD3EAAFCEDC3F42F4101AC88024884C018C7D0DF61BF5571
6CDDE73E441BAC714E8769A512D05CF9D7D566A0E53CB5B3540FE72436B7BDC9
E33F6D4B2E9C167AD8933A934AC1172ED7DF4001ABAF75230B6DFDB2309D0B97
EEFAC28BAC01932FF6D3254526D953F27586F8CD105752BB4DAD4B0FF3779D39
D39D12059B64E8C6097B5464FE27680D2ACC6987BE974B04232D56DDA60AD254
9E4E3B146AE55A893A5F9B7B3709B544C8412F8BF642048220227B34D001A98B
961862B5BA481DA1E4DB4B8B2EB0731E4E3F32A4B1E22FEFF347BD3FDAC64590
A3E6AA5EACD8729C829BA0F99C9D401B825ACF0CFFA9A4A2416E28BF2EFCBBD3
0636E1F31B355F9617AFD58A54622E52AFE7CEA158E99E37E4773B561C5CD2EE
10814CC2C3E2906A59CD4D305F731ECDEBA2A8C7B93F359219DBEC2EFE13B1C5
E2DE5B1C88FADF22976279F1B8285F5EEBD77006279C91938C746FFB2F9BB185
9B9E19B54C00F58AEEBABF3DD73B968D7E025311BEA11FD3D09B4505A9EDCA73
207EB3018D5C09EA88CA0873AE690E94D43B323B53340EBAAB090E28DB9EEFF9
B99D887C2344393FA89D67F327D58731A241E11468BBA16BA3494A4E80FF1202
C8ADC435799D547BD2B0D0179A96E8C1BBEBFBE83CDE780028E65449802E6C1E
310E78A4D28ADDB131FA22535ED930E9021BEA3D463E8FA8B45EA921B9FED123
083A9D65A4691664E373B5C24B3EB36CB7D5F86AB267E5014A98E1DEA814D34A
D1C22BF3D7E222146343ADA948C30BE1D0DD6BE2E1A4D52E20ADB9D647DE6009
28D0523DF3B1D9C5D34017A12D8C3F1DFD0B90AD438A22F578C292260822E618
B71F2FD585B9685A7A51091536FFA80EA70CFDA85B3EFC1C18FD44FF2BC993B8
8B9FDA9A8CFB92D04ABDE47EFEC71E4973F629B392CE3475109E2605C0463CE5
C32B054A731210DF35A32EB4B613956536D8539B88596E341CB47F5382316B75
38794D9D414DB3BD99FE9772B67F797F9EB5B41391DA87E6AD902DC406EC381B
2E9CEFC29A1772EDCACBCE337B4DCD113B4648D024B94EB181D2943267C158AC
94F834EB78FBA80798F01BC2AF85CBA7D0FCFEE888CC7FFDEFCBD57372571767
CBC51CC2CF1FB9573924D8613BE48CC4826515D027505FDE4F12067CA525859B
73E6FD4FDC8F586559540547A004949564F64A1A197E2A9809F715609F5F30FE
E57E8A403C373E5CDD5962599AE3BA0D086EE6BE16833091C9C061F2F9BAAF63
6F17EB88960EA70F1F0F037DDC9682E486CAB5C7D0D9AF69A89FE5F8EE5CCB4A
2E547457B5E91D7D802FB65F4066B638056F697BA89C4DBFF9B1768E5CB12B87
89A8A267C1EEA6D458112EF1FA8508EE0EAC77FA44C3B89C7255A4F118846B75
70803990AA19F568DEA6D43A6C9B262C5BAF4AD6E854F5D7A6DB6F94CF9340C5
0778EDDB5E0A218C79625498AFDDA45201F039E9AA44ECB7649E3347035449BC
D936328FEDB5C069E86BD275BF88D7E1F8FF373ED07D33E42FF9C37B29DE4002
8C70E43447EFC2E50AD5550235270EA6787A4D6489797FB00B7026D3CAE5BCD3
97BA1FDCA43DFE85D83BF9EE5CDA220987161A2E2BE7F4212FB8E2A9BA738766
4872B574E18981FD2B469D303AD1CEB6594C64FFBBB3F50187B1C11A39A5F66D
239B14CD8EE411C90A03F80E4BC988F98528CE2BF580724B588C348665435FEC
6478D9926ACD273FE63A16FE984DD5FFF5F83DD310DC7E55D254FC01407126D3
973FE22CD3AC4F6FBB0AD7B9689FE02665CFCF412B99167152D35BC0E671E657
EDD871DCE85CD2460FC8F8BA2C70E744D0C9ECB5CDFA5812B81AFFFDD9DC994C
11AC11F9038B2B1B5F0771332BF0149E7CF1D47DE4897284B2FFF95A8A508A19
C3281F49B3A3A92853AE7AD9F459C54082DD302A15ACF17034C74DEA93A04EA9
0994D3233D447E8F87527C35F3CDE94D945A7D93099D13B81C3904DF76D09C57
5A27CD28508B545B6B27BA9173B2B324C4A9667F5692B30D09EFB60C1AA5E9D5
278ACEC4A55F1A082D537B3C1EE890A6FD2ECACE1D265178E45959BD7D3CCA69
C4BCE2D5E9EC06945AB88A39199BFCD1C4FF3CE4851D494EF97D357057B13BE8
E8021D3FB5D5882F227F5EFEADD582C932F59D55E90B924C01FD5FE881F99944
98B9CA251192A91D5EE10D322FDF1A494A3F81C9D5B5AE42F44FB0118252A235
42904AEF8A29BA9972B1C7AA6BA53BA32A081D3006CF35BE5F1041B0EE4D1E1A
FB6B6FA6EFF9D626D24C4FCC956B268B30DF26FC381D8D871D0D96566F0E4910
D17120CEC875CD212E6BC289D87F1E08E6EA810D7009159F1FAF384957485E52
C2815090CA3B1221A12F749E5C41948A9F0B6D3A86FB04163ED36491F24D7C3D
634B25C2C8D2C8569E58941EC067EC4C03A2F8D4D19690C2AFC60980B26361D3
5B0C05E68E1C0C20518533DA77B3495C336CD67106B1EB2CCE2D70A82A8366D5
3A10FA663E1F74935FF1A2BA3EAB6FB86ACAD4DBE2B70E8198A1BC0A952F694D
D22AE64DB1186C10A7C760D3569E5EDD235ABF2CA82D0890A369061A83A29725
5CDA995A30B8144AC2CC69BE5F80E23A8F5206C817E75FD12153EF75A00DC208
92AAEDEDF87704921CCFA16F0DCD60F522EE900DAA6529AEF512224950615DA2
039D4EB3B18C87BC21D806D278CFAB6B8AC894D3DE5A07441A79952846B0AD9E
0F8899CCF1CB0F26A82703271ECB04CC388498F04F23F8B3C50117C0EA512125
DC02C19B85C24B38B1B40D53EBC0422556E76F11E21940DED1DD6815946798BA
5647052C155CCE495AE3EC6EE9C4FADAA72FC2C4A95C05EDBCF7593927317440
E34D425850AF9EFFB5200DCFCEA613CC3A7A4F85B11AC1806B4526F23484D8B7
2BB65CDD626E7FFD23BC99D34FCB2E6586DE317EE3BC34234AEDFA4C83BB0BCB
DA4B8FD30EBFD8E947926A7AD4A39C3E396A1C89BC2DB1381ADB11431C97A8DB
C052426E3C954762E35A9BD114ECEAE9E2018FFE5B97E3F9B57EC47115943BB7
AF6043F860D5D548B166C25921D8DDAD33982E864586C8FDAD35CA3EA60BE1E2
8418837CFC7209F4A0569D19475976933B742305066D1656493996A2A629087A
5949E34D4359CD47A000608F799114BE5D36359D0D3FB0ED01DFD581E9F3F68D
C6F44D503C233895B9C85B82E6828392F3978EFB0530AA2239903E4B3F8196C3
AD3F91E6B9AFFA3E9950914CB0781D5442DC61E235A209A4B764F63C7588955B
F73F38B67E1FDD63579EE3AA49872D498A17C7ECFFAF85013B5C541204F79824
5660D440E80394960014969BD78FD57BCFE092F16FC59B70F1C3D4DE36946FBF
C4D184CB3471F958F98B5D411933162DDE8472D73AE198962F216A97E1BB4621
8720C44A3F16BE706170B67822A5FF7C730360CF6EB23BC007F53624B87091C0
DDC1AC4A2265D10F6A7CEC42FC81D1F4CF2BD3DB3168F736647968BDA608B66B
AE07DEC4257E78246187838F532359D6FBC18512610FC852B07E15D4B6893042
6F3112E17476602F3D7B5AA66AC712573010697ED8B89EFFEF7EF9EF46CD604D
79D4F83161C24A1CA0B8EA185C378E7C7961340E398551177A7D13B2A9214E43
CA381CD2DE3DB70458D95772040A5D25C06408446C9C266DB1BFB84FA980E06F
E4DB4778ED1E2057402F90782F4B7219F31E5A942286CB11A0D89420D72ECB55
F9274DA1D76EB088B8E6123958523931DB4FAA798AE995CEA8507680ACA37850
B30D1BBCDD128AC48359893727FCF9433139132A62240BB9C4839AE787FD2548
7D6E7275F2D61C1D0A16CA68A4AF96E6F89370958884EE230983271ACEDE0DFD
0A5AE49C1E9B1A8D95ACDFD83095F12A656C1E182D115BB3ADC01428F7B73929
7CC4B6A305EA2B3A50C3275885620061EB2DF4472122948167369B0ECDC43A4C
530DB3EA06EF9672983138D713933F67624B5469A467ED1223C8CF29FD813EDD
931A53CB338FE4ED8B20CD1D15987A7716BBFC20EB3DB805CAC99BDB86F253D0
260C1157555524CED262025524283F4864FC0D42139B37EB84B0D6297FA506FD
D296949F8FE9C26D822F0515BF6AE3921693A7B12C5083F0C991CCB5EED23085
111B4757BF7017016826D699540EDCF90853ACE507C388CAA1BF17BBFA4E9D98
849E6AB20FAEFA93C3F0A0CE906A8D14156A2604D976052BCAD16FD258A3016B
F248D1BA01D0E1E9DACA45F94EFC91D568C63F0DF55132EF7CD9A8D1BE060CB3
43627CC5EA64D47B8012CEE096018F0F45B5B14743D409366D9B06578A1C23B4
8A90E45E5BBF004B19B3310F6288DCD79C864499251C58ED888B9CB2CA9BC97C
804325EC599D755882E751A70A0EAE6413953A7B17D211E29E3F949F0338DB92
FCC991DFF7A88316E5FE553BAE20B09A6F8AE40BE89370893222868F3FFB11A8
2E401A42DF13634343E4A666C7A27E6ABF8BD9B53E7CE250174A661C774B556C
7F853DF36DA9DE6913151A57D02371497BA21EA208A185D6B82C973F1935A458
8B34522F89E6B7EACEC2DA13A8D0B66AA0C3A6F585A1C44A2A00554667CFAFF8
A417D246F28CEE9056594C5B6F39E58816C7A84839C069CFBB069C10AF003760
BCE91CFC17FF79588A0DBE8669A47636E612EC6678528E56DDC31E3C30CC36F3
BD12FDBD8233796A985C09A5E2E90A5D8304CE37D3D708FB4C197F972E2941C9
90E9B3AA469E3B149F0E450313D8BEE3496EA31276759299B1095A1B6EF1661A
4DA77B723EEEAE8EF961E3CDB4A8BBDFCC29F4A3B54C712E006E1D6BD9936689
99C3AE0E45D2C688956D013FB0402EF25AAD74978C52E040ADF1D0B06BA5E122
6A5E029527C3FAAA34FB1CE195856BCBEBF18DFA6C417149ED9AD951A3927846
EC08782BE06F828EC06691564896ADBD78625001BED0F468B73136F9AF343903
99CB01AE02D9F65CCD02F475EC35EFA28DE86728F795325D9888D8096ED5DBF2
9A8D720D4C03973D6A85A31C7A02F478B38C81212374608C1E14C26C7B8E3519
77F20C49E981C6F195F1504AB7976BDB0BA9541C902BB62B941674DD58814B73
9CC6A246711262D0BBC0108222DC42AA85CECC350612812534DF15EE532FAEB1
64ECCC2D1D7CA87420015E3B5373A4DB75F295679E9A1CD97971FCC7D20A16D8
3542482971C6209DF01498D6ED3FA6D41F1121F9CCD3E6FB4365972F12C46190
4C87B315A7A14B849FEADF8A4521F41626A60F3EE25E
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
{restore}if
%%EndFont 
%%BeginFont: LMMono10-Regular
%!PS-AdobeFont-1.0: LMMono10-Regular 1.106
%%CreationDate: 22nd January 2008
% Generated by MetaType1 (a MetaPost-based engine)
% Copyright 2003--2008 by B. Jackowski and J.M. Nowacki (on behalf of TeX USERS GROUPS).
% Supported by CSTUG, DANTE eV, GUST, GUTenberg, NTG, and TUG.
% METATYPE1/Type 1 version by B. Jackowski & J. M. Nowacki
% from GUST (http://www.gust.org.pl).
% This work is released under the GUST Font License.
% For the most recent version of this license see
% This work has the LPPL maintenance status `maintained'.
% The Current Maintainer of this work is Bogus\l{}aw Jackowski and Janusz M. Nowacki.
% This work consists of the files listed in the MANIFEST-Latin-Modern.txt file.
% ADL: 778 222 0
%%EndComments
FontDirectory/LMMono10-Regular known{/LMMono10-Regular findfont dup/UniqueID known{dup
/UniqueID get 0 eq exch/FontType get 1 eq and}{pop false}ifelse
{save true}{false}ifelse}{false}ifelse
17 dict begin
/FontInfo 9 dict dup begin
/version(1.106)readonly def
/Notice(Copyright 2003--2008 by B. Jackowski and J.M. Nowacki (on behalf of TeX USERS GROUPS).)readonly def
/FullName(LMMono10-Regular)readonly def
/FamilyName(LMMono10)readonly def
/Weight(Normal)readonly def
/isFixedPitch true def
/ItalicAngle 0 def
/UnderlinePosition -167 def
/UnderlineThickness 69 def
end readonly def
/FontName /LMMono10-Regular def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 0 /.notdef put
readonly def
/PaintType 0 def
/FontType 1 def
/StrokeWidth 0 def
/FontMatrix[0.001 0 0 0.001 0 0]readonly def
%/UniqueID 0 def
/FontBBox{-451 -316 731 1016}readonly def
currentdict end
currentfile eexec
D9D66F633B846A97B686A97E45A3D0AA0525392EECAC163E584A9104D99AD0BC
1B1844A0E222653FA481B8809B26A46F4C483A5D7E95816EA6582584156CFEDE
B994ADCFF4645140E3617E4D7E1B0E4541CB9F562E55829B4DD880AABE2229E9
4A9FA259A734D29BBA91BA1E2055CBEA4339BCBFF98D32CEFF11F296225CAABA
DCA10577A5D431B714726C1278D8101ABD1BD8D0BD0174FFF9148F8C61C241D9
2AD360A28616CB4A0670C1BF105A2B97A25458EAC07B98B8F1ABC91ED489DF5A
340A9C333CA5AF409E52EE1BA5629A1DA85B8B9EA3150173A28A696C6B98D060
4CD8AE5F032FC97BAA1F5394B526DA51B5521D60F8531E0E5A437F5E00E9B683
3F08ED5C6A216D2CA9C1806AEA6B335CD03C87CB35115D28AF52BF955F7F349A
C9C2519FBF9D866A7CC0AB363443FFA4831A9FAF41181CC67437D2315BA0438C
2D2387CED780B0C89728BF50FCD44E9E83FAB34746B8A417D64F6A3378ABB41E
655FEC203D698B28ADFE7F4E92DBA914A99EC52429572D9ED80EB023C537E01E
9E4A40D09D9417817392A223A65B72414BF703DACFE722CFDABF22F430B889F4
78F10384B1AA42BC0699162947733AA28CFE1C6F895AF011BE4D69462DA368DD
E0053158F0014ABEE1F0DA8BF9BA079506AE79E051EBCCB7BBB8D2C132161CB6
19B35E1E9FECC094D9A6076CFA54929EFF586B52FE4402D2EC025D6DCD58A336
F4A5B4D49BBF0C3E6110D43D55077CE8A1EBCC74391EEFE1913FA20F2AE348EB
843E78C800542E95512021F184447244F446ED8EFFA98C77513FAB5FA2F59FD3
532B4D697D9EE88DB732E3D285343D16BD71155A92ACF29FA2A980D26E9D9524
466FCFBB1D451F9AA392333A6E7894401FFD1ABB307EB3B2C5B3A961D2EDC875
BF0BA966C0C9C212D108BA78ED297AE4D564EC84C58B4FED6ED0E184B0671E00
7A6D4F4CEE644E0EDA1A0C34536133ACDAF5072A8B95B71881E6D93FD686DFB9
FD246BF331BAC2ACDB8234E068B12CEC255B4655A9F16A0EB4D085C0315E98B7
C3CC3918C819415305FFAD3576154406C6A4EE753D9AF484110B36E71B639738
157FEA63660CCD40DE243E5B4A2CAA150F2956E15AA3C01AB47DE8B9908BCD8A
425798CCB9717332C22357C0D62F9B2EB84DE06F84221B1FDCC1E198146D83BF
4F3B499DD83177D1E35A9779CD5BB3FEE084E9C930439360DAC904379DAEF266
E8EC1CD2F174945C87770CD195208EA56CC1E588221139EA424EDD2441CCA7AC
9BC05C7A851862E20031E2FB675DFC7BE3CC51FE58FC26FAB5DBB7AB222BCA35
1A5EC765F601CAE8C1A63B99930B70AF8F83ADEE6CAD7951FBF3D7B2F18A5483
9BF443E9FF5A66AED00F22804A5B31B13418130BA661F22AFB5B8B42C09FC53F
4725299207CC83212A4DDCBE0C2A201B9CB49EA61EDD405047825AA849C47F9E
7C396C0FBA34E1611C40142A3D0ADF020BC4EF5A0641324A603608EA9CED3CC4
A8D4AC4B1394A19FCD8E550632C6B917D1C2BC8E88733F061220110198F87E3E
DC35597142F07C21A0E5EEC94A34801B354952F73CB1304CB721184B7D1D9B3D
2BAF8C379476FC910BD87BD590E136AC565250067880F5E7ECD0F788DB3C7D74
E8725B11CF3178D43FB7678053EBA645D18D5D8C0840BD4E0707DD7912E77E70
546C07CD45B42A0839B340CCEC22569071FCC788DFA28F3C30B2F6541C9D7A64
21F96B87E4DD451BE0A249260F17FACCAF4BAC67E3B5488D734F7A11336B032D
4C08B0D2F26D9A9645F2
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
{restore}if
%%EndFont 
TeXDict begin 40258437 52099154 1000 600 600 (CompileEps.dvi)
@start /Fa 177[26 3[26 8[26 65[{ enclmec ReEncodeFont }3
49.8132 /LMMono8-Regular rf /Fb 206[44 49[{ enclmec ReEncodeFont }1
83.022 /LMMono10-Regular rf end
%%EndProlog
%%BeginSetup
%%Feature: *Resolution 600dpi
TeXDict begin
 end
%%EndSetup
TeXDict begin 1 0 bop 0 TeXcolorgray 0 155 a
 tx@Dict begin gsave CM STV CP newpath moveto 3.0 neg 0 rmoveto clip
setmatrix end
 0 155 a
0 155 142 156 v 142 155 a
 currentpoint grestore moveto
 142 155 a 51 67 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0 0 0  setrgbcolor  /ArrowA { moveto
} def /ArrowB { } def /ArrowInside { } def  [ 6.09454 8.12607 -6.09454
8.12607 -6.09454 -8.12607   /Lineto /lineto load def false 1  setlinejoin
 NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5
2.  CLW mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /Length
x2 x1 sub y2 y1 sub Pyth def /dArrowPos 0.5  abs def { /ArrowPos ArrowPos
dArrowPos add def ArrowPos Length gt { exit } if x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } loop }{
/ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos
mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat
} ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto
} repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1 1 1 
setrgbcolor  1. .setopacityalpha  fill  grestore gsave 0.2 SLW 0 0
0  setrgbcolor  1. .setopacityalpha  1 setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.502 0.502 0.502  setrgbcolor  /ArrowA
{ moveto } def /ArrowB { } def /ArrowInside { } def  [ 6.3822 7.8384
-5.80688 7.8384 -5.80688 -8.41373   /Lineto /lineto load def false
1  setlinejoin  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length
0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength
exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1
sub Atan def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /Length
x2 x1 sub y2 y1 sub Pyth def /dArrowPos 0.5  abs def { /ArrowPos ArrowPos
dArrowPos add def ArrowPos Length gt { exit } if x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } loop }{
/ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos
mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat
} ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto
} repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1 1 1 
setrgbcolor  1. .setopacityalpha  fill  grestore gsave 0.1 SLW 0.502
0.502 0.502  setrgbcolor  1. .setopacityalpha  1 setlinecap stroke
 grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.502 0.502 0.502  setrgbcolor  /ArrowA
{ moveto } def /ArrowB { } def /ArrowInside { } def  [ 6.669 7.55159
-5.52008 7.55159 -5.52008 -8.70053   /Lineto /lineto load def false
1  setlinejoin  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length
0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength
exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1
sub Atan def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /Length
x2 x1 sub y2 y1 sub Pyth def /dArrowPos 0.5  abs def { /ArrowPos ArrowPos
dArrowPos add def ArrowPos Length gt { exit } if x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } loop }{
/ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos
mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat
} ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto
} repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1 1 1 
setrgbcolor  1. .setopacityalpha  fill  grestore gsave 0.1 SLW 0.502
0.502 0.502  setrgbcolor  1. .setopacityalpha  1 setlinecap stroke
 grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.502 0.502 0.502  setrgbcolor  /ArrowA
{ moveto } def /ArrowB { } def /ArrowInside { } def  [ 6.95668 7.26393
-5.2324 7.26393 -5.2324 -8.98819   /Lineto /lineto load def false 1
 setlinejoin  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length
0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength
exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1
sub Atan def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /Length
x2 x1 sub y2 y1 sub Pyth def /dArrowPos 0.5  abs def { /ArrowPos ArrowPos
dArrowPos add def ArrowPos Length gt { exit } if x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } loop }{
/ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos
mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat
} ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto
} repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1 1 1 
setrgbcolor  1. .setopacityalpha  fill  grestore gsave 0.1 SLW 0.502
0.502 0.502  setrgbcolor  1. .setopacityalpha  1 setlinecap stroke
 grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.502 0.502 0.502  setrgbcolor  /ArrowA
{ moveto } def /ArrowB { } def /ArrowInside { } def  [ 7.24359 6.977
-4.9455 6.977 -4.9455 -9.27512   /Lineto /lineto load def false 1 
setlinejoin  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length
0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength
exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1
sub Atan def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /Length
x2 x1 sub y2 y1 sub Pyth def /dArrowPos 0.5  abs def { /ArrowPos ArrowPos
dArrowPos add def ArrowPos Length gt { exit } if x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } loop }{
/ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos
mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat
} ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto
} repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1 1 1 
setrgbcolor  1. .setopacityalpha  fill  grestore gsave 0.1 SLW 0.502
0.502 0.502  setrgbcolor  1. .setopacityalpha  1 setlinecap stroke
 grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0 0 0  setrgbcolor  [ -4.65782 6.68935
7.53127 6.68935 7.53127 -9.56277 -4.65782 -9.56277  /Lineto /lineto
load def false 1  setlinejoin NArray n 2 eq { 0 0 /n 3 def } if n 3
lt { n { pop pop } repeat }{ n 3 gt { CheckClosed } if n 2 mul -2 roll
/y0 ED /x0 ED /y1 ED /x1 ED /xx1 x1 def /yy1 y1 def x1 y1 /x1 x0 x1
add 2 div def /y1 y0 y1 add 2 div def x1 y1 moveto /n n 2 sub def /drawArrows
{ x11 y11 0.5  1 gt { /Alpha y12 y11 sub x12 x11 sub atan def /ArrowPos
0.  def /Length x12 x11 sub y12 y11 sub Pyth def /dArrowPos 0.5  abs
def { /ArrowPos ArrowPos dArrowPos add def ArrowPos Length gt { exit
} if x11 Alpha cos ArrowPos mul add y11 Alpha sin ArrowPos mul add
currentdict /ArrowInside known { ArrowInside } if pop pop } loop }{
/ArrowPos 0.  def /dArrowPos 1.  1 gt {1.0 1.  1.0 add div }{ 0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x12 x11 sub
ArrowPos mul x11 add y12 y11 sub ArrowPos mul y11 add currentdict /ArrowInside
known { ArrowInside } if pop pop } repeat } ifelse pop pop Lineto }
def n { 4 copy /y11 ED /x11 ED /y12 ED /x12 ED drawArrows } repeat
x1 y1 x0 y0 6 4 roll 2 copy /y11 ED /x11 ED /y12 y0 def /x12 x0 def
drawArrows /y11 y0 def /x11 x0 def /y12 yy1 def /x12 xx1 def drawArrows
pop pop closepath } ifelse   gsave 1 1 1  setrgbcolor  1. .setopacityalpha
 fill  grestore gsave 0.2 SLW 0 0 0  setrgbcolor  1. .setopacityalpha
 1 setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.2 SLW 0 0 0  setrgbcolor  0.2 SLW 0 0
0  setrgbcolor  /ArrowA { /lineto load stopped { moveto } if } def
/ArrowB { } def /ArrowInside { } def  [ -1.21886 -7.3134 -3.06029 -6.31638
-3.81516 4.20773 -4.65782 6.68935  /currentpoint load stopped pop false
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{ 0.5 } ifelse def BezierNArray
n 1 eq { pop pop }{ 2 copy /y0 ED /x0 ED ArrowA n 4 sub 3 idiv { 6
2 roll 4 2 roll curveto } repeat 6 2 roll 4 2 roll ArrowB /y3 ED /x3
ED /y2 ED /x2 ED /y1 ED /x1 ED /cx x1 x0 sub 3 mul def /cy y1 y0 sub
3 mul def /bx x2 x1 sub 3 mul cx sub def /by y2 y1 sub 3 mul cy sub
def /ax x3 x0 sub cx sub bx sub def /ay y3 y0 sub cy sub by sub def
/getValues { ax t0 3 exp mul bx t0 t0 mul mul add cx t0 mul add x0
add ay t0 3 exp mul by t0 t0 mul mul add cy t0 mul add y0 add ax t
3 exp mul bx t t mul mul add cx t mul add x0 add ay t 3 exp mul by
t t mul mul add cy t mul add y0 add } def /getdL { getValues 3 -1 roll
sub 3 1 roll sub Pyth } def /CurveLength { /u 0 def /du 0.01 def 0
100 { /t0 u def /u u du add def /t u def getdL add } repeat } def /GetArrowPos
{ /ende 0.5  1 gt {ArrowPos} {ArrowPos CurveLength mul} ifelse def
/u 0 def /du 0.01 def /sum 0 def { /t0 u def /u u du add def /t u def
/sum getdL sum add def sum ende gt {exit} if } loop u } def /ArrowPos
0.  def /loopNo 0.5  1 gt {CurveLength 0.5  div cvi }{ 1. } ifelse
def loopNo cvi { /ArrowPos ArrowPos dArrowPos add def /t GetArrowPos
def /t0 t 0.95 mul def getValues ArrowInside pop pop pop pop } repeat
x1 y1 x2 y2 x3 y3 curveto } ifelse   0.2 SLW 0 0 0  setrgbcolor  /ArrowA
{ /lineto load stopped { moveto } if } def /ArrowB { } def /ArrowInside
{ } def  [ 10.97023 -7.3134   /currentpoint load stopped pop /Lineto
/lineto load def false 1  setlinejoin  NArray n 0 eq not { n 1 eq {
0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul
exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2
ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /Length x2 x1 sub y2 y1 sub Pyth def
/dArrowPos 0.5  abs def { /ArrowPos ArrowPos dArrowPos add def ArrowPos
Length gt { exit } if x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } loop }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   0.2 SLW 0 0 0  setrgbcolor  /ArrowA
{ /lineto load stopped { moveto } if } def /ArrowB { } def /ArrowInside
{ } def  [ 7.53127 6.68935 8.37393 4.20773 9.1288 -6.31638  /currentpoint
load stopped pop false /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{ 0.5
} ifelse def BezierNArray n 1 eq { pop pop }{ 2 copy /y0 ED /x0 ED
ArrowA n 4 sub 3 idiv { 6 2 roll 4 2 roll curveto } repeat 6 2 roll
4 2 roll ArrowB /y3 ED /x3 ED /y2 ED /x2 ED /y1 ED /x1 ED /cx x1 x0
sub 3 mul def /cy y1 y0 sub 3 mul def /bx x2 x1 sub 3 mul cx sub def
/by y2 y1 sub 3 mul cy sub def /ax x3 x0 sub cx sub bx sub def /ay
y3 y0 sub cy sub by sub def /getValues { ax t0 3 exp mul bx t0 t0 mul
mul add cx t0 mul add x0 add ay t0 3 exp mul by t0 t0 mul mul add cy
t0 mul add y0 add ax t 3 exp mul bx t t mul mul add cx t mul add x0
add ay t 3 exp mul by t t mul mul add cy t mul add y0 add } def /getdL
{ getValues 3 -1 roll sub 3 1 roll sub Pyth } def /CurveLength { /u
0 def /du 0.01 def 0 100 { /t0 u def /u u du add def /t u def getdL
add } repeat } def /GetArrowPos { /ende 0.5  1 gt {ArrowPos} {ArrowPos
CurveLength mul} ifelse def /u 0 def /du 0.01 def /sum 0 def { /t0
u def /u u du add def /t u def /sum getdL sum add def sum ende gt {exit}
if } loop u } def /ArrowPos 0.  def /loopNo 0.5  1 gt {CurveLength
0.5  div cvi }{ 1. } ifelse def loopNo cvi { /ArrowPos ArrowPos dArrowPos
add def /t GetArrowPos def /t0 t 0.95 mul def getValues ArrowInside
pop pop pop pop } repeat x1 y1 x2 y2 x3 y3 curveto } ifelse   gsave
1 1 1  setrgbcolor  1. .setopacityalpha  fill  grestore gsave 0.2 SLW
0 0 0  setrgbcolor  1. .setopacityalpha  1 setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0 0 0  setrgbcolor  /ArrowA { moveto
} def /ArrowB { } def /ArrowInside { } def  [ -4.65782 -9.56277 -6.09454
-8.12607   /Lineto /lineto load def false 1  setlinejoin  NArray n
0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW
mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /Length x2
x1 sub y2 y1 sub Pyth def /dArrowPos 0.5  abs def { /ArrowPos ArrowPos
dArrowPos add def ArrowPos Length gt { exit } if x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } loop }{
/ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos
mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat
} ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto
} repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1 1 1 
setrgbcolor  1. .setopacityalpha  fill  grestore gsave 0.2 SLW 0 0
0  setrgbcolor  1. .setopacityalpha  1 setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0 0 0  setrgbcolor  /ArrowA { moveto
} def /ArrowB { } def /ArrowInside { } def  [ -4.65782 6.68935 -6.09454
8.12607   /Lineto /lineto load def false 1  setlinejoin  NArray n 0
eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul
add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /Length x2
x1 sub y2 y1 sub Pyth def /dArrowPos 0.5  abs def { /ArrowPos ArrowPos
dArrowPos add def ArrowPos Length gt { exit } if x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } loop }{
/ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos
mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat
} ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto
} repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1 1 1 
setrgbcolor  1. .setopacityalpha  fill  grestore gsave 0.2 SLW 0 0
0  setrgbcolor  1. .setopacityalpha  1 setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0 0 0  setrgbcolor  /ArrowA { moveto
} def /ArrowB { } def /ArrowInside { } def  [ 7.53127 6.68935 6.09454
8.12607   /Lineto /lineto load def false 1  setlinejoin  NArray n 0
eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul
add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /Length x2
x1 sub y2 y1 sub Pyth def /dArrowPos 0.5  abs def { /ArrowPos ArrowPos
dArrowPos add def ArrowPos Length gt { exit } if x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } loop }{
/ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos
mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat
} ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto
} repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1 1 1 
setrgbcolor  1. .setopacityalpha  fill  grestore gsave 0.2 SLW 0 0
0  setrgbcolor  1. .setopacityalpha  1 setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0 0 0  setrgbcolor  /ArrowA { moveto
} def /ArrowB { } def /ArrowInside { } def  [ 10.97023 -7.3134 -1.21886
-7.3134   /Lineto /lineto load def false 1  setlinejoin  NArray n 0
eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul
add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /Length x2
x1 sub y2 y1 sub Pyth def /dArrowPos 0.5  abs def { /ArrowPos ArrowPos
dArrowPos add def ArrowPos Length gt { exit } if x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } loop }{
/ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos
mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat
} ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto
} repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1 1 1 
setrgbcolor  1. .setopacityalpha  fill  grestore gsave 0.2 SLW 0 0
0  setrgbcolor  1. .setopacityalpha  1 setlinecap stroke  grestore
end
 
@endspecial
51 67 a
 tx@Dict begin { 2.24924 -0.62405 } PutCoor PutBegin  end
 51 67 a -22 w Fb(1)51 67 y
 tx@Dict begin  PutEnd  end
 51 67 a 51 67 a
 tx@Dict begin { 3.6567 -6.50087 } PutCoor PutBegin  end
 51
67 a -40 w Fa(JAN)51 67 y
 tx@Dict begin  PutEnd  end
 51 67 a eop end
%%Trailer

userdict /end-hook known{end-hook}if
%%EOF
