%%
%% This is file `cool.sty',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% cool.dtx  (with options: `package')
%% 
%% This is a generated file
%% 
%% This file may be distributed and/or modified under the
%% conditions of the Limited General Product License
%% 
\NeedsTeXFormat{LaTeX2e}[1999/12/01]
\ProvidesPackage{cool}
 [2006/12/29 v1.35 COntent Oriented LaTeX]
\RequirePackage{ifthen}
\RequirePackage{coollist}
\RequirePackage{coolstr}
\RequirePackage{forloop}
\RequirePackage{amsmath}
\RequirePackage{amssymb}
\RequirePackage{bbm}
%% \CharacterTable
%%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%%   Digits        \0\1\2\3\4\5\6\7\8\9
%%   Exclamation   \!     Double quote  \"     Hash (number) \#
%%   Dollar        \$     Percent       \%     Ampersand     \&
%%   Acute accent  \'     Left paren    \(     Right paren   \)
%%   Asterisk      \*     Plus          \+     Comma         \,
%%   Minus         \-     Point         \.     Solidus       \/
%%   Colon         \:     Semicolon     \;     Less than     \<
%%   Equals        \=     Greater than  \>     Question mark \?
%%   Commercial at \@     Left bracket  \[     Backslash     \\
%%   Right bracket \]     Circumflex    \^     Underscore    \_
%%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%%   Right brace   \}     Tilde         \~}
\newcounter{COOL@ct} %just a general counter
\newcounter{COOL@ct@}%just a general counter
\newcommand{\inp}[2][0cm]{\mathopen{}\left(#2\parbox[h][#1]{0cm}{}\right)}
        % in parentheses ()
\newcommand{\inb}[2][0cm]{\mathopen{}\left[#2\parbox[h][#1]{0cm}{}\right]}
        % in brackets []
\newcommand{\inbr}[2][0cm]{\mathopen{}\left\{#2\parbox[h][#1]{0cm}{}\right\}}
\newcommand{\inap}[2][0cm]{\mathopen{}\left<{#2}\parbox[h][#1]{0cm}{}\right>}
\newcommand{\nop}[1]{\mathopen{}\left.{#1}\right.}
\let\COOL@decide@paren@no@type=\relax
\newcommand{\COOL@decide@paren}[3][\COOL@decide@paren@no@type]{%
\ifthenelse{ \equal{#1}{\COOL@decide@paren@no@type} }%
{%
\def\COOL@decide@paren@type{\csname COOL@notation@#2Paren\endcsname}%
}%
{%
\def\COOL@decide@paren@type{#1}%
}%
\ifthenelse{ \equal{\COOL@decide@paren@type}{none} }%
{%
#3%
}%
{%
\ifthenelse{ \equal{\COOL@decide@paren@type}{p} }%
{%
\inp{#3}%
}%
{%
\ifthenelse{ \equal{\COOL@decide@paren@type}{b} }%
{%
\inb{#3}%
}%
{%
\ifthenelse{ \equal{\COOL@decide@paren@type}{br} }%
{%
\inbr{#3}%
}%
{%
\ifthenelse{ \equal{\COOL@decide@paren@type}{ap} }%
{%
\inap{#3}%
}%
{%
\ifthenelse{ \equal{\COOL@decide@paren@type}{inv} }%
{%
\nop{#3}%
}%
{%
\PackageError{cool}{Invalid Parenthesis Option}%
{*Paren can only be `none', `p', `b', `br', `ap', `inv'}%
}%
}%
}%
}%
}%
}%
}
\newcommand{\COOL@decide@indicies}[3]{%
\def\COOL@decide@indicies@placement%
{\csname COOL@notation@#1Indicies\endcsname}%
\ifthenelse{\equal{\COOL@decide@indicies@placement}{local}}%
{%
\ifthenelse{\equal{#2}{u}}%
{^{#3}}%
{_{#3}}%
}%
{%
\ifthenelse{\equal{\COOL@decide@indicies@placement}{up}}%
{%
{^{#3}}%
}%
{%
\ifthenelse{\equal{\COOL@decide@indicies@placement}{down}}%
{%
{_{#3}}%
}%
{%
\PackageError{cool}{Invalid Option Sent}%
{#1Indices can only be 'up', 'down', or 'local'}%
}%
}%
}%
}
\newcommand{\Style}[1]{%
\COOL@keyeater#1,\COOL@keystop\COOL@keyend%
}
\newcommand{\COOL@keystop}{@@@}%
\def\COOL@keyeater#1=#2,#3\COOL@keyend{%
\ifx#3\COOL@keystop%
\expandafter\gdef\csname COOL@notation@#1\endcsname{#2}%
\else%
\expandafter\gdef\csname COOL@notation@#1\endcsname{#2}%
\COOL@keyeater#3\COOL@keyend%
\fi%
}
\newcommand{\UseStyleFile}[1]{}
\newcommand{\COOL@notation@ISymb}{i}
\newcommand{\I}{\COOL@notation@ISymb}
\newcommand{\COOL@notation@ESymb}{e}
\newcommand{\E}{\COOL@notation@ESymb}
\newcommand{\COOL@notation@PISymb}{\pi}
\newcommand{\PI}{\COOL@notation@PISymb}
\newcommand{\GoldenRatio}{\varphi}
\newcommand{\COOL@notation@EulerGammaSymb}{\gamma}
\newcommand{\EulerGamma}{\COOL@notation@EulerGammaSymb}
\newcommand{\Catalan}{C}
\newcommand{\Glaisher}{\mathord{\operatorname{Glaisher}}}
\newcommand{\Khinchin}{\mathord{\operatorname{Khinchin}}}
\newcommand{\Infinity}{\infty}
\newcommand{\Indeterminant}{%
\mathchoice%
{\mbox{\textrm>}}%
{\mbox{\small>}}%
{\mbox{\scriptsize>}}%
{\mbox{\tiny>}}%
}
\newcommand{\DirectedInfinity}[1]{#1 \, \infty}
\newcommand{\DirInfty}[1]{\DirectedInfinity{#1}}
\newcommand{\ComplexInfinity}{\tilde{\infty}}
\newcommand{\CInfty}{\ComplexInfinity}
\newcommand{\COOL@notation@ExpParen}{p}
\newcommand{\Exp}[1]
{%
\exp\COOL@decide@paren{Exp}{#1}%
}
\newcommand{\COOL@notation@LogParen}{none}
\newcommand{\COOL@notation@LogBaseESymb}{ln}% 'ln', 'log'
\newcommand{\COOL@notation@LogShowBase}{at will}% 'at will', 'always'
\newcommand{\Log}[2][\E]
{%
\ifthenelse{ \equal{\COOL@notation@LogShowBase}{at will} }%
{%
\ifthenelse{ \equal{#1}{\E} }%
{%
\ifthenelse{ \equal{\COOL@notation@LogBaseESymb}{ln} }%
{%
\ln \COOL@decide@paren{Log}{#2}%
}%
{%
\ifthenelse{ \equal{\COOL@notation@LogBaseESymb}{log} }%
{%
\log \COOL@decide@paren{Log}{#2}%
}%
{%
\PackageError{cool}{Invalid Option Sent}%
{LogBaseESymb can only be `ln' or `log'}%
}%
}%
}%
{%
\ifthenelse{ \equal{#1}{10} \AND
\NOT \equal{\COOL@notation@LogBaseESymb}{log}  }%
{%
\log \COOL@decide@paren{Log}{#2}%
}%
{%
\log_{#1} \COOL@decide@paren{Log}{#2}%
}%
}%
}%
{%
\ifthenelse{ \equal{\COOL@notation@LogShowBase}{always} }%
{%
\log_{#1}\COOL@decide@paren{Log}{#2}%
}%
{%
\PackageError{cool}{Invalid Option Sent}%
{LogShowBase can only be 'at will' or 'always'}%
}%
}%
}
\newcommand{\COOL@notation@SinParen}{p}
\newcommand{\Sin}[1]{\sin\COOL@decide@paren{Sin}{#1}}
\newcommand{\COOL@notation@CosParen}{p}
\newcommand{\Cos}[1]{\cos\COOL@decide@paren{Cos}{#1}}
\newcommand{\COOL@notation@TanParen}{p}
\newcommand{\Tan}[1]{\tan\COOL@decide@paren{Tan}{#1}}
\newcommand{\COOL@notation@CscParen}{p}
\newcommand{\Csc}[1]{\csc\COOL@decide@paren{Csc}{#1}}
\newcommand{\COOL@notation@SecParen}{p}
\newcommand{\Sec}[1]{\sec\COOL@decide@paren{Sec}{#1}}
\newcommand{\COOL@notation@CotParen}{p}
\newcommand{\Cot}[1]{\cot\COOL@decide@paren{Cot}{#1}}
\def\COOL@notation@ArcTrig{inverse}
\newcommand{\COOL@notation@ArcSinParen}{p}
\newcommand{\ArcSin}[1]{%
\ifthenelse{ \equal{\COOL@notation@ArcTrig}{inverse} }%
{%
\sin^{-1}\COOL@decide@paren{ArcSin}{#1}%
}
{
\ifthenelse{\equal{\COOL@notation@ArcTrig}{arc}}%
{%
\arcsin\COOL@decide@paren{ArcSin}{#1}%
}%
{%
\PackageError{cool}{Invalid option sent}{}%
}%
}%
}
\newcommand{\COOL@notation@ArcCosParen}{p}
\newcommand{\ArcCos}[1]{%
\ifthenelse{ \equal{\COOL@notation@ArcTrig}{inverse} }%
{%
\cos^{-1}\COOL@decide@paren{ArcCos}{#1}%
}%
{%
\ifthenelse{\equal{\COOL@notation@ArcTrig}{arc}}%
{%
\arccos\COOL@decide@paren{ArcCos}{#1}%
}%
{%
\PackageError{cool}{Invalid option sent}{}%
}%
}%
}
\newcommand{\COOL@notation@ArcTanParen}{p}
\newcommand{\ArcTan}[1]{%
\ifthenelse{ \equal{\COOL@notation@ArcTrig}{inverse} }%
{%
\tan^{-1}\COOL@decide@paren{ArcTan}{#1}%
}%
{%
\ifthenelse{\equal{\COOL@notation@ArcTrig}{arc}}%
{%
\arctan\COOL@decide@paren{ArcTan}{#1}%
}%
{%
\PackageError{cool}{Invalid option sent}{}%
}%
}%
}
\newcommand{\COOL@notation@ArcCscParen}{p}
\newcommand{\ArcCsc}[1]{\csc^{-1}\COOL@decide@paren{ArcCsc}{#1}}
\newcommand{\COOL@notation@ArcSecParen}{p}
\newcommand{\ArcSec}[1]{\sec^{-1}\COOL@decide@paren{ArcSec}{#1}}
\newcommand{\COOL@notation@ArcCotParen}{p}
\newcommand{\ArcCot}[1]{\cot^{-1}\COOL@decide@paren{ArcCot}{#1}}
\newcommand{\COOL@notation@SinhParen}{p}
\newcommand{\Sinh}[1]{\sinh\COOL@decide@paren{Sinh}{#1}}
\newcommand{\COOL@notation@CoshParen}{p}
\newcommand{\Cosh}[1]{\cosh\COOL@decide@paren{Cosh}{#1}}
\newcommand{\COOL@notation@TanhParen}{p}
\newcommand{\Tanh}[1]{\tanh\COOL@decide@paren{Tanh}{#1}}
\newcommand{\COOL@notation@CschParen}{p}
\DeclareMathOperator{\csch}{csch}
\newcommand{\Csch}[1]{\csch\COOL@decide@paren{Csch}{#1}}
\newcommand{\COOL@notation@SechParen}{p}
\DeclareMathOperator{\sech}{sech}
\newcommand{\Sech}[1]{\sech\COOL@decide@paren{Sech}{#1}}
\newcommand{\COOL@notation@CothParen}{p}
\newcommand{\Coth}[1]{\coth\COOL@decide@paren{Coth}{#1}}
\newcommand{\COOL@notation@ArcSinhParen}{p}
\newcommand{\ArcSinh}[1]{\sinh^{-1}\COOL@decide@paren{ArcSinh}{#1}}
\newcommand{\COOL@notation@ArcCoshParen}{p}
\newcommand{\ArcCosh}[1]{\cosh^{-1}\COOL@decide@paren{ArcCosh}{#1}}
\newcommand{\COOL@notation@ArcTanhParen}{p}
\newcommand{\ArcTanh}[1]{\tanh^{-1}\COOL@decide@paren{ArcTanh}{#1}}
\newcommand{\COOL@notation@ArcCschParen}{p}
\newcommand{\ArcCsch}[1]{\csch^{-1}\COOL@decide@paren{ArcCsch}{#1}}
\newcommand{\COOL@notation@ArcSechParen}{p}
\newcommand{\ArcSech}[1]{\sech^{-1}\COOL@decide@paren{ArcSech}{#1}}
\newcommand{\COOL@notation@ArcCothParen}{p}
\newcommand{\ArcCoth}[1]{\coth^{-1}\COOL@decide@paren{ArcCoth}{#1}}
\newcommand{\LambertW}[1]{\ProductLog{#1}}
\newcommand{\COOL@notation@ProductLogParen}{p}
\newcommand{\ProductLog}[1]{%
\listval{#1}{0}%
\ifthenelse{\value{COOL@listpointer}=1}%
{%
W\COOL@decide@paren{ProductLog}{#1}%
}%
{%
\ifthenelse{\value{COOL@listpointer}=2}%
{%
W_{\listval{#1}{1}}\COOL@decide@paren{ProductLog}{\listval{#1}{2}}%
}%
{%
\PackageError{cool}{`ProductLog' Invaid Argument}%
{Must have a comma separated list of length 1 or 2}
}%
}%
}
\newcommand{\COOL@notation@MaxParen}{p}
\newcommand{\Max}[1]{\max\COOL@decide@paren{Max}{#1}}
\newcommand{\COOL@notation@MinParen}{p}
\newcommand{\Min}[1]{\min\COOL@decide@paren{Min}{#1}}
\newcommand{\COOL@notation@BesselJSymb}{J}
\newcommand{\COOL@notation@BesselJParen}{p}
\newcommand{\BesselJ}[2]%
{\COOL@notation@BesselJSymb_{#1}\COOL@decide@paren{BesselJ}{#2}}
\newcommand{\COOL@notation@BesselYSymb}{Y}
\newcommand{\COOL@notation@BesselYParen}{p}
\newcommand{\BesselY}[2]%
{\COOL@notation@BesselYSymb_{#1}\COOL@decide@paren{BesselY}{#2}}
\newcommand{\COOL@notation@BesselISymb}{I}
\newcommand{\COOL@notation@BesselIParen}{p}
\newcommand{\BesselI}[2]%
{\COOL@notation@BesselISymb_{#1}\COOL@decide@paren{BesselI}{#2}}
\newcommand{\COOL@notation@BesselKSymb}{K}
\newcommand{\COOL@notation@BesselKParen}{p}
\newcommand{\BesselK}[2]%
{\COOL@notation@BesselKSymb_{#1}\COOL@decide@paren{BesselK}{#2}}
\newcommand{\COOL@notation@AiryAiParen}{p}
\DeclareMathOperator{\AiryAiSymb}{Ai}
\newcommand{\AiryAi}[1]{\AiryAiSymb\COOL@decide@paren{AiryAi}{#1}}
\newcommand{\COOL@notation@AiryBiParen}{p}
\DeclareMathOperator{\AiryBiSymb}{Bi}
\newcommand{\AiryBi}[1]{\AiryBiSymb\COOL@decide@paren{AiryBi}{#1}}
\newcommand{\COOL@notation@StruveHParen}{p}
\newcommand{\StruveH}[2]{ {\bf H}_{#1}\COOL@decide@paren{StruveH}{#2}}
\newcommand{\COOL@notation@StruveLParen}{p}
\newcommand{\StruveL}[2]{ {\bf L}_{#1}\COOL@decide@paren{StruveL}{#2}}
\newcommand{\Floor}[1]{\lfloor #1 \rfloor}
\newcommand{\Ceiling}[1]{\lceil #1 \rceil}
\newcommand{\Round}[1]{\lfloor #1 \rceil}
\newcommand{\COOL@notation@IntegerPartParen}{p}
\DeclareMathOperator{\iPartSymb}{int}
\newcommand{\iPart}[1]{\iPartSymb\COOL@decide@paren{IntegerPart}{#1}}
\newcommand{\IntegerPart}[1]{\iPart{#1}}
\newcommand{\COOL@notation@FractionalPartParen}{p}
\DeclareMathOperator{\fPartSymb}{frac}
\newcommand{\fPart}[1]{\fPartSymb\COOL@decide@paren{FractionalPart}{#1}}
\newcommand{\FractionalPart}[1]{\fPart{#1}}
\newcommand{\COOL@notation@ModDisplay}{mod}
\newcommand{\Mod}[2]{%
\ifthenelse{\equal{\COOL@notation@ModDisplay}{mod}}%
{%
#1 \mod #2%
}%
{ \ifthenelse{\equal{\COOL@notation@ModDisplay}{bmod}}%
{%
#1 \bmod #2%
}%
{ \ifthenelse{\equal{\COOL@notation@ModDisplay}{pmod}}%
{%
#1 \pmod #2%
}%
{\ifthenelse{\equal{\COOL@notation@ModDisplay}{pod}}%
{%
#1 \pod #2%
}%
{%
\PackageError{cool}{Invalid Option Sent}%
{ModDisplay can only be `mod', `bmod', `pmod', or `pod'}%
}}}}%
}
\newcommand{\COOL@notation@QuotientParen}{p}
\DeclareMathOperator{\QuotientSymb}{quotient}
\newcommand{\Quotient}[2]%
{\QuotientSymb\COOL@decide@paren{Quotient}{#1,#2}}
\newcommand{\COOL@notation@GCDParen}{p}
\newcommand{\GCD}[1]{\gcd\COOL@decide@paren{GCD}{#1}}
\newcommand{\COOL@notation@ExtendedGCDParen}{p}
\DeclareMathOperator{\ExtendedGCDSymb}{egcd}
\newcommand{\ExtendedGCD}[2]%
{\ExtendedGCDSymb\COOL@decide@paren{ExtendedGCD}{#1,#2}}
\newcommand{\EGCD}[2]{\ExtendedGCD{#1}{#2}}
\newcommand{\COOL@notation@LCMParen}{p}
\DeclareMathOperator{\LCMSymb}{lcm}
\newcommand{\LCM}[1]{\LCMSymb\COOL@decide@paren{LCM}{#1}}
\newcommand{\COOL@notation@FibonacciParen}{p}
\newcommand{\Fibonacci}[1]{%
\liststore{#1}{COOL@Fibonacci@arg@}%
\listval{#1}{0}%
\ifthenelse{\value{COOL@listpointer} = 1}%
{%
F_{#1}%
}%
{ \ifthenelse{\value{COOL@listpointer} = 2}%
{%
F_{\COOL@Fibonacci@arg@i}%
\COOL@decide@paren{Fibonacci}{\COOL@Fibonacci@arg@ii}%
}%
{%
\PackageError{cool}{Invalid Argument}%
{`Fibonacci' can only accept a
comma separate list of length 1 or 2}%
}}%
}
\newcommand{\COOL@notation@EulerParen}{p}
\newcommand{\Euler}[1]{%
\liststore{#1}{COOL@Euler@arg@}%
\listval{#1}{0}%
\ifthenelse{\value{COOL@listpointer} = 1}%
{%
E_{#1}%
}%
{ \ifthenelse{\value{COOL@listpointer} = 2}%
{%
E_{\COOL@Euler@arg@i}%
\COOL@decide@paren{Euler}{\COOL@Euler@arg@ii}%
}%
{%
\PackageError{cool}{Invalid Argument}%
{`Euler' can only accept a
comma separate list of length 1 or 2}%
}}%
}
\newcommand{\COOL@notation@BernoulliParen}{p}
\newcommand{\Bernoulli}[1]{%
\liststore{#1}{COOL@Bernoulli@arg@}%
\listval{#1}{0}%
\ifthenelse{\value{COOL@listpointer} = 1}%
{%
B_{#1}%
}%
{ \ifthenelse{\value{COOL@listpointer} = 2}%
{%
B_{\COOL@Bernoulli@arg@i}%
\COOL@decide@paren{Bernoulli}{\COOL@Bernoulli@arg@ii}%
}%
{%
\PackageError{cool}{Invalid Argument}%
{`Bernoulli' can only accept a
comma separate list of length 1 or 2}%
}}%
}
\newcommand{\StirlingSOne}[2]{S_{#1}^{\inp{#2}}}
\newcommand{\StirlingSTwo}[2]{{\cal S}_{#1}^{\inp{#2}}}
\newcommand{\COOL@notation@PartitionsPParen}{p}
\newcommand{\PartitionsP}[1]{p\COOL@decide@paren{PartitionsP}{#1}}
\newcommand{\COOL@notation@PartitionsQParen}{p}
\newcommand{\PartitionsQ}[1]{q\COOL@decide@paren{PartitionsQ}{#1}}
\newcommand{\COOL@notation@DiscreteDeltaParen}{p}
\newcommand{\DiscreteDelta}[1]%
{\delta\COOL@decide@paren{DiscreteDelta}{#1}}
\newcommand{\COOL@notation@KroneckerDeltaUseComma}{false}%
\newcommand{\COOL@notation@KroneckerDeltaIndicies}{local}
\newcommand{\KroneckerDelta}[2][u]{%
\liststore{#2}{COOL@arg@}%
\listval{#2}{0}%
\def\COOL@arg@temp{}%
\forLoop{1}{\value{COOL@listpointer}}{COOL@ct}%
{%
\ifthenelse{\equal{\COOL@notation@KroneckerDeltaUseComma}{true}}%
{%
\ifthenelse{\NOT \value{COOL@ct} = 1}
{%
\edef\COOL@arg@temp%
{\COOL@arg@temp, \csname COOL@arg@\roman{COOL@ct}\endcsname}%
}%
{%
\edef\COOL@arg@temp%
{\COOL@arg@temp \csname COOL@arg@\roman{COOL@ct}\endcsname}%
}%
}%
{%
\edef\COOL@arg@temp%
{\COOL@arg@temp \csname COOL@arg@\roman{COOL@ct}\endcsname}%
}%
}%
\delta\COOL@decide@indicies{KroneckerDelta}{#1}{\COOL@arg@temp}%
}
\newcommand{\COOL@notation@LeviCivitaUseComma}{false}
\newcommand{\COOL@notation@LeviCivitaIndicies}{local}
\newcommand{\LeviCivita}[2][u]{%
\liststore{#2}{COOL@arg@}%
\listval{#2}{0}%
\def\COOL@arg@temp{}%
\forLoop{1}{\value{COOL@listpointer}}{COOL@ct}%
{%
\ifthenelse{\equal{\COOL@notation@LeviCivitaUseComma}{true}}%
{%
\ifthenelse{\NOT \value{COOL@ct} = 1}%
{%
\edef\COOL@arg@temp%
{\COOL@arg@temp, \csname COOL@arg@\roman{COOL@ct}\endcsname}%
}%
{%
\edef\COOL@arg@temp%
{\COOL@arg@temp \csname COOL@arg@\roman{COOL@ct}\endcsname}%
}%
}%
{%
\edef\COOL@arg@temp%
{\COOL@arg@temp \csname COOL@arg@\roman{COOL@ct}\endcsname}%
}%
}%
\epsilon\COOL@decide@indicies{LeviCivita}{#1}{\COOL@arg@temp}%
}%
\newcommand{\Signature}[2][u]{\LeviCivita[#1]{#2}}
\newcommand{\COOL@notation@HermiteHParen}{p}
\newcommand{\COOL@notation@HermiteHSymb}{H}
\newcommand{\HermiteH}[2]%
{\COOL@notation@HermiteHSymb_{#1}\COOL@decide@paren{HermiteH}{#2}}
\newcommand{\COOL@notation@LaugerreLParen}{p}
\newcommand{\COOL@notation@LaugerreLSymb}{L}
\newcommand{\LaugerreL}[1]{%
\liststore{#1}{COOL@list@temp@}%
\listval{#1}{0}%
\ifthenelse{\value{COOL@listpointer}=2}%
{%
\COOL@notation@LaugerreLSymb_{\COOL@list@temp@i}%
\COOL@decide@paren{LaugerreL}{\COOL@list@temp@ii}%
}%
{ \ifthenelse{\value{COOL@listpointer}=3}%
{%
\COOL@notation@LaugerreLSymb_{\COOL@list@temp@i}^{\COOL@list@temp@ii}%
\COOL@decide@paren{LaugerreL}{\COOL@list@temp@iii}%
}%
{%
\PackageError{cool}{Invalid Argument}%
{`LaugerrL' only accepts a comma separated list of length 2 or 3}%
}}%
}
\newcommand{\COOL@notation@LegendrePParen}{p}
\newcommand{\COOL@notation@LegendrePSymb}{P}
\newcommand{\LegendreP}[1]{%
\liststore{#1}{COOL@LegendreP@arg@}%
\listval{#1}{0}%
\ifthenelse{\value{COOL@listpointer} = 2}%
{%
\COOL@notation@LegendrePSymb_{\COOL@LegendreP@arg@i}%
\COOL@decide@paren{LegendreP}{\COOL@LegendreP@arg@ii}%
}%
{ \ifthenelse{\value{COOL@listpointer} = 3}%
{%
\COOL@notation@LegendrePSymb_{\COOL@LegendreP@arg@i}%
^{\COOL@LegendreP@arg@ii}%
\COOL@decide@paren{LegendreP}{\COOL@LegendreP@arg@iii}%
}%
{ \ifthenelse{\value{COOL@listpointer} = 4}%
{%
\isint{\COOL@LegendreP@arg@iii}{COOL@isint}%
\ifthenelse{\boolean{COOL@isint}}%
{%
\ifcase\COOL@LegendreP@arg@iii\relax%
\PackageError{cool}{Invalid Argument}%
{`LegendreP' third argument must be $>$ 1}%
\or%
\PackageError{cool}{Invalid Argument}%
{`LegendreP' third argument must be $>$ 1}%
\or%
\COOL@notation@LegendrePSymb_{\COOL@LegendreP@arg@i}%
^{\COOL@LegendreP@arg@ii}%
\COOL@decide@paren{LegendreP}{\COOL@LegendreP@arg@iv}%
\or%
{\cal P}_{\COOL@LegendreP@arg@i}%
^{\COOL@LegendreP@arg@ii}%
\COOL@decide@paren{LegendreP}{\COOL@LegendreP@arg@iv}%
\else%
\PackageError{cool}{Invalid Argument}{unsupported}%
\fi%
}
{%
\PackageError{cool}{Invalid Argument}{third arg must be int}%
}%
}%
{%
\PackageError{cool}{Invalid Argument}%
{`LegendreP' can only accept a%
 comma separated list of length 2-4}%
}}}%
}
\newcommand{\COOL@notation@LegendreQParen}{p}
\newcommand{\COOL@notation@LegendreQSymb}{Q}
\newcommand{\LegendreQ}[1]{%
\liststore{#1}{COOL@LegendreQ@arg@}%
\listval{#1}{0}%
\ifthenelse{\value{COOL@listpointer} = 2}%
{%
\COOL@notation@LegendreQSymb_{\COOL@LegendreQ@arg@i}%
\COOL@decide@paren{LegendreQ}{\COOL@LegendreQ@arg@ii}%
}%
{ \ifthenelse{\value{COOL@listpointer} = 3}%
{%
\COOL@notation@LegendreQSymb_{\COOL@LegendreQ@arg@i}%
^{\COOL@LegendreQ@arg@ii}%
\COOL@decide@paren{LegendreQ}{\COOL@LegendreQ@arg@iii}%
}%
{ \ifthenelse{\value{COOL@listpointer} = 4}%
{%
\isint{\COOL@LegendreQ@arg@iii}{COOL@isint}%
\ifthenelse{\boolean{COOL@isint}}%
{%
\ifcase\COOL@LegendreQ@arg@iii\relax%
\PackageError{cool}{Invalid Argument}%
{`LegendreQ' third argument must be $>$ 1}%
\or%
\PackageError{cool}{Invalid Argument}%
{`LegendreQ' third argument must be $>$ 1}%
\or%
\COOL@notation@LegendreQSymb_{\COOL@LegendreQ@arg@i}%
^{\COOL@LegendreQ@arg@ii}%
\COOL@decide@paren{LegendreQ}{\COOL@LegendreQ@arg@iv}%
\or%
{\cal Q}_{\COOL@LegendreQ@arg@i}%
^{\COOL@LegendreQ@arg@ii}%
\COOL@decide@paren{LegendreQ}{\COOL@LegendreQ@arg@iv}%
\else%
\PackageError{cool}{Invalid Argument}{unsupported}%
\fi%
}
{%
\PackageError{cool}{Invalid Argument}{third arg must be int}%
}%
}%
{%
\PackageError{cool}{Invalid Argument}%
{`LegendreQ' can only accept a%
 comma separated list of length 2-4}%
}}}%
}
\newcommand{\COOL@notation@ChebyshevTParen}{p}
\newcommand{\COOL@notation@ChebyshevTSymb}{T}
\newcommand{\ChebyshevT}[2]%
{\COOL@notation@ChebyshevTSymb_{#1}\COOL@decide@paren{ChebyshevT}{#2}}
\newcommand{\COOL@notation@ChebyshevUParen}{p}
\newcommand{\COOL@notation@ChebyshevUSymb}{U}
\newcommand{\ChebyshevU}[2]%
{\COOL@notation@ChebyshevUSymb_{#1}\COOL@decide@paren{ChebyshevU}{#2}}
\newcommand{\COOL@notation@JacobiPParen}{p}
\newcommand{\COOL@notation@JacobiPSymb}{P}
\newcommand{\JacobiP}[4]{%
\COOL@notation@JacobiPSymb_{#1}^{\inp{#2, #3}}%
\COOL@decide@paren{JacobiP}{#4}%
}
\newcommand{\AssocLegendreP}[3]{\LegendreP{#1,#2,#3}}
\newcommand{\AssocLegendreQ}[3]{\LegendreQ{#1,#2,#3}}
\newcommand{\COOL@notation@GegenbauerCParen}{p}
\newcommand{\COOL@notation@GegenbauerCSymb}{C}
\newcommand{\GegenbauerC}[3]{%
\COOL@notation@GegenbauerCSymb_{#1}^{#2}%
\COOL@decide@paren{GegenbauerC}{#3}%
}
\newcommand{\COOL@notation@SphericalHarmonicYParen}{p}
\newcommand{\COOL@notation@SphericalHarmonicYSymb}{Y}
\newcommand{\SphericalHarmonicY}[4]{%
\COOL@notation@SphericalHarmonicYSymb_{#1}^{#2}%
\COOL@decide@paren{SphericalHarmonicY}{#3,#4}%
}
\newcommand{\SphericalHarmY}[4]{\SphericalHarmonicY{#1}{#2}{#3}{#4}}
\newcommand{\SpHarmY}[4]{\SphericalHarmonicY{#1}{#2}{#3}{#4}}
\newcommand{\COOL@notation@CyclotomicCParen}{p}
\newcommand{\CyclotomicC}[2]%
{C_{#1}\COOL@decide@paren{CyclotomicC}{#2}}
\newcommand{\FibonacciF}[2]{\Fibonacci{#1,#2}}
\newcommand{\EulerE}[2]{\Euler{#1,#2}}
\newcommand{\BernoulliB}[2]{\Bernoulli{#1,#2}}
\newcommand{\Factorial}[1]{#1!}
\newcommand{\DblFactorial}[1]{#1!!}
\newcommand{\Binomial}[2]{ \binom{#1}{#2} }
\newcommand{\Multinomial}[1]%
{%
\listval{#1}{0}% get the length of the list
\setcounter{COOL@listlen}{\value{COOL@listpointer}}% record length
\liststore{#1}{COOL@list@temp@}%
\isint{\COOL@list@temp@i}{COOL@isint}% check that the entries are integers
\setcounter{COOL@ct}{2}%
\whiledo{ \boolean{COOL@isint} \AND
\NOT \value{COOL@ct}>\value{COOL@listlen}  }%
{%
\def\COOL@Multinomial@tempa%
{\csname COOL@list@temp@\roman{COOL@ct}\endcsname}%
\isint{\COOL@Multinomial@tempa}{COOL@isint}%
\stepcounter{COOL@ct}%
}%
\ifthenelse{\boolean{COOL@isint}}%
{%
\setcounter{COOL@ct@}{ \COOL@list@temp@i }% records the sum
\forLoop{2}{\value{COOL@listlen}}{COOL@ct}%
{%
\addtocounter{COOL@ct@}%
{\csname COOL@list@temp@\roman{COOL@ct}\endcsname}%
}%
\left(\arabic{COOL@ct@}%
}%
{%
\left(%
\listval{#1}{1}%
\forLoop{2}{\value{COOL@listlen}}{COOL@ct}%
{%
+ \listval{#1}{\arabic{COOL@ct}}%
}%
}%
;#1\right)%
}
\newcommand{\COOL@notation@GammaFuncParen}{p}
\newcommand{\GammaFunc}[1]{%
\listval{#1}{0}%
\ifthenelse{\value{COOL@listpointer} = 1}%
{%
\Gamma\COOL@decide@paren{GammaFunc}{#1}%
}%
{ \ifthenelse{\value{COOL@listpointer} = 2}%
{%
\Gamma\COOL@decide@paren{GammaFunc}{#1}%
}%
{ \ifthenelse{\value{COOL@listpointer} = 3}%
{%
\Gamma\COOL@decide@paren{GammaFunc}{#1}%
}%
{%
\PackageError{cool}{Invalid Argument}%
{`GammaFunc' can only accept a comma separate list of length 1 to 3}%
}%
}}%
}
\newcommand{\IncGamma}[2]{\GammaFunc{#1,#2}}
\newcommand{\GenIncGamma}[3]{\GammaFunc{#1, #2, #3}}
\newcommand{\COOL@notation@GammaRegularizedParen}{p}%
\newcommand{\GammaRegularized}[1]{%
\listval{#1}{0}%
\ifthenelse{\value{COOL@listpointer} = 2}%
{%
Q\COOL@decide@paren{GammaRegularized}{#1}%
}%
{ \ifthenelse{\value{COOL@listpointer} = 3}%
{%
Q\COOL@decide@paren{GammaRegularized}{#1}%
}%
{%
\PackageError{cool}{Invalid Argument}%
{`GammaRegularized' can only accept comma%
 separated lists of length 2 or 3}%
}%
}%
}
\newcommand{\RegIncGamma}[2]{\GammaRegularized{#1, #2}}
\newcommand{\GammaReg}[1]{\GammaRegularized{#1}}
\newcommand{\COOL@notation@InverseGammaRegularizedParen}{p}
\newcommand{\InverseGammaRegularized}[1]{%
\listval{#1}{0}%
\ifthenelse{\value{COOL@listpointer} = 2}%
{%
Q^{-1}\COOL@decide@paren{InverseGammaRegularized}{#1}%
}%
{ \ifthenelse{\value{COOL@listpointer} = 3}%
{%
Q^{-1}\COOL@decide@paren{InverseGammaRegularized}{#1}%
}%
{%
\PackageError{cool}{Invalid Argument}%
{`InverseGammaRegularized' can only accept%
 a comma separated list of length 2 or 3}%
}%
}%
}
\newcommand{\RegIncGammaInv}[2]{\InverseGammaRegularized{#1, #2}}
\newcommand{\GammaRegInv}[1]{\InverseGammaRegularized{#1}}
\newcommand{\GenRegIncGamma}[3]{\GammaRegularized{#1, #2, #3}}
\newcommand{\GenRegIncGammaInv}[3]{\InverseGammaRegularized{#1, #2, #3}}
\newcommand{\Pochhammer}[2]{\inp{#1}_{#2}}
\newcommand{\COOL@notation@LogGammaParen}{p}
\DeclareMathOperator{\LogGammaSymb}{log\Gamma}
\newcommand{\LogGamma}[1]{\LogGammaSymb\COOL@decide@paren{LogGamma}{#1}}
\newcommand{\COOL@notation@DiGammaParen}{p}
\newcommand{\DiGamma}[1]{\digamma\COOL@decide@paren{DiGamma}{#1}}
\newcommand{\COOL@notation@PolyGammaParen}{p}
\newcommand{\PolyGamma}[2]%
{\psi^{\inp{#1}}\COOL@decide@paren{PolyGamma}{#2}}
\newcommand{\HarmNum}[1]{%
\listval{#1}{0}%
\ifthenelse{\value{COOL@listpointer}=1}%
{%
H_{#1}
}%
{ \ifthenelse{\value{COOL@listpointer}=2}%
{%
\liststore{#1}{COOL@list@temp@}%
H^{\inp{\COOL@list@temp@ii}}_{\COOL@list@temp@i}%
}%
{%
\PackageError{cool}{Invalid Argument}%
{`Harm Num' can only accept a comma separated list of length 1 or 2}%
}}%
}
\newcommand{\COOL@notation@BetaParen}{p}
\newcommand{\Beta}[1]{%
\liststore{#1}{COOL@Beta@arg@}%
\listval{#1}{0}%
\ifthenelse{\value{COOL@listpointer} = 2}%
{%
B\COOL@decide@paren{Beta}{\COOL@Beta@arg@i, \COOL@Beta@arg@ii}%
}%
{ \ifthenelse{\value{COOL@listpointer} = 3}%
{%
B_{\COOL@Beta@arg@i}%
\COOL@decide@paren{Beta}{\COOL@Beta@arg@ii, \COOL@Beta@arg@iii}%
}%
{ \ifthenelse{\value{COOL@listpointer} = 4}%
{%
B_{\inp{\COOL@Beta@arg@i,\COOL@Beta@arg@ii}}%
\COOL@decide@paren{Beta}{\COOL@Beta@arg@iii, \COOL@Beta@arg@iv}%
}%
{%
\PackageError{cool}{Invalid Argument}%
{`Beta' can only accept a comma separated list of length 2 to 4}%
}%
}}%
}
\newcommand{\IncBeta}[3]{\Beta{#1,#2, #3}}
\newcommand{\GenIncBeta}[4]{\Beta{#1,#2,#3,#4}}
\newcommand{\COOL@notation@BetaRegularizedParen}{p}
\newcommand{\BetaRegularized}[1]{%
\liststore{#1}{COOL@BetaRegularized@arg@}%
\listval{#1}{0}%
\ifthenelse{\value{COOL@listpointer} = 3}%
{%
I_{\COOL@BetaRegularized@arg@i}%
\COOL@decide@paren{BetaRegularized}%
{\COOL@BetaRegularized@arg@ii, \COOL@BetaRegularized@arg@iii}%
}%
{ \ifthenelse{\value{COOL@listpointer} = 4}%
{%
I_{\inp{\COOL@BetaRegularized@arg@i, \COOL@BetaRegularized@arg@ii}}%
\COOL@decide@paren{BetaRegularized}%
{\COOL@BetaRegularized@arg@iii, \COOL@BetaRegularized@arg@iv}%
}%
{%
\PackageError{cool}{Invalid Argument}%
{`BetaRegularized' can only accept%
 a comma separated list of length 3 or 4}%
}%
}%
}
\newcommand{\RegIncBeta}[3]{\BetaRegularized{#1,#2,#3}}
\newcommand{\BetaReg}[1]{\BetaRegularized{#1}}
\newcommand{\COOL@notation@InverseBetaRegularizedParen}{p}
\newcommand{\InverseBetaRegularized}[1]{%
\liststore{#1}{COOL@InverseBetaRegularized@arg@}%
\listval{#1}{0}%
\ifthenelse{\value{COOL@listpointer} = 3}%
{%
I^{-1}_{\COOL@InverseBetaRegularized@arg@i}%
\COOL@decide@paren{InverseBetaRegularized}%
{\COOL@InverseBetaRegularized@arg@ii,%
 \COOL@InverseBetaRegularized@arg@iii}%
}%
{ \ifthenelse{\value{COOL@listpointer} = 4}%
{%
I^{-1}_{\inp{ \COOL@InverseBetaRegularized@arg@i,%
\COOL@InverseBetaRegularized@arg@ii%
    }%
}%
\COOL@decide@paren{InverseBetaRegularized}%
{\COOL@InverseBetaRegularized@arg@iii,%
 \COOL@InverseBetaRegularized@arg@iv}%
}%
{%
\PackageError{cool}{Invalid Argument}%
{`InverseBetaRegularized' can only accept%
 a comma separated list of length 3 or 4}%
}%
}%
}
\newcommand{\RegIncBetaInv}[3]{\InverseBetaRegularized{#1,#2,#3}}
\newcommand{\BetaRegInv}[1]{\InverseBetaRegularized{#1}}
\newcommand{\GenRegIncBeta}[4]{\Beta{#1,#2,#3,#4}}
\newcommand{\GenRegIncBetaInv}[4]{\InverseBetaRegularized{#1,#2,#3,#4}}
\newcommand{\COOL@notation@ErfParen}{p}
\DeclareMathOperator{\ErfSymb}{erf}
\newcommand{\Erf}[1]{%
\liststore{#1}{COOL@Erf@arg@}%
\listval{#1}{0}%
\ifthenelse{\value{COOL@listpointer} = 1}%
{%
\ErfSymb\COOL@decide@paren{Erf}{#1}
}%
{ \ifthenelse{\value{COOL@listpointer} = 2}%
{%
\ErfSymb\COOL@decide@paren{Erf}{#1}
}%
{%
\PackageError{cool}{Invalid Argument}%
{`Erf' can only accept a comma separated list of length 1 or 2}%
}%
}%
}
\newcommand{\COOL@notation@ErfInvParen}{p}
\newcommand{\ErfInv}[1]{%
\liststore{#1}{COOL@Erf@arg@}%
\listval{#1}{0}%
\ifthenelse{\value{COOL@listpointer} = 1}%
{%
\ErfSymb^{-1}\COOL@decide@paren{ErfInv}{#1}
}%
{ \ifthenelse{\value{COOL@listpointer} = 2}%
{%
\ErfSymb^{-1}\COOL@decide@paren{ErfInv}{#1}
}%
{%
\PackageError{cool}{Invalid Argument}%
{`Erf' can only accept a comma separated list of length 1 or 2}%
}%
}%
}

\newcommand{\GenErf}[2]{\Erf{#1,#2}}
\newcommand{\GenErfInv}[2]{\ErfInv{#1, #2}}
\newcommand{\COOL@notation@ErfcParen}{p}
\DeclareMathOperator{\ErfcSymb}{erfc}
\newcommand{\Erfc}[1]{\ErfcSymb\COOL@decide@paren{Erfc}{#1}}
\newcommand{\COOL@notation@ErfcInvParen}{p}
\newcommand{\ErfcInv}[1]%
{\ErfcSymb^{-1}\COOL@decide@paren{ErfcInv}{#1}}
\newcommand{\COOL@notation@ErfiParen}{p}
\DeclareMathOperator{\ErfiSymb}{erfi}
\newcommand{\Erfi}[1]{\ErfiSymb\COOL@decide@paren{Erfi}{#1}}
\newcommand{\COOL@notation@FresnelSParen}{p}
\newcommand{\FresnelS}[1]{S\COOL@decide@paren{FresnelS}{#1}}
\newcommand{\COOL@notation@FresnelCParen}{p}
\newcommand{\FresnelC}[1]{C\COOL@decide@paren{FresnelC}{#1}}
\newcommand{\COOL@notation@ExpIntEParen}{p}
\newcommand{\ExpIntE}[2]{E_{#1}\COOL@decide@paren{ExpIntE}{#2}}
\newcommand{\COOL@notation@ExpIntEiParen}{p}
\DeclareMathOperator{\ExpIntEiSymb}{Ei}
\newcommand{\ExpIntEi}[1]%
{\ExpIntEiSymb\COOL@decide@paren{ExpIntEi}{#1}}
\newcommand{\COOL@notation@LogIntParen}{p}
\DeclareMathOperator{\LogIntSymb}{li}
\newcommand{\LogInt}[1]{\LogIntSymb\COOL@decide@paren{LogInt}{#1}}
\newcommand{\COOL@notation@SinIntParen}{p}
\DeclareMathOperator{\SinIntSymb}{Si}
\newcommand{\SinInt}[1]{\SinIntSymb\COOL@decide@paren{SinInt}{#1}}
\newcommand{\COOL@notation@CosIntParen}{p}
\DeclareMathOperator{\CosIntSymb}{Ci}
\newcommand{\CosInt}[1]{\CosIntSymb\COOL@decide@paren{CosInt}{#1}}
\newcommand{\COOL@notation@SinhIntParen}{p}
\DeclareMathOperator{\SinhIntSymb}{Shi}
\newcommand{\SinhInt}[1]{\SinhIntSymb\COOL@decide@paren{SinhInt}{#1}}
\newcommand{\COOL@notation@CoshIntParen}{p}
\DeclareMathOperator{\CoshIntSymb}{Chi}
\newcommand{\CoshInt}[1]{\CoshIntSymb\COOL@decide@paren{CoshInt}{#1}}
\newcommand{\COOL@Hypergeometric@pq@ab@value}[4]{%
\ifthenelse{\boolean{COOL@#1@isint} \AND \boolean{COOL@#3@islist}}%
{% #1 is an INT and #3 is a LIST
\ifthenelse{ #2 = 0 }%
{%
\PackageWarning{cool}{`#3'-arg ignored}%
}%
{%
\ifthenelse{ #2 = 1 }%
{%
\PackageError{cool}{`Hypergeometric' `#1'-arg mismatch with `#3'-arg}{}%
}%
{%
#4%
}%
}%
}%
{}%
\ifthenelse{ \boolean{COOL@#1@isint} \AND
\NOT \boolean{COOL@#3@islist}  }%
{%
\ifthenelse{ #2 = 0 }%
{%
}%
{%
\ifthenelse{ #2 = 1 }%
{%
#4%
}%
{%
\forLoop{1}{#2}{COOL@ct}
{%
\ifthenelse{ \value{COOL@ct} = 1 }{}{,}%
#4_{\arabic{COOL@ct}}%
}% end for loop
}%
}%
}%
{}%
\ifthenelse{  \NOT \boolean{COOL@#1@isint} \AND
\boolean{COOL@#3@islist}  }%
{%
\PackageError{cool}{Invalid Argument}%
{`Hypergeometric': `#1'-arg is not int but `#3'-arg is list}
}%
{}%
\ifthenelse{ \NOT \boolean{COOL@#1@isint} \AND
\NOT \boolean{COOL@#3@islist}  }%
{%
#4_1,\ldots,#4_{#2}%
}%
{}%
}%
\newcommand{\COOL@notation@HypergeometricParen}{p}
\newcommand{\COOL@notation@HypergeometricSymb}{F}
\newcommand{\Hypergeometric}[6][F]{%
\provideboolean{COOL@p@isint}%
\provideboolean{COOL@q@isint}%
\provideboolean{COOL@a@islist}%
\provideboolean{COOL@b@islist}%
\isint{#2}{COOL@isint}%
\ifthenelse{\boolean{COOL@isint}}%
{\setboolean{COOL@p@isint}{true}}%
{\setboolean{COOL@p@isint}{false}}%
\isint{#3}{COOL@isint}%
\ifthenelse{\boolean{COOL@isint}}%
{\setboolean{COOL@q@isint}{true}}%
{\setboolean{COOL@q@isint}{false}}%
\listval{#4}{0}%
\ifthenelse{\value{COOL@listpointer}>1}%
{\setboolean{COOL@a@islist}{true}}%
{\setboolean{COOL@a@islist}{false}}%
\ifthenelse{ \boolean{COOL@p@isint} \AND
\boolean{COOL@a@islist} \AND
\NOT \( #2 = \value{COOL@listpointer} \) }%
{%
\PackageError{cool}{`Hypergeometric' `p'-arg mismatch with `a'-arg}{}%
}%
{}%
\listval{#5}{0}%
\ifthenelse{\value{COOL@listpointer}>1}%
{\setboolean{COOL@b@islist}{true}}%
{\setboolean{COOL@b@islist}{false}}%
\ifthenelse{ \boolean{COOL@q@isint} \AND
\boolean{COOL@b@islist} \AND
\NOT \( #3 = \value{COOL@listpointer} \) }%
{%
\PackageError{cool}{`Hypergeometric' `q'-arg mismatch with `b'-arg}%
{`b' list is not the same length as `q'}%
}%
{}%
\ifthenelse{ \boolean{COOL@a@islist} \AND \NOT \boolean{COOL@p@isint} }%
{%
\PackageError{cool}{`Hypergeometric' `a'-arg mismatch with `p'-arg}%
{happens if `a'-arg is a list and `p'-arg isn't an integer}%
}%
{}%
\ifthenelse{ \boolean{COOL@b@islist} \AND \NOT \boolean{COOL@q@isint} }%
{%
\PackageError{cool}{`Hypergeometric' `b'-arg mismatch with `q'-arg}%
{happens if `b'-arg is a list and `q'-arg isn't an integer}%
}%
{}%
{}_{#2}{\COOL@notation@HypergeometricSymb}_{#3}%
\COOL@decide@paren{Hypergeometric}%
{%
\COOL@Hypergeometric@pq@ab@value{p}{#2}{a}{#4};%
\COOL@Hypergeometric@pq@ab@value{q}{#3}{b}{#5};%
#6%
}%
}
\newcommand{\COOL@notation@RegHypergeometricParen}{p}
\newcommand{\COOL@notation@RegHypergeometricSymb}{\tilde{F}}
\newcommand{\RegHypergeometric}[6][\tilde{F}]{%
\provideboolean{COOL@p@isint}%
\provideboolean{COOL@q@isint}%
\provideboolean{COOL@a@islist}%
\provideboolean{COOL@b@islist}%
\isint{#2}{COOL@isint}%
\ifthenelse{\boolean{COOL@isint}}%
{\setboolean{COOL@p@isint}{true}}%
{\setboolean{COOL@p@isint}{false}}%
\isint{#3}{COOL@isint}%
\ifthenelse{\boolean{COOL@isint}}%
{\setboolean{COOL@q@isint}{true}}%
{\setboolean{COOL@q@isint}{false}}%
\listval{#4}{0}%
\ifthenelse{\value{COOL@listpointer}>1}%
{\setboolean{COOL@a@islist}{true}}%
{\setboolean{COOL@a@islist}{false}}%
\ifthenelse{ \boolean{COOL@p@isint} \AND
\boolean{COOL@a@islist} \AND
\NOT \( #2 = \value{COOL@listpointer} \) }%
{%
\PackageError{cool}%
{`RegHypergeometric' `p'-arg mismatch with `a'-arg}{}%
}%
{}%
\listval{#5}{0}%
\ifthenelse{\value{COOL@listpointer}>1}%
{\setboolean{COOL@b@islist}{true}}%
{\setboolean{COOL@b@islist}{false}}%
\ifthenelse{ \boolean{COOL@q@isint} \AND
\boolean{COOL@b@islist} \AND
\NOT \( #3 = \value{COOL@listpointer} \) }%
{%
\PackageError{cool}%
{`RegHypergeometric' `q'-arg mismatch with `b'-arg}%
{`b' list is not the same length as `q'}%
}%
{}%
\ifthenelse{ \boolean{COOL@a@islist} \AND \NOT \boolean{COOL@p@isint} }%
{%
\PackageError{cool}%
{`RegHypergeometric' `a'-arg mismatch with `p'-arg}%
{happens if `a'-arg is a list and `p'-arg isn't an integer}%
}%
{}%
\ifthenelse{ \boolean{COOL@b@islist} \AND \NOT \boolean{COOL@q@isint} }%
{%
\PackageError{cool}%
{`RegHypergeometric' `b'-arg mismatch with `q'-arg}%
{happens if `b'-arg is a list and `q'-arg isn't an integer}%
}%
{}%
{}_{#2}{\COOL@notation@RegHypergeometricSymb}_{#3}%
\COOL@decide@paren{RegHypergeometric}%
{%
\COOL@Hypergeometric@pq@ab@value{p}{#2}{a}{#4};%
\COOL@Hypergeometric@pq@ab@value{q}{#3}{b}{#5};%
#6%
}%
}
\newcommand{\COOL@notation@AppellFOneParen}{p}
\newcommand{\AppellFOne}[4]%
{F_{1}\COOL@decide@paren{AppellFOne}{#1; #2; #3; #4}}
\newcommand{\COOL@notation@HypergeometricUSymb}{U}
\newcommand{\HypergeometricU}[3]%
{\COOL@notation@HypergeometricUSymb\inp{#1, #2, #3}}
\newcommand{\COOL@MeijerG@anp@value}[3]{%
\isint{#3}{COOL@isint}%
\ifthenelse{\boolean{COOL@isint}}%
{%
\isint{#2}{COOL@isint}%
\ifthenelse{\boolean{COOL@isint}}%
{%
\forLoop{1}{#3}{COOL@ct}%
{%
\ifthenelse{\value{COOL@ct}=1}{}{,}%
#1_{\arabic{COOL@ct}}%
}%
}%
{%
#1_1,\ldots,#1_{#2},#1_{#2+1},\dots,#1_{#3}%
}%
}%
{%
\isint{#2}{COOL@isint}%
\ifthenelse{\boolean{COOL@isint}}%
{%
\forLoop{1}{#2}{COOL@ct}%
{%
\ifthenelse{\value{COOL@ct}=1}{}{,}%
#1_{\arabic{COOL@ct}}%
}%
\setcounter{COOL@ct}{#2}%
\addtocounter{COOL@ct}{1}%
,#1_{\arabic{COOL@ct}}, \ldots, #1_{#3}%
}%
{%
#1_1,\ldots,#1_{#2},#1_{#2+1},\dots,#1_{#3}%
}%
}%
}
\newcommand{\COOL@notation@MeijerGSymb}{G}
\newcommand{\MeijerG}[6][@,@]{%
\listval{#1}{0}
\ifthenelse{\value{COOL@listpointer}>2 \OR \value{COOL@listpointer}<1}%
{%
\PackageError{cool}{`MeijerG' Invalid Optional Argument}%
{Must be a comma separated list of length 1 or 2}%
}%
{%
}%
\COOL@notation@MeijerGSymb%
\ifthenelse{\equal{#1}{@,@}}%
{%
\listval{#2}{0}% n
\setcounter{COOL@ct}{\value{COOL@listpointer}}%
\listval{#4}{0}% m
\setcounter{COOL@ct@}{\value{COOL@listpointer}}%
^{\arabic{COOL@ct@},\arabic{COOL@ct}}%
\listval{#3}{0}% p - n
\addtocounter{COOL@ct}{\value{COOL@listpointer}}%
\listval{#5}{0}% q - m
\addtocounter{COOL@ct@}{\value{COOL@listpointer}}%
_{\arabic{COOL@ct},\arabic{COOL@ct@}}%
\mathopen{}\left(%
#6%
\left|%
{ {#2,#3} \@@atop {#4,#5} }%
\right)\right.%
}%
{%
\listval{#1}{0}%
\ifthenelse{\value{COOL@listpointer}=2}%
{%
\provideboolean{COOL@MeijerG@opt@one@blank}%
\def\COOL@MeijerG@sniffer##1,##2\COOL@MeijerG@sniffer@end{%
\ifthenelse{\equal{##1}{}}%
{%
\setboolean{COOL@MeijerG@opt@one@blank}{true}%
}%
{%
\setboolean{COOL@MeijerG@opt@one@blank}{false}%
}%
}%
\expandafter\COOL@MeijerG@sniffer#1\COOL@MeijerG@sniffer@end\relax%
\ifthenelse{\boolean{COOL@MeijerG@opt@one@blank}}%
{%
\listval{#2}{0}% n
\setcounter{COOL@ct}{\value{COOL@listpointer}}%
^{#4,\arabic{COOL@ct}}%
\listval{#3}{0}% p
\addtocounter{COOL@ct}{\value{COOL@listpointer}}%
_{\arabic{COOL@ct},#5}%
\mathopen{}\left(%
#6%
\left|%
{%
{#2,#3} \@@atop {\COOL@MeijerG@anp@value{\listval{#1}{2}}{#4}{#5}}
}%
\right)\right.%
}%
{%
^{#4,#2}_{#3,#5}%
\mathopen{}\left(%
#6%
\left|%
{%
{\COOL@MeijerG@anp@value{\listval{#1}{1}}{#2}{#3}}%
\@@atop%
{\COOL@MeijerG@anp@value{\listval{#1}{2}}{#4}{#5}}
}%
\right)\right.%
}%
}%
{%
\listval{#4}{0}% m
\setcounter{COOL@ct}{\value{COOL@listpointer}}%
^{\arabic{COOL@ct}, #2}%
\listval{#5}{0}% q
\addtocounter{COOL@ct}{\value{COOL@listpointer}}%
_{#3, \arabic{COOL@ct}}%
\mathopen{}\left(%
#6%
\left|%
{%
{\COOL@MeijerG@anp@value{#1}{#2}{#3}} \@@atop {#4,#5}
}%
\right)\right.%
}%
}%
}%
\newcommand{\ClebschGordon}[3]{%
\listval{#1}{0}%
\ifthenelse{\NOT \value{COOL@listpointer}=2}%
{%
\PackageError{cool}{`ClebschGordon' Invalid Argument}%
{Must have a comma separated list of length two}%
}%
{}%
\listval{#2}{0}%
\ifthenelse{\NOT \value{COOL@listpointer}=2}%
{%
\PackageError{cool}{`ClebschGordon' Invalid Argument}%
{Must have a comma separated list of length two}%
}%
{}%
\listval{#3}{0}%
\ifthenelse{\NOT \value{COOL@listpointer}=2}%
{%
\PackageError{cool}{`ClebschGordon' Invalid Argument}%
{Must have a comma separated list of length two}%
}%
{}%
\left<%
\listval{#1}{1},\listval{#2}{1};%
\listval{#1}{2},\listval{#2}{2}%
\left|%
\listval{#1}{1},\listval{#2}{1};%
\listval{#3}{1},\listval{#3}{2}%
\right>\right.%
}
\newcommand{\ThreeJSymbol}[3]{%
\listval{#1}{0}%
\ifthenelse{\NOT \value{COOL@listpointer}=2}%
{%
\PackageError{cool}{`ThreeJSymbol' Invalid Argument}%
{Must have comma separated list of length 2}%
}%
{}%
\listval{#2}{0}%
\ifthenelse{\NOT \value{COOL@listpointer}=2}%
{%
\PackageError{cool}{`ThreeJSymbol' Invalid Argument}%
{Must have comma separated list of length 2}%
}%
{}%
\listval{#3}{0}%
\ifthenelse{\NOT \value{COOL@listpointer}=2}%
{%
\PackageError{cool}{`ThreeJSymbol' Invalid Argument}%
{Must have comma separated list of length 2}%
}%
{}%
\mathchoice{%
\inp{\!%
\begin{array}{ccc}%
\listval{#1}{1} & \listval{#2}{1} & \listval{#3}{1} \\%
\listval{#1}{2} & \listval{#2}{2} & \listval{#3}{2}
\end{array}%
     \!}%
   }%
   {%
\inp{\!%
{\listval{#1}{1} \@@atop \listval{#1}{2}}%
{\listval{#2}{1} \@@atop \listval{#2}{2}}%
{\listval{#3}{1} \@@atop \listval{#3}{2}}%
     \!}%
   }%
   {%
\inp{\!%
{\listval{#1}{1} \@@atop \listval{#1}{2}}%
{\listval{#2}{1} \@@atop \listval{#2}{2}}%
{\listval{#3}{1} \@@atop \listval{#3}{2}}%
     \!}%
   }%
   {%
\inp{\!%
{\listval{#1}{1} \@@atop \listval{#1}{2}}%
{\listval{#2}{1} \@@atop \listval{#2}{2}}%
{\listval{#3}{1} \@@atop \listval{#3}{2}}%
     \!}%
   }%
}
\newcommand{\SixJSymbol}[2]{%
\listval{#1}{0}%
\ifthenelse{\NOT \value{COOL@listpointer}=3}%
{%
\PackageError{cool}{`SixJSymbol' Invalid Argument}%
{Must have a comma separated list of length 3}%
}%
{}%
\listval{#2}{0}%
\ifthenelse{\NOT \value{COOL@listpointer}=3}%
{%
\PackageError{cool}{`SixJSymbol' Invalid Argument}%
{Must have a comma separated list of length 3}%
}%
{}%
\mathchoice{%
\inbr{\!%
\begin{array}{ccc}%
\listval{#1}{1} & \listval{#1}{2} & \listval{#1}{3} \\%
\listval{#2}{1} & \listval{#2}{2} & \listval{#2}{3}%
\end{array}%
     \!}%
  }%
  {%
\inbr{\!%
{\listval{#1}{1} \@@atop \listval{#2}{1}}%
{\listval{#1}{2} \@@atop \listval{#2}{2}}%
{\listval{#1}{3} \@@atop \listval{#2}{3}}%
     \!}%
  }%
  {%
\inbr{\!%
{\listval{#1}{1} \@@atop \listval{#2}{1}}%
{\listval{#1}{2} \@@atop \listval{#2}{2}}%
{\listval{#1}{3} \@@atop \listval{#2}{3}}%
     \!}%
  }%
  {%
\inbr{\!%
{\listval{#1}{1} \@@atop \listval{#2}{1}}%
{\listval{#1}{2} \@@atop \listval{#2}{2}}%
{\listval{#1}{3} \@@atop \listval{#2}{3}}%
     \!}%
  }%
}
\newcommand{\COOL@notation@EllipticKParen}{p}
\newcommand{\COOL@notation@EllipticKSymb}{K}
\newcommand{\EllipticK}[1]%
{\COOL@notation@EllipticKSymb\COOL@decide@paren{EllipticK}{#1}}%
\newcommand{\COOL@notation@EllipticEParen}{p}
\newcommand{\COOL@notation@EllipticESymb}{E}
\newcommand{\EllipticE}[1]{%
\liststore{#1}{COOL@EllipticE@arg@}%
\listval{#1}{0}%
\ifthenelse{\value{COOL@listpointer} = 1}%
{%
\COOL@notation@EllipticESymb\COOL@decide@paren{EllipticE}{#1}%
}%
{ \ifthenelse{\value{COOL@listpointer} = 2}%
{%
\COOL@notation@EllipticESymb%
\COOL@decide@paren{EllipticE}%
{\COOL@EllipticE@arg@i \left| \, \COOL@EllipticE@arg@ii \!\!\right.}%
}%
{%
\PackageError{Invalid Argument}%
{`EllipticE' can only accept a comma separated list of length 1 or 2}%
}%
}%
}
\newcommand{\COOL@notation@EllipticPiParen}{p}
\newcommand{\COOL@notation@EllipticPiSymb}{\Pi}
\newcommand{\EllipticPi}[1]{%
\liststore{#1}{COOL@EllipticPi@arg@}%
\listval{#1}{0}%
\ifthenelse{\value{COOL@listpointer} = 2}%
{%
\COOL@notation@EllipticPiSymb%
\COOL@decide@paren{EllipticPi}%
{\COOL@EllipticPi@arg@i \left| \, \COOL@EllipticPi@arg@ii \!\!\right.}%
}%
{ \ifthenelse{\value{COOL@listpointer} = 3}%
{%
\COOL@notation@EllipticPiSymb%
\COOL@decide@paren{EllipticPi}%
{ \COOL@EllipticPi@arg@i; \,%
\COOL@EllipticPi@arg@ii \left| \,%
\COOL@EllipticPi@arg@iii \!\!\right.%
}%
}%
{%
\PackageError{cool}{Invalid Argument}%
{`EllipticPi' can only accept a comma separated list of length 2 or 3}%
}%
}%
}
\newcommand{\COOL@notation@EllipticFParen}{p}
\newcommand{\COOL@notation@EllipticFSymb}{F}
\newcommand{\EllipticF}[1]{%
\liststore{#1}{COOL@EllipticF@arg@}%
\listval{#1}{0}%
\ifthenelse{ \value{COOL@listpointer} = 2 }%
{%
\COOL@notation@EllipticFSymb%
\COOL@decide@paren{EllipticF}%
{\COOL@EllipticF@arg@i \left| \, \COOL@EllipticF@arg@ii \!\!\right.}%
}%
{%
\PackageError{cool}{Invalid Argument}%
{`EllipticF' can only accept a comma separated list of length 2}%
}%
}
\newcommand{\IncEllipticF}[2]{\EllipticF{#1,#2}}
\newcommand{\IncEllipticE}[2]{\EllipticE{#1,#2}}
\newcommand{\IncEllipticPi}[3]{\EllipticPi{#1,#2,#3}}
\newcommand{\COOL@notation@JacobiZetaParen}{p}
\newcommand{\COOL@notation@JacobiZetaSymb}{Z}
\newcommand{\JacobiZeta}[2]{%
\COOL@notation@JacobiZetaSymb
\COOL@decide@paren{JacobiZeta}{#1 \left| \, #2 \right.\!\!}%
}
\newcommand{\COOL@notation@EllipticThetaParen}{p}
\newcommand{\EllipticTheta}[3]%
{\vartheta_{#1}\COOL@decide@paren{EllipticTheta}{#2, #3}}
\newcommand{\JacobiTheta}[3]{\EllipticTheta{#1}{#2}{#3}}
\newcommand{\COOL@notation@NevilleThetaCParen}{p}
\newcommand{\NevilleThetaC}[2]{%
\vartheta_{c}\COOL@decide@paren{NevilleThetaC}%
{#1 \left| \, #2 \right.\!\!}%
}
\newcommand{\COOL@notation@NevilleThetaDParen}{p}
\newcommand{\NevilleThetaD}[2]{%
\vartheta_{d}\COOL@decide@paren{NevilleThetaD}%
{#1 \left| \, #2 \right.\!\!}%
}
\newcommand{\COOL@notation@NevilleThetaNParen}{p}
\newcommand{\NevilleThetaN}[2]{%
\vartheta_{n}\COOL@decide@paren{NevilleThetaN}%
{#1 \left| \, #2 \right.\!\!}%
}
\newcommand{\COOL@notation@NevilleThetaSParen}{p}
\newcommand{\NevilleThetaS}[2]{%
\vartheta_{s}\COOL@decide@paren{NevilleThetaS}%
{#1 \left| \, #2 \right.\!\!}%
}
\newcommand{\COOL@notation@WeierstrassPParen}{p}
\newcommand{\WeierstrassP}[2]{%
\liststore{#2}{COOL@WeiP@arg@g@}%
\listval{#2}{0}%
\ifthenelse{\NOT \value{COOL@listpointer} = 2}%
{%
\PackageError{cool}{Invalid Argument}%
{`WeierstrassP' second argument must be%
 a comma separated list of length 2}%
}
{%
\wp\COOL@decide@paren{WeierstrassP}{#1; #2}
}%
}
\newcommand{\WeiP}[2]{\WeierstrassP{#1}{#2}}
\newcommand{\COOL@notation@WeierstrassPInvParen}{p}
\newcommand{\WeierstrassPInv}[2]{%
\liststore{#1}{COOL@WeiPinv@arg@z@}%
\liststore{#1}{COOL@WeiPinv@arg@g@}%
\listval{#2}{0}%
\ifthenelse{\NOT \value{COOL@listpointer} = 2}%
{%
\PackageError{cool}{Invalid Argument}%
{`WeierstrassPInv' second argument must be%
 a comma separated list of length 2}%
}
{
\listval{#1}{0}%
\ifthenelse{\value{COOL@listpointer} = 1}%
{%
\wp^{-1}\COOL@decide@paren{WeierstrassPInv}{#1; #2}%
}%
{ \ifthenelse{\value{COOL@listpointer} = 2}%
{%
\wp^{-1}\COOL@decide@paren{WeierstrassPInv}{#1; #2}%
}%
{%
\PackageError{cool}{Invalid Argument}%
{`WeierstrassPInv' first argument must be%
 a comma separate list of length 1 or 2}%
}}%
}%
}
\newcommand{\WeiPInv}[2]{\WeierstrassPInv{#1}{#2}}
\newcommand{\WeierstrassPGenInv}[4]{\WeierstrassPInv{#1,#2}{#3,#4}}
\newcommand{\WeierstrassSigma}[2]{%
\liststore{#1}{COOL@WeiSigma@arg@z@}%
\liststore{#2}{COOL@WeiSigma@arg@g@}%
\listval{#2}{0}%
\ifthenelse{\NOT \value{COOL@listpointer} = 2}
{%
\PackageError{cool}{Invalid Argument}%
{`WeierstrassSigma' second argument must be%
 a comma separated list of length 2}%
}%
{%
\listval{#1}{0}%
\ifthenelse{\value{COOL@listpointer} = 1}%
{%
\sigma\inp{#1; #2}%
}%
{ \ifthenelse{\value{COOL@listpointer} = 2}%
{%
\sigma_{\COOL@WeiSigma@arg@z@i}\inp{\COOL@WeiSigma@arg@z@ii; #2}%
}%
{%
\PackageError{cool}{Invalid Argument}%
{`WeierstrassSigma' first argument must be%
 a comma separated list of length 1 or 2}%
}}%
}%
}
\newcommand{\WeiSigma}[2]{\WeierstrassSigma{#1}{#2}}
\newcommand{\AssocWeierstrassSigma}[4]{\WeierstrassSigma{#1,#2}{#3,#4}}
\newcommand{\COOL@notation@WeierstrassZetaParen}{p}%
\newcommand{\WeierstrassZeta}[2]{%
\listval{#2}{0}%
\ifthenelse{\NOT \value{COOL@listpointer} = 2}%
{%
\PackageError{cool}{Invalid Argument}%
{`WeierstrassZeta' second argument must be%
 a comma separated list of length 2}%
}%
{%
\zeta\COOL@decide@paren{WeierstrassZeta}{#1; #2}%
}%
}
\newcommand{\WeiZeta}[2]{\WeierstrassZeta{#1}{#2}}
\newcommand{\WeierstrassHalfPeriods}[1]{%
\listval{#1}{0}%
\ifthenelse{\NOT \value{COOL@listpointer} = 2}%
{%
\PackageError{cool}{Invalid Argument}%
{`WeierstrassHalfPeriods' can only accept%
 a comma separated list of length 2}%
}%
{%
\{ \omega_1\inp{#1}, \omega_3\inp{#1} \}%
}%
}
\newcommand{\WeiHalfPeriods}[1]{\WeierstrassHalfPeriods{#1}}
\newcommand{\WeierstrassInvariants}[1]{%
\listval{#1}{0}%
\ifthenelse{\NOT \value{COOL@listpointer} = 2}%
{%
\PackageError{cool}{Invalid Argument}%
{`WeierstrassInvariants' can only accept%
 a comma separated list of length 2}%
}%
{%
\{ g_2\inp{#1}, g_3\inp{#1} \}%
}%
}
\newcommand{\WeiInvars}[1]{\WeierstrassInvariants{#1}}
\newcommand{\COOL@hideOnSF}[2]
{%
\ifthenelse{ \equal{\csname COOL@notation@#1\endcsname}{sf} }%
{}%
{#2}%
}
\newcommand{\COOL@notation@WeierstrassPHalfPeriodValuesDisplay}{sf}
\newcommand{\WeierstrassPHalfPeriodValues}[1]
{%
\listval{#1}{0}%
\ifthenelse{\NOT \value{COOL@listpointer} = 2}%
{%
\PackageError{cool}{Invalid Argument}%
{`WeierstrassPHalfPeriodValues' can only accept%
 a comma separated list of length 2}%
}%
{%
\{  e_1\COOL@hideOnSF{WeierstrassPHalfPeriodValuesDisplay}{\inp{#1}},%
e_2\COOL@hideOnSF{WeierstrassPHalfPeriodValuesDisplay}{\inp{#1}},%
e_3\COOL@hideOnSF{WeierstrassPHalfPeriodValuesDisplay}{\inp{#1}}%
\}%
}%
}
\newcommand{\WeiPHalfPeriodVal}[1]{\WeierstrassPHalfPeriodValues{#1}}
\newcommand{\COOL@notation@WeierstrassZetaHalfPeriodValuesDisplay}{sf}
\newcommand{\WeierstrassZetaHalfPeriodValues}[1]
{%
\listval{#1}{0}%
\ifthenelse{\NOT \value{COOL@listpointer} = 2}%
{%
\PackageError{cool}{Invalid Argument}%
{`WeierstrassZetaHalfPeriodValues' can only accept%
 a comma separated list of length 2}%
}%
{%
\{%
\eta_1\COOL@hideOnSF%
{WeierstrassZetaHalfPeriodValuesDisplay}{\inp{#1}},%
\eta_2\COOL@hideOnSF%
{WeierstrassZetaHalfPeriodValuesDisplay}{\inp{#1}},%
\eta_3\COOL@hideOnSF%
{WeierstrassZetaHalfPeriodValuesDisplay}{\inp{#1}}%
\}%
}%
}
\newcommand{\WeiZetaHalfPeriodVal}[1]%
{\WeierstrassZetaHalfPeriodValues{#1}}
\newcommand{\COOL@notation@JacobiAmplitudeParen}{p}
\DeclareMathOperator{\JacobiAmplitudeSymb}{am}
\newcommand{\JacobiAmplitude}[2]{%
\JacobiAmplitudeSymb\COOL@decide@paren%
{JacobiAmplitude}{#1 \left| \, #2 \right.\!\!}%
}
\newcommand{\COOL@notation@JacobiCDParen}{p}
\newcommand{\COOL@notation@JacobiCDInvParen}{p}
\DeclareMathOperator{\JacobiCDSymb}{cd}
\newcommand{\JacobiCD}[2]{%
\JacobiCDSymb\COOL@decide@paren%
{JacobiCD}{#1 \left| \, #2 \right.\!\!}%
}
\newcommand{\JacobiCDInv}[2]{%
\JacobiCDSymb^{-1}\COOL@decide@paren%
{JacobiCDInv}{#1 \left| \, #2 \right.\!\!}%
}
\newcommand{\COOL@notation@JacobiCNParen}{p}
\newcommand{\COOL@notation@JacobiCNInvParen}{p}
\DeclareMathOperator{\JacobiCNSymb}{cn}
\newcommand{\JacobiCN}[2]{%
\JacobiCNSymb\COOL@decide@paren%
{JacobiCN}{#1 \left| \, #2 \right.\!\!}%
}
\newcommand{\JacobiCNInv}[2]{%
\JacobiCNSymb^{-1}\COOL@decide@paren%
{JacobiCNInv}{#1 \left| \, #2 \right.\!\!}%
}
\newcommand{\COOL@notation@JacobiCSParen}{p}
\newcommand{\COOL@notation@JacobiCSInvParen}{p}
\DeclareMathOperator{\JacobiCSSymb}{cs}
\newcommand{\JacobiCS}[2]{%
\JacobiCSSymb\COOL@decide@paren%
{JacobiCS}{#1 \left| \, #2 \right.\!\!}%
}
\newcommand{\JacobiCSInv}[2]{%
\JacobiCSSymb^{-1}\COOL@decide@paren%
{JacobiCSInv}{#1 \left| \, #2 \right.\!\!}%
}
\newcommand{\COOL@notation@JacobiDCParen}{p}
\newcommand{\COOL@notation@JacobiDCInvParen}{p}
\DeclareMathOperator{\JacobiDCSymb}{dc}
\newcommand{\JacobiDC}[2]{%
\JacobiDCSymb\COOL@decide@paren%
{JacobiDC}{#1 \left| \, #2 \right.\!\!}%
}
\newcommand{\JacobiDCInv}[2]{%
\JacobiDCSymb^{-1}\COOL@decide@paren%
{JacobiDCInv}{#1 \left| \, #2 \right.\!\!}%
}
\newcommand{\COOL@notation@JacobiDNParen}{p}
\newcommand{\COOL@notation@JacobiDNInvParen}{p}
\DeclareMathOperator{\JacobiDNSymb}{dn}
\newcommand{\JacobiDN}[2]{%
\JacobiDNSymb\COOL@decide@paren%
{JacobiDN}{#1 \left| \, #2 \right.\!\!}%
}
\newcommand{\JacobiDNInv}[2]{%
\JacobiDNSymb^{-1}\COOL@decide@paren%
{JacobiDNInv}{#1 \left| \, #2 \right.\!\!}%
}
\newcommand{\COOL@notation@JacobiDSParen}{p}
\newcommand{\COOL@notation@JacobiDSInvParen}{p}
\DeclareMathOperator{\JacobiDSSymb}{ds}
\newcommand{\JacobiDS}[2]{%
\JacobiDSSymb\COOL@decide@paren%
{JacobiDS}{#1 \left| \, #2 \right.\!\!}%
}
\newcommand{\JacobiDSInv}[2]{%
\JacobiDSSymb^{-1}\COOL@decide@paren%
{JacobiDSInv}{#1 \left| \, #2 \right.\!\!}%
}
\newcommand{\COOL@notation@JacobiNCParen}{p}
\newcommand{\COOL@notation@JacobiNCInvParen}{p}
\DeclareMathOperator{\JacobiNCSymb}{nc}
\newcommand{\JacobiNC}[2]{%
\JacobiNCSymb\COOL@decide@paren%
{JacobiNC}{#1 \left| \, #2 \right.\!\!}%
}
\newcommand{\JacobiNCInv}[2]{%
\JacobiNCSymb^{-1}\COOL@decide@paren%
{JacobiNCInv}{#1 \left| \, #2 \right.\!\!}%
}
\newcommand{\COOL@notation@JacobiNDParen}{p}
\newcommand{\COOL@notation@JacobiNDInvParen}{p}
\DeclareMathOperator{\JacobiNDSymb}{nd}
\newcommand{\JacobiND}[2]{%
\JacobiNDSymb\COOL@decide@paren%
{JacobiND}{#1 \left| \, #2 \right.\!\!}%
}
\newcommand{\JacobiNDInv}[2]{%
\JacobiNDSymb^{-1}\COOL@decide@paren%
{JacobiNDInv}{#1 \left| \, #2 \right.\!\!}%
}
\newcommand{\COOL@notation@JacobiNSParen}{p}
\newcommand{\COOL@notation@JacobiNSInvParen}{p}
\DeclareMathOperator{\JacobiNSSymb}{ns}
\newcommand{\JacobiNS}[2]{%
\JacobiNSSymb\COOL@decide@paren%
{JacobiNS}{#1 \left| \, #2 \right.\!\!}%
}
\newcommand{\JacobiNSInv}[2]{%
\JacobiNSSymb^{-1}\COOL@decide@paren%
{JacobiNSInv}{#1 \left| \, #2 \right.\!\!}%
}
\newcommand{\COOL@notation@JacobiSCParen}{p}
\newcommand{\COOL@notation@JacobiSCInvParen}{p}
\DeclareMathOperator{\JacobiSCSymb}{sc}
\newcommand{\JacobiSC}[2]{%
\JacobiSCSymb\COOL@decide@paren%
{JacobiSC}{#1 \left| \, #2 \right.\!\!}%
}
\newcommand{\JacobiSCInv}[2]{%
\JacobiSCSymb^{-1}\COOL@decide@paren%
{JacobiSCInv}{#1 \left| \, #2 \right.\!\!}%
}
\newcommand{\COOL@notation@JacobiSDParen}{p}
\newcommand{\COOL@notation@JacobiSDInvParen}{p}
\DeclareMathOperator{\JacobiSDSymb}{sd}
\newcommand{\JacobiSD}[2]{%
\JacobiSDSymb\COOL@decide@paren%
{JacobiSD}{#1 \left| \, #2 \right.\!\!}%
}
\newcommand{\JacobiSDInv}[2]{%
\JacobiSDSymb^{-1}\COOL@decide@paren%
{JacobiSDInv}{#1 \left| \, #2 \right.\!\!}%
}
\newcommand{\COOL@notation@JacobiSNParen}{p}
\newcommand{\COOL@notation@JacobiSNInvParen}{p}
\DeclareMathOperator{\JacobiSNSymb}{sn}
\newcommand{\JacobiSN}[2]{%
\JacobiSNSymb\COOL@decide@paren%
{JacobiSN}{#1 \left| \, #2 \right.\!\!}%
}
\newcommand{\JacobiSNInv}[2]{%
\JacobiSNSymb^{-1}\COOL@decide@paren%
{JacobiSNInv}{#1 \left| \, #2 \right.\!\!}%
}
\newcommand{\COOL@notation@DedekindEtaParen}{p}
\newcommand{\DedekindEta}[1]{\eta\COOL@decide@paren{DedekindEta}{#1}}
\newcommand{\COOL@notation@KleinInvariantJParen}{p}
\newcommand{\KleinInvariantJ}[1]%
{J\COOL@decide@paren{KleinInvariantJ}{#1}}
\newcommand{\COOL@notation@ModularLambdaParen}{p}
\newcommand{\ModularLambda}[1]%
{\lambda\COOL@decide@paren{ModularLambda}{#1}}
\newcommand{\COOL@notation@EllipticNomeQParen}{p}
\newcommand{\COOL@notation@EllipticNomeQInvParen}{p}
\newcommand{\EllipticNomeQ}[1]%
{q\COOL@decide@paren{EllipticNomeQ}{#1}}
\newcommand{\EllipticNomeQInv}[1]%
{q^{-1}\COOL@decide@paren{EllipticNomeQ}{#1}}
\newcommand{\COOL@notation@ArithGeoMeanParen}{p}
\DeclareMathOperator{\ArithGeoMeanSymb}{agm}
\newcommand{\ArithGeoMean}[2]%
{\ArithGeoMeanSymb\COOL@decide@paren{ArithGeoMean}{#1, #2}}
\newcommand{\AGM}[2]{\ArithGeoMean{#1}{#2}}
\newcommand{\COOL@notation@EllipticExpParen}{p}
\DeclareMathOperator{\EllipticExpSymb}{eexp}
\newcommand{\EllipticExp}[2]{%
\liststore{#2}{COOL@EllipticExp@arg@}
\listval{#2}{0}%
\ifthenelse{\NOT \value{COOL@listpointer} = 2}%
{%
\PackageError{cool}{Invalid Argument}%
{`EllipticExp' second argument must be
 a comma separated list of length 2}%
}%
{%
\EllipticExpSymb\COOL@decide@paren{EllipticExp}{#1; #2}%
}%
}
\newcommand{\EExp}[2]{\EllipticExp{#1}{#2}}
\newcommand{\COOL@notation@EllipticLogParen}{p}
\DeclareMathOperator{\EllipticLogSymb}{elog}
\newcommand{\EllipticLog}[2]{%
\liststore{#1}{COOL@EllipticLog@arg@z@}%
\liststore{#2}{COOL@EllipticLog@arg@a@}%
\listval{#1}{0}%
\ifthenelse{\NOT \value{COOL@listpointer} = 2}%
{%
\PackageError{cool}{Invalid Argument}%
{`EllipticLog' first argument must be
 a comma separated list of length 2}%
}%
{%
\listval{#2}{0}%
\ifthenelse{\NOT \value{COOL@listpointer} = 2}%
{%
\PackageError{cool}{Invalid Argument}%
{`EllipticLog' second argument must be%
 a comma separated list of length 2}%
}%
{%
\EllipticLogSymb\COOL@decide@paren{EllipticLog}{#1; #2}%
}%
}%
}
\newcommand{\ELog}[2]{\EllipticLog{#1}{#2}}
\newcommand{\RiemannZeta}[1]{\Zeta{#1}}
\newcommand{\HurwitzZeta}[2]{\Zeta{#1,#2}}
\newcommand{\COOL@notation@ZetaParen}{p}
\newcommand{\Zeta}[1]{%
\liststore{#1}{COOL@Zeta@arg@}%
\listval{#1}{0}% get the list length
\ifthenelse{\value{COOL@listpointer} = 2}%
{%
\zeta\COOL@decide@paren{Zeta}{\COOL@Zeta@arg@i,\COOL@Zeta@arg@ii}%
}%
{%
\ifthenelse{\value{COOL@listpointer} = 1}%
{%
\zeta\COOL@decide@paren{Zeta}{#1}%
}%
{%
\PackageError{cool}{`Zeta' Invalid Argument}%
{the Zeta function can only accept%
 a comma deliminated list of length 1 or 2}
}%
}%
}%
\newcommand{\COOL@notation@RiemannSiegelThetaParen}{p}
\newcommand{\RiemannSiegelTheta}[1]%
{\vartheta\COOL@decide@paren{RiemannSiegelTheta}{#1}}
\newcommand{\COOL@notation@RiemannSiegelZParen}{p}
\newcommand{\RiemannSiegelZ}[1]%
{Z\COOL@decide@paren{RiemannSiegelZ}{#1}}
\newcommand{\StieltjesGamma}[1]{\gamma_{#1}}
\newcommand{\COOL@notation@LerchPhiParen}{p}
\newcommand{\LerchPhi}[3]{\Phi\COOL@decide@paren{LerchPhi}{#1,#2,#3}}
\newcommand{\COOL@notation@NielsenPolyLogParen}{p}
\newcommand{%
\NielsenPolyLog}[3]{S_{#1}^{#2}%
\COOL@decide@paren{NielsenPolyLog}{#3}%
}
\newcommand{\COOL@notation@PolyLogParen}{p}
\DeclareMathOperator{\PolyLogSymb}{Li}
\newcommand{\PolyLog}[1]{%
\liststore{#1}{COOL@PolyLog@arg@}%
\listval{#1}{0}%
\ifthenelse{\value{COOL@listpointer} = 3}%
{%
\NielsenPolyLog{\COOL@PolyLog@arg@i}%
{\COOL@PolyLog@arg@ii}{\COOL@PolyLog@arg@iii}%
}%
{%
\ifthenelse{ \value{COOL@listpointer} = 2 }%
{%
\PolyLogSymb_{\COOL@PolyLog@arg@i}%
\COOL@decide@paren{PolyLog}{\COOL@PolyLog@arg@ii}%
}%
{%
\PackageError{cool}{`PolyLog' Invalid Argument}%
{This function returns either the Polylogarithm or the%
 Nielsen Polylogarithm.  It therefore only accepts a comma%
 deliminated list of length two or three (1 or 2 commas)}%
}%
}%
}
\newcommand{\DiLog}[1]{\PolyLog{2,#1}}
\newcommand{\COOL@notation@MathieuCParen}{p}
\DeclareMathOperator{\MathieuCSymb}{Ce}
\newcommand{\MathieuC}[3]%
{\MathieuCSymb\COOL@decide@paren{MathieuC}{#1,#2,#3}}
\newcommand{\COOL@notation@MathieuSParen}{p}
\DeclareMathOperator{\MathieuSSymb}{Se}
\newcommand{\MathieuS}[3]%
{\mathord{\MathieuSSymb}\COOL@decide@paren{MathieuS}{#1,#2,#3}}
\newcommand{\COOL@notation@MathieuCharacteristicAParen}{p}
\newcommand{\MathieuCharacteristicA}[2]%
{a_{#1}\COOL@decide@paren{MathieuCharacteristicA}{#2}}
\newcommand{\MathieuCharisticA}[2]{\MathieuCharacteristicA{#1}{#2}}
\newcommand{\COOL@notation@MathieuCharacteristicBParen}{p}
\newcommand{\MathieuCharacteristicB}[2]%
{b_{#1}\COOL@decide@paren{MathieuCharacteristicB}{#2}}
\newcommand{\MathieuCharisticB}[2]{\MathieuCharacteristicB{#1}{#2}}
\newcommand{\COOL@notation@MathieuCharacteristicExponentParen}{p}
\newcommand{\MathieuCharacteristicExponent}[2]%
{r\COOL@decide@paren{MathieuCharacteristicExponent}{#1,#2}}
\newcommand{\MathieuCharisticExp}[2]%
{\MathieuCharacteristicExponent{#1}{#2}}
\newcommand{\Abs}[1]{ \left|#1\right| }
\newcommand{\Arg}[1]{ \arg\inp{#1} }
\def\COOL@notation@Conjugate{star}
\newcommand{\COOL@notation@ConjugateParen}{inv}
\newcommand{\Conjugate}[1]{\Conj{#1}}
\newcommand{\Conj}[1]{%
\ifthenelse{\equal{\COOL@notation@Conjugate}{bar}}%
{%
\bar{#1}%
}%
{ \ifthenelse{\equal{\COOL@notation@Conjugate}{overline}}%
{%
\overline{#1}%
}%
{ \ifthenelse{\equal{\COOL@notation@Conjugate}{star}}%
{%
\COOL@decide@paren{Conjugate}{#1}^*%
}%
{%
\PackageError{cool}{Invalid Option Sent}%
{`Conjugate' can only be set at `star', `bar', or `overline'}%
}%
}}%
}
\newcommand{\COOL@notation@RealParen}{none}
\DeclareMathOperator{\RealSymb}{Re}
\newcommand{\Real}[1]{%
\ifthenelse{\equal{\COOL@notation@ImagParen}{none}}%
{%
\RealSymb{#1}%
}%
{%
\RealSymb\COOL@decide@paren{Imag}{#1}%
}%
}
\newcommand{\COOL@notation@ImagParen}{none}
\DeclareMathOperator{\ImagSymb}{Im}
\newcommand{\Imag}[1]{%
\ifthenelse{\equal{\COOL@notation@ImagParen}{none}}%
{%
\ImagSymb{#1}%
}%
{%
\ImagSymb\COOL@decide@paren{Imag}{#1}%
}%
}
\newcommand{\COOL@notation@SignParen}{p}
\newcommand{\Sign}[1]{\operatorname{sgn}\COOL@decide@paren{Sign}{#1}}
\newcommand{\COOL@notation@FactorIntegerParen}{p}
\DeclareMathOperator{\FactorIntegerSymb}{factors}
\newcommand{\FactorInteger}[1]%
{\FactorIntegerSymb\COOL@decide@paren{FactorInteger}{#1}}
\newcommand{\Factors}[1]{\FactorInteger{#1}}
\newcommand{\COOL@notation@DivisorsParen}{p}
\DeclareMathOperator{\DivisorsSymb}{divisors}
\newcommand{\Divisors}[1]%
{\mathord{\DivisorsSymb}\COOL@decide@paren{Divisors}{#1}}
\newcommand{\COOL@notation@PrimeParen}{p}
\DeclareMathOperator{\PrimeSymb}{prime}
\newcommand{\Prime}[1]%
{\mathord{\PrimeSymb}\COOL@decide@paren{Prime}{#1}}
\newcommand{\COOL@notation@PrimePiParen}{p}
\newcommand{\PrimePi}[1]{\pi\COOL@decide@paren{PrimePi}{#1}}
\newcommand{\COOL@notation@DivisorSigmaParen}{p}
\newcommand{\DivisorSigma}[2]%
{\sigma_{#1}\COOL@decide@paren{DivisorSigma}{#2}}
\newcommand{\COOL@notation@EulerPhiParen}{p}
\newcommand{\EulerPhi}[1]{\varphi\COOL@decide@paren{EulerPhi}{#1}}
\newcommand{\COOL@notation@MoebiusMuParen}{p}
\newcommand{\MoebiusMu}[1]{\mu\COOL@decide@paren{MoebiusMu}{#1}}
\newcommand{\JacobiSymbol}[2]{\inp{\frac{#1}{#2}}}
\newcommand{\COOL@notation@CarmichaelLambdaParen}{p}
\newcommand{\CarmichaelLambda}[1]%
{\lambda\COOL@decide@paren{CarmichaelLambda}{#1}}
\newcommand{\DigitCount}[2]{%
\isint{#2}{COOL@isint}%
\ifthenelse{\boolean{COOL@isint}}%
{%
\{%
\setcounter{COOL@ct@}{#2}%
\addtocounter{COOL@ct@}{-1}%
\forLoop{1}{\arabic{COOL@ct@}}{COOL@ct}%
{%
s^{\arabic{COOL@ct}}_{#2}\inp{#1},
}%
s^{\inp{0}}_{#2}\inp{#1}%
\}%
}%
{%
\{%
s^{\inp{1}}_{#2}\inp{#1},%
s^{\inp{2}}_{#2}\inp{#1},%
\ldots,%
s^{\inp{#2} - 1}_{#2}\inp{#1},%
s^{\inp{0}}_{#2}\inp{#1}%
\}%
}%
}
\newcommand{\COOL@notation@DiracDeltaParen}{p}
\newcommand{\DiracDelta}[1]{\delta\COOL@decide@paren{DiracDelta}{#1}}
\newcommand{\COOL@notation@HeavisideStepParen}{p}
\newcommand{\HeavisideStep}[1]%
{\theta\COOL@decide@paren{HeavisideStep}{#1}}
\newcommand{\UnitStep}[1]{\HeavisideStep{#1}}
\newcounter{COOL@multideriv}
\newcommand{\COOL@notation@DDisplayFunc}{inset}
\newcommand{\COOL@notation@DShorten}{true}
\newcommand{\COOL@notation@DSymb}{d}
\newcommand{\COOL@derivative}[4]{%
\listval{#3}{0}%
\setcounter{COOL@listlen}{\value{COOL@listpointer}}%
\liststore{#3}{COOL@deriv@wrt@}%
\listval{#1}{0}%
\setcounter{COOL@ct}{\value{COOL@listpointer}}%
\ifthenelse{\value{COOL@ct}>\value{COOL@listlen}}%
{\setcounter{COOL@ct}{\value{COOL@listlen}}}{}%
\liststore{#1}{COOL@deriv@powers@}%
\isint{\COOL@deriv@powers@i}{COOL@isint}%
\setcounter{COOL@multideriv}{2}%
\whiledo{ \boolean{COOL@isint} \AND
\NOT \value{COOL@multideriv}>\value{COOL@ct}  }%
{%
\def\COOL@tempd%
{\csname COOL@deriv@powers@\roman{COOL@multideriv}\endcsname}%
\isint{\COOL@tempd}{COOL@isint}%
\stepcounter{COOL@multideriv}%
}%
\ifthenelse{ \equal{\COOL@notation@DShorten}{true} \AND
\equal{\COOL@notation@DDisplayFunc}{inset} }%
{%
\ifthenelse{ \boolean{COOL@isint} }%
{%
\def\COOL@temp@D@bot{}%
\setcounter{COOL@ct@}{0}%
\forLoop{1}{\value{COOL@ct}}{COOL@multideriv}%
{%
\edef\COOL@power@temp%
{\csname COOL@deriv@powers@\roman{COOL@multideriv}\endcsname}%
\edef\COOL@wrt@temp%
{\csname COOL@deriv@wrt@\roman{COOL@multideriv}\endcsname}%
\addtocounter{COOL@ct@}{\COOL@power@temp}%
\ifthenelse{ \value{COOL@multideriv}=1 }{}%
{\edef\COOL@temp@D@bot{\COOL@temp@D@bot \,}}%
\ifthenelse{ \equal{\COOL@power@temp}{1} }%
{%
\edef\COOL@temp@D@bot%
{\COOL@temp@D@bot {#4} \COOL@wrt@temp}%
}%
{%
\edef\COOL@temp@D@bot%
{\COOL@temp@D@bot {#4} \COOL@wrt@temp^\COOL@power@temp}%
}%
}%
\ifthenelse{\value{COOL@ct}<\value{COOL@listlen}}%
{%
\edef\COOL@power@temp%
{\csname COOL@deriv@powers@\roman{COOL@ct}\endcsname}%
\stepcounter{COOL@ct}%
\forLoop{\value{COOL@ct}}{\value{COOL@listlen}}{COOL@multideriv}%
{%
\edef\COOL@wrt@temp%
{\csname COOL@deriv@wrt@\roman{COOL@multideriv}\endcsname}%
\addtocounter{COOL@ct@}{\COOL@power@temp}%
\ifthenelse{ \value{COOL@multideriv}=1 }{}%
{\edef\COOL@temp@D@bot{\COOL@temp@D@bot \,}}%
\ifthenelse{ \equal{\COOL@power@temp}{1} }%
{%
\edef\COOL@temp@D@bot%
{\COOL@temp@D@bot {#4} \COOL@wrt@temp}%
}%
{%
\edef\COOL@temp@D@bot%
{\COOL@temp@D@bot {#4} \COOL@wrt@temp^\COOL@power@temp}%
}%
}%
}%
{}%
\ifthenelse{\value{COOL@ct@}=1}%
{%
\frac{{#4} #2}{\COOL@temp@D@bot}%
}%
{%
\frac{{#4}^{\arabic{COOL@ct@}} #2}{\COOL@temp@D@bot}%
}%
}%
{%
\edef\COOL@temp@D@bot{}%
\def\COOL@temp@D@top@power{}%
\forLoop{1}{\value{COOL@ct}}{COOL@multideriv}%
{%
\edef\COOL@power@temp%
{\csname COOL@deriv@powers@\roman{COOL@multideriv}\endcsname}%
\edef\COOL@wrt@temp%
{\csname COOL@deriv@wrt@\roman{COOL@multideriv}\endcsname}%
\ifthenelse{ \value{COOL@multideriv} = 1}%
{%
\edef\COOL@temp@D@top@power{\COOL@power@temp}%
}%
{%
\edef\COOL@temp@D@top@power%
{\COOL@temp@D@top@power + \COOL@power@temp}%
\edef\COOL@temp@D@bot{\COOL@temp@D@bot \,}%
}%
\ifthenelse{ \equal{\COOL@power@temp}{1} }%
{%
\edef\COOL@temp@D@bot%
{\COOL@temp@D@bot {#4} \COOL@wrt@temp}%
}%
{%
\edef\COOL@temp@D@bot%
{\COOL@temp@D@bot {#4} \COOL@wrt@temp^\COOL@power@temp}%
}%
}%
\ifthenelse{\value{COOL@ct}<\value{COOL@listlen}}%
{%
\edef\COOL@power@temp%
{\csname COOL@deriv@powers@\roman{COOL@ct}\endcsname}%
\stepcounter{COOL@ct}%
\forLoop{\value{COOL@ct}}{\value{COOL@listlen}}{COOL@multideriv}%
{%
\edef\COOL@wrt@temp%
{\csname COOL@deriv@wrt@\roman{COOL@multideriv}\endcsname}%
\ifthenelse{ \value{COOL@multideriv} = 1}%
{%
\edef\COOL@temp@D@top@power{\COOL@power@temp}%
}%
{%
\edef\COOL@temp@D@top@power%
{\COOL@temp@D@top@power + \COOL@power@temp}%
\edef\COOL@temp@D@bot{\COOL@temp@D@bot \,}%
}%
\ifthenelse{ \equal{\COOL@power@temp}{1} }%
{%
\edef\COOL@temp@D@bot%
{\COOL@temp@D@bot {#4} \COOL@wrt@temp}%
}%
{%
\edef\COOL@temp@D@bot%
{\COOL@temp@D@bot {#4} \COOL@wrt@temp^\COOL@power@temp}%
}%
}%
}%
{}%
\frac{{#4}^{\COOL@temp@D@top@power} #2}{\COOL@temp@D@bot}%
}%
}%
{ \ifthenelse{ \equal{\COOL@notation@DShorten}{true} \AND
\equal{\COOL@notation@DDisplayFunc}{outset}  }%
{%
\ifthenelse{ \boolean{COOL@isint} }%
{%
\def\COOL@temp@D@bot{}%
\setcounter{COOL@ct@}{0}%
\forLoop{1}{\value{COOL@ct}}{COOL@multideriv}%
{%
\edef\COOL@power@temp%
{\csname COOL@deriv@powers@\roman{COOL@multideriv}\endcsname}%
\edef\COOL@wrt@temp%
{\csname COOL@deriv@wrt@\roman{COOL@multideriv}\endcsname}%
\addtocounter{COOL@ct@}{\COOL@power@temp}%
\ifthenelse{ \value{COOL@multideriv}=1 }{}%
{\edef\COOL@temp@D@bot{\COOL@temp@D@bot \,}}%
\ifthenelse{ \equal{\COOL@power@temp}{1} }%
{%
\edef\COOL@temp@D@bot%
{\COOL@temp@D@bot {#4} \COOL@wrt@temp}%
}%
{%
\edef\COOL@temp@D@bot%
{\COOL@temp@D@bot {#4} \COOL@wrt@temp^\COOL@power@temp}%
}%
}%
\ifthenelse{\value{COOL@ct}<\value{COOL@listlen}}%
{%
\edef\COOL@power@temp%
{\csname COOL@deriv@powers@\roman{COOL@ct}\endcsname}%
\stepcounter{COOL@ct}%
\forLoop{\value{COOL@ct}}{\value{COOL@listlen}}{COOL@multideriv}%
{%
\edef\COOL@wrt@temp%
{\csname COOL@deriv@wrt@\roman{COOL@multideriv}\endcsname}%
\addtocounter{COOL@ct@}{\COOL@power@temp}%
\ifthenelse{ \value{COOL@multideriv}=1 }{}%
{\edef\COOL@temp@D@bot{\COOL@temp@D@bot \,}}%
\ifthenelse{ \equal{\COOL@power@temp}{1} }%
{%
\edef\COOL@temp@D@bot%
{\COOL@temp@D@bot {#4} \COOL@wrt@temp}%
}%
{%
\edef\COOL@temp@D@bot%
{\COOL@temp@D@bot {#4} \COOL@wrt@temp^\COOL@power@temp}%
}%
}%
}%
{}%
\ifthenelse{\value{COOL@ct@}=1}%
{%
\frac{#4}{\COOL@temp@D@bot} #2%
}%
{%
\frac{{#4}^{\arabic{COOL@ct@}}}{\COOL@temp@D@bot} #2%
}%
}%
{%
\edef\COOL@temp@D@bot{}%
\def\COOL@temp@D@top@power{}%
\forLoop{1}{\value{COOL@ct}}{COOL@multideriv}%
{%
\edef\COOL@power@temp%
{\csname COOL@deriv@powers@\roman{COOL@multideriv}\endcsname}%
\edef\COOL@wrt@temp%
{\csname COOL@deriv@wrt@\roman{COOL@multideriv}\endcsname}%
\ifthenelse{ \value{COOL@multideriv} = 1}%
{%
\edef\COOL@temp@D@top@power{\COOL@power@temp}%
}%
{%
\edef\COOL@temp@D@top@power%
{\COOL@temp@D@top@power + \COOL@power@temp}%
\edef\COOL@temp@D@bot{\COOL@temp@D@bot \,}%
}%
\ifthenelse{ \equal{\COOL@power@temp}{1} }%
{%
\edef\COOL@temp@D@bot%
{\COOL@temp@D@bot {#4} \COOL@wrt@temp}%
}%
{%
\edef\COOL@temp@D@bot%
{\COOL@temp@D@bot {#4} \COOL@wrt@temp^\COOL@power@temp}%
}%
}%
\ifthenelse{\value{COOL@ct}<\value{COOL@listlen}}%
{%
\edef\COOL@power@temp%
{\csname COOL@deriv@powers@\roman{COOL@ct}\endcsname}%
\stepcounter{COOL@ct}%
\forLoop{\value{COOL@ct}}{\value{COOL@listlen}}{COOL@multideriv}%
{%
\edef\COOL@wrt@temp%
{\csname COOL@deriv@wrt@\roman{COOL@multideriv}\endcsname}%
\ifthenelse{ \value{COOL@multideriv} = 1}%
{%
\edef\COOL@temp@D@top@power{\COOL@power@temp}%
}%
{%
\edef\COOL@temp@D@top@power%
{\COOL@temp@D@top@power + \COOL@power@temp}%
\edef\COOL@temp@D@bot{\COOL@temp@D@bot \,}%
}%
\ifthenelse{ \equal{\COOL@power@temp}{1} }%
{%
\edef\COOL@temp@D@bot%
{\COOL@temp@D@bot {#4} \COOL@wrt@temp}%
}%
{%
\edef\COOL@temp@D@bot%
{\COOL@temp@D@bot {#4} \COOL@wrt@temp^\COOL@power@temp}%
}%
}%
}%
{}%
\frac{{#4}^{\COOL@temp@D@top@power} }{\COOL@temp@D@bot} #2%
}%
}%
{ \ifthenelse{ \equal{\COOL@notation@DShorten}{false} \AND
\equal{\COOL@notation@DDisplayFunc}{inset} }%
{%
\def\COOL@temp@D@result{}%
\def\COOL@temp@D@bot{}%
\def\COOL@temp@D@top{}%
\setcounter{COOL@ct@}{\value{COOL@ct}}%
\addtocounter{COOL@ct@}{-1}
\forLoop{1}{\value{COOL@ct@}}{COOL@multideriv}%
{%
\edef\COOL@power@temp%
{\csname COOL@deriv@powers@\roman{COOL@multideriv}\endcsname}%
\edef\COOL@wrt@temp%
{\csname COOL@deriv@wrt@\roman{COOL@multideriv}\endcsname}%
\ifthenelse{ \equal{\COOL@power@temp}{1} }%
{%
\edef\COOL@temp@D@top{#4}%
\edef\COOL@temp@D@bot{{#4} \COOL@wrt@temp}%
}%
{%
\edef\COOL@temp@D@top{{#4}^\COOL@power@temp}%
\edef\COOL@temp@D@bot{{#4} \COOL@wrt@temp^\COOL@power@temp}%
}%
\edef\COOL@temp@D@result%
{\COOL@temp@D@result \frac{\COOL@temp@D@top}{\COOL@temp@D@bot}}%
}%
\ifthenelse{\value{COOL@ct}<\value{COOL@listlen}}%
{%
\edef\COOL@power@temp%
{\csname COOL@deriv@powers@\roman{COOL@ct}\endcsname}%
\edef\COOL@wrt@temp%
{\csname COOL@deriv@wrt@\roman{COOL@ct}\endcsname}%
\ifthenelse{ \equal{\COOL@power@temp}{1} }%
{%
\edef\COOL@temp@D@top{#4}%
\edef\COOL@temp@D@bot{{#4} \COOL@wrt@temp}%
}%
{%
\edef\COOL@temp@D@top{{#4}^\COOL@power@temp}%
\edef\COOL@temp@D@bot{{#4} \COOL@wrt@temp^\COOL@power@temp}%
}%
\edef\COOL@temp@D@result%
{\COOL@temp@D@result \frac{\COOL@temp@D@top}{\COOL@temp@D@bot}}%
\stepcounter{COOL@ct}%
\setcounter{COOL@ct@}{\value{COOL@listlen}}%
\addtocounter{COOL@ct@}{-1}%
\forLoop{\value{COOL@ct}}{\value{COOL@ct@}}{COOL@multideriv}%
{%
\ifthenelse{ \equal{\COOL@power@temp}{1} }%
{%
\edef\COOL@temp@D@top{#4}%
\edef\COOL@temp@D@bot{{#4} \COOL@wrt@temp}%
}%
{%
\edef\COOL@temp@D@top{{#4}^\COOL@power@temp}%
\edef\COOL@temp@D@bot{{#4} \COOL@wrt@temp^\COOL@power@temp}%
}%
\edef\COOL@temp@D@result%
{\COOL@temp@D@result \frac{\COOL@temp@D@top}{\COOL@temp@D@bot}}%
}%
\edef\COOL@wrt@temp%
{\csname COOL@deriv@wrt@\roman{COOL@listlen}\endcsname}%
\ifthenelse{ \equal{\COOL@power@temp}{1} }%
{%
\edef\COOL@temp@D@top{#4}%
\edef\COOL@temp@D@bot{{#4} \COOL@wrt@temp}%
}%
{%
\edef\COOL@temp@D@top{{#4}^\COOL@power@temp}%
\edef\COOL@temp@D@bot{{#4} \COOL@wrt@temp^\COOL@power@temp}%
}%
\edef\COOL@temp@D@result%
{\COOL@temp@D@result \frac{\COOL@temp@D@top #2}{\COOL@temp@D@bot}}%
}%
{%
\edef\COOL@power@temp%
{\csname COOL@deriv@powers@\roman{COOL@ct}\endcsname}%
\edef\COOL@wrt@temp%
{\csname COOL@deriv@wrt@\roman{COOL@ct}\endcsname}%
\ifthenelse{ \equal{\COOL@power@temp}{1} }%
{%
\edef\COOL@temp@D@top{#4}%
\edef\COOL@temp@D@bot{{#4} \COOL@wrt@temp}%
}%
{%
\edef\COOL@temp@D@top{{#4}^\COOL@power@temp}%
\edef\COOL@temp@D@bot{{#4} \COOL@wrt@temp^\COOL@power@temp}%
}%
\edef\COOL@temp@D@result%
{\COOL@temp@D@result \frac{\COOL@temp@D@top #2}{\COOL@temp@D@bot}}%
}%
\COOL@temp@D@result%
}%
{ \ifthenelse{ \equal{\COOL@notation@DShorten}{false} \AND
\equal{\COOL@notation@DDisplayFunc}{outset} }%
{%
\def\COOL@temp@D@result{}%
\def\COOL@temp@D@bot{}%
\def\COOL@temp@D@top{}%
\forLoop{1}{\value{COOL@ct}}{COOL@multideriv}%
{%
\edef\COOL@power@temp%
{\csname COOL@deriv@powers@\roman{COOL@multideriv}\endcsname}%
\edef\COOL@wrt@temp%
{\csname COOL@deriv@wrt@\roman{COOL@multideriv}\endcsname}%
\ifthenelse{ \equal{\COOL@power@temp}{1} }%
{%
\edef\COOL@temp@D@top{#4}%
\edef\COOL@temp@D@bot{{#4} \COOL@wrt@temp}%
}%
{%
\edef\COOL@temp@D@top{{#4}^\COOL@power@temp}%
\edef\COOL@temp@D@bot{{#4} \COOL@wrt@temp^\COOL@power@temp}%
}%
\edef\COOL@temp@D@result%
{\COOL@temp@D@result \frac{\COOL@temp@D@top}{\COOL@temp@D@bot}}%
}%
\ifthenelse{\value{COOL@ct}<\value{COOL@listlen}}%
{%
\edef\COOL@power@temp%
{\csname COOL@deriv@powers@\roman{COOL@ct}\endcsname}%
\stepcounter{COOL@ct}%
\forLoop{\value{COOL@ct}}{\value{COOL@listlen}}{COOL@multideriv}%
{%
\edef\COOL@wrt@temp%
{\csname COOL@deriv@wrt@\roman{COOL@multideriv}\endcsname}%
\ifthenelse{ \equal{\COOL@power@temp}{1} }%
{%
\edef\COOL@temp@D@top{#4}%
\edef\COOL@temp@D@bot{{#4} \COOL@wrt@temp}%
}%
{%
\edef\COOL@temp@D@top{{#4}^\COOL@power@temp}%
\edef\COOL@temp@D@bot{{#4} \COOL@wrt@temp^\COOL@power@temp}%
}%
\edef\COOL@temp@D@result%
{\COOL@temp@D@result \frac{\COOL@temp@D@top}{\COOL@temp@D@bot}}%
}%
}%
{%
}%
\COOL@temp@D@result #2
}%
{%
\PackageError{cool}{Invalid Option Sent}%
{DShorten can only be `true' or `false';%
 DDisplayFunc can only be `inset' or `outset'}%
}%
}}}%
}
\newcommand{\D}[3][1]{\COOL@derivative{#1}{#2}{#3}{{\COOL@notation@DSymb}}}
\newcommand{\pderiv}[3][1]{\COOL@derivative{#1}{#2}{#3}{\partial}}
\newcommand{\COOL@notation@IntegrateDisplayFunc}{inset}
\newcommand{\COOL@notation@IntegrateDifferentialDSymb}{d}
\newcommand{\Integrate}[2]{%
\listval{#2}{0}%
\setcounter{COOL@listlen}{\value{COOL@listpointer}}%
\ifthenelse{ \value{COOL@listlen} = 1 }%
{%
\ifthenelse{\equal{\COOL@notation@IntegrateDisplayFunc}{outset}}%
{%
\int \! \COOL@notation@IntegrateDifferentialDSymb{}#2 \, #1%
}%
{ \ifthenelse{\equal{\COOL@notation@IntegrateDisplayFunc}{inset}}%
{%
\int #1 \, \COOL@notation@IntegrateDifferentialDSymb{}#2%
}%
{%
\PackageError{cool}{Invalid Option Sent}%
{`DisplayFunc' can only be `inset' or `outset'}%
}}%
}%
{ \ifthenelse{ \value{COOL@listlen} = 2 }%
{%
\ifthenelse{\equal{\COOL@notation@IntegrateDisplayFunc}{outset}}%
{%
\int_{\listval{#2}{2}} \!
\COOL@notation@IntegrateDifferentialDSymb{}{\listval{#2}{1}} \, #1%
}%
{ \ifthenelse{\equal{\COOL@notation@IntegrateDisplayFunc}{inset}}%
{%
\int_{\listval{#2}{2}} #1 \,
\COOL@notation@IntegrateDifferentialDSymb{}{\listval{#2}{1}}%
}%
{%
\PackageError{cool}{Invalid Option Sent}%
{`DisplayFunc' can only be `inset' or `outset'}%
}}%
}%
{ \ifthenelse{ \value{COOL@listlen} = 3 }%
{%
\ifthenelse{\equal{\COOL@notation@IntegrateDisplayFunc}{outset}}%
{%
\int_{\listval{#2}{2}}^{\listval{#2}{3}} \!
\COOL@notation@IntegrateDifferentialDSymb{}{\listval{#2}{1}} \, #1%
}%
{ \ifthenelse{\equal{\COOL@notation@IntegrateDisplayFunc}{inset}}%
{%
\int_{\listval{#2}{2}}^{\listval{#2}{3}} #1 \,
\COOL@notation@IntegrateDifferentialDSymb{}{\listval{#2}{1}}%
}%
{%
\PackageError{cool}{Invalid Option Sent}%
{`DisplayFunc' can only be `inset' or `outset'}%
}}%
}%
{%
\PackageError{cool}{`Integrate' has invalid parameter list}%
   {this happens when the second argument has more than two commas}%
}}}%
}%
\newcommand{\Int}[2]{\Integrate{#1}{#2}}
\newcommand{\Sum}[2]{%
\listval{#2}{0}%
\setcounter{COOL@listlen}{\value{COOL@listpointer}}
\ifthenelse{ \value{COOL@listlen} = 1 }%
{%
\sum_{#2} #1%
}%
{%
\ifthenelse{ \value{COOL@listlen} = 3 }%
{%
\sum_{ \listval{#2}{1} = \listval{#2}{2} }^{ \listval{#2}{3} } #1
}%
{%
\PackageError{cool}{Invalid list length for `Sum'}%
{can only have none or two commas for second argument}%
}%
}%
}
\newcommand{\Prod}[2]{%
\listval{#2}{0}%
\setcounter{COOL@listlen}{\value{COOL@listpointer}}
\ifthenelse{ \value{COOL@listlen} = 1 }%
{%
\prod_{#2} #1%
}%
{%
\ifthenelse{ \value{COOL@listlen} = 3 }%
{%
\prod_{ \listval{#2}{1} = \listval{#2}{2} }^{ \listval{#2}{3} } #1
}%
{%
\PackageError{cool}{Invalid list length for `Prod'}%
{can only have none or two commas for second argument}%
}%
}%
}
\newcommand{\DotProduct}[2]{#1 \cdot #2}
\newcommand{\Cross}[2]{#1 \times #2}
\newcommand{\Div}[1]{\nabla \cdot #1}
\newcommand{\Grad}[1]{\nabla #1}
\newcommand{\Curl}[1]{\nabla \times #1}
\newcommand{\Laplacian}[1]{\nabla^2 #1}
\newcommand{\COOL@notation@TransposeParen}{inv}
\newcommand{\Transpose}[1]{ \COOL@decide@paren{Transpose}{#1}^T }
\newcommand{\COOL@notation@DaggerParen}{inv}
\newcommand{\Dagger}[1]{ \COOL@decide@paren{Dagger}{#1}^\dagger }
\newcommand{\COOL@notation@DetParen}{none}
\newcommand{\COOL@notation@DetDisplay}{det}
\newcommand{\Det}[1]{%
\ifthenelse{\equal{\COOL@notation@DetDisplay}{det}}%
{%
\det\COOL@decide@paren{Det}{#1}%
}%
{ \ifthenelse{\equal{\COOL@notation@DetDisplay}{barenc}}%
{%
\left|#1\right|%
}%
{%
\PackageError{cool}{Invalid Option Sent}%
{`DetDisplay' can only be `det' or `barenc'}%
}}%
}
\newcommand{\COOL@notation@TrParen}{none}
\newcommand{\Tr}[2][]{%
\ifthenelse{\equal{#1}{}}
{%
\operatorname{Tr}\COOL@decide@paren{Tr}{#2}%
}%
{%
\operatorname{Tr}_{#1}\COOL@decide@paren{Tr}{#2}%
}%
}
\newcommand{\COOL@notation@IdentityMatrixParen}{p}
\newcounter{COOL@row}%
\newcounter{COOL@col}%
\newcommand{\COOL@notation@IdentityMatrixSymb}{\mathbbm{1}}
\newcommand{\IdentityMatrix}[1][0]{%
\isint{#1}{COOL@isint}%
\ifthenelse{\boolean{COOL@isint}}%
{%
\ifthenelse{ #1=0 }%
{%
\COOL@notation@IdentityMatrixSymb%
}%
{%
\setcounter{COOL@ct}{\value{MaxMatrixCols}}%
\setcounter{MaxMatrixCols}{#1}%
\ifthenelse{\equal{\COOL@notation@IdentityMatrixParen}{p}}%
{%
\begin{pmatrix}%
}%
{ \ifthenelse{\equal{\COOL@notation@IdentityMatrixParen}{b}}%
{%
\begin{bmatrix}%
}%
{ \ifthenelse{\equal{\COOL@notation@IdentityMatrixParen}{br}}%
{%
\begin{Bmatrix}%
}%
{%
\begin{matrix}%
}}}%
\forLoop{1}{#1}{COOL@row}%
{%
\ifthenelse{\NOT \value{COOL@row} = 1}{\\}{}%
\forLoop{1}{#1}{COOL@col}%
{%
\ifthenelse{ \NOT \value{COOL@col} = 1 }{&}{}%
\ifthenelse{ \value{COOL@row}=\value{COOL@col} }{1}{0}%
}%
}%
\ifthenelse{\equal{\COOL@notation@IdentityMatrixParen}{p}}%
{%
\end{pmatrix}%
}%
{ \ifthenelse{\equal{\COOL@notation@IdentityMatrixParen}{b}}%
{%
\end{bmatrix}%
}%
{ \ifthenelse{\equal{\COOL@notation@IdentityMatrixParen}{br}}%
{%
\end{Bmatrix}%
}%
{%
\end{matrix}%
}}}%
\setcounter{MaxMatrixCols}{\value{COOL@ct}}%
}%
}%
{%
\COOL@notation@IdentityMatrixSymb%
}%
}%
\endinput
%%
%% End of file `cool.sty'.
