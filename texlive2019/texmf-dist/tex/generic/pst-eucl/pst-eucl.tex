%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -*- Mode: Latex -*- %%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% pst-eucl.tex --- Generation of geometric figures in euclidean geometry
%% Copyright 2000-2013 Dominique RODRIGUEZ
%% Copyright 2014-     Dominique RODRIGUEZ, Herbert Vo√ü
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN
%% archives in directory macros/latex/base/lppl.txt.
%%
%% Author          : Dominique RODRIGUEZ (EN) <dominique.rodriguez@waika9.com>  
%%                 : hv hvoss@tug.org
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Require PSTricks and pst-node packages
\ifx\PSTnodesLoaded\endinput\else\input pst-node.tex\fi
\ifx\PSTArrowLoaded\endinput\else\input pst-arrow.tex\fi
\ifx\PSTtoolsLoaded\endinput\else\input pst-tools.tex\fi
%\ifx\PSTXKeyLoaded\endinput\else \input pst-xkey\fi
\ifx\MultidoLoaded\endinput \else\input multido.tex \fi
\csname PSTEuclideLoaded\endcsname
\let\PSTEuclideLoaded\endinput
%
\def\fileversion{1.64}
\def\filedate{2019/01/31}
%%
\message{`PST-Euclide v\fileversion, \filedate\space (dr,hv)}%
%% prologue for postcript
\pstheader{pst-eucl.pro}%
\edef\PstAtCode{\the\catcode`\@}%
\catcode`\@=11\relax
\pst@addfams{pst-eucl}
% Definition of the parameters
% ----------------------------
% symbol used for the point
\define@key[psset]{pst-eucl}{PointSymbol}[*]{%
  \def\psk@PointSymbol{#1}%
  \def\psk@PointSymbolA{#1}%
  \def\psk@PointSymbolB{#1}%
  \def\psk@PointSymbolC{#1}%
}%
\define@key[psset]{pst-eucl}{PointSymbolA}[*]{\def\psk@PointSymbolA{#1}}%
\define@key[psset]{pst-eucl}{PointSymbolB}[*]{\def\psk@PointSymbolB{#1}}%
\define@key[psset]{pst-eucl}{PointSymbolC}[*]{\def\psk@PointSymbolC{#1}}%
% name used for the point

\define@key[psset]{pst-eucl}{PointName}[default]{\def\psk@PointName{#1}}%
\define@key[psset]{pst-eucl}{PointNameA}[undef]{\def\psk@PointNameA{#1}}%
\define@key[psset]{pst-eucl}{PointNameB}[undef]{\def\psk@PointNameB{#1}}%
\define@key[psset]{pst-eucl}{PointNameC}[undef]{\def\psk@PointNameC{#1}}%
% use math mode in point name
\newif\ifPst@PtNameMath%
\define@key[psset]{pst-eucl}{PtNameMath}[false]{\@nameuse{Pst@PtNameMath#1}}%
\define@key[psset]{pst-eucl}{PointNameSize}[\normalsize]{\def\Point@Name@Size{#1}}%
\define@key[psset]{pst-eucl}{PointNameMathSize}[\textnormal]{\def\Point@Name@MathSize{#1}}%
% symbol used for marking equal length segment
\define@key[psset]{pst-eucl}{SegmentSymbol}[MarkHashh]{\def\psk@SegmentSymbol{#1}}%
\define@key[psset]{pst-eucl}{SegmentSymbolA}[MarkHashh]{\def\psk@SegmentSymbolA{#1}}%
\define@key[psset]{pst-eucl}{SegmentSymbolB}[MarkHashh]{\def\psk@SegmentSymbolB{#1}}%
\define@key[psset]{pst-eucl}{SegmentSymbolC}[MarkHashh]{\def\psk@SegmentSymbolC{#1}}%
\define@key[psset]{pst-eucl}{Mark}[undef]{\def\psk@Mark{#1}}%
\define@key[psset]{pst-eucl}{mark}[undef]{\def\psk@mark{Angle#1}}%  for angles
\define@key[psset]{pst-eucl}{MarkAngle}[undef]{\edef\psk@MarkAngle{#1}}%
\newdimen\psMarkHashLength
\newdimen\psMarkHashSep
\define@key[psset]{pst-eucl}{MarkHashLength}[1.25mm]{\pssetlength\psMarkHashLength{#1}}
\define@key[psset]{pst-eucl}{MarkHashSep}[0.625mm]{\pssetlength\psMarkHashSep{#1}}
\psset{MarkHashLength,MarkHashSep}% sets the defaults
%
% disance from point to its label
\define@key[psset]{pst-eucl}{PointNameSep}{\edef\psk@PointNameSep{#1}}%
% position angle for positionning a point name
\define@key[psset]{pst-eucl}{PosAngle}{\edef\psk@PosAngle{#1}}%
\iffalse
\define@key[psset]{pst-eucl}{PosAngle}{\expandafter\psk@@Pos@Angle#1,,!}%
\def\psk@@Pos@Angle#1,#2,#3#4#5!{%
  \typeout{1: #1; 2: #2; 3: #3; 4: #4; 5: #5}%
  \def\psk@PosAngle{#1}%
  \def\@temp{#1}%
  \ifx\@temp\@undef \typeout{Nichts machen}\else\typeout{Winkel setzen}%
    \ifx\relax#1\relax \def\psk@PosAngle{undef}\else\def\psk@PosAngleA{#1}\fi
    \ifx\relax#2\relax \else\def\psk@PosAngleB{#2}\fi
    \ifx\relax#3\relax \else\def\psk@PosAngleC{#3}\fi
  \fi
}
\fi
\define@key[psset]{pst-eucl}{PosAngleA}[undef]{\def\psk@PosAngleA{#1}}%
\define@key[psset]{pst-eucl}{PosAngleB}[undef]{\def\psk@PosAngleB{#1}}%
\define@key[psset]{pst-eucl}{PosAngleC}[undef]{\def\psk@PosAngleC{#1}}%
% dimension of the right angle mark
\define@key[psset]{pst-eucl}{RightAngleSize}[4]{\edef\psk@RightAngleSize{#1}}%
\define@key[psset]{pst-eucl}{RightAngleType}[default]{\edef\psk@RightAngleType{#1}}%
% radius of an angle mark
\define@key[psset]{pst-eucl}{MarkAngleRadius}[0.4]{\edef\psk@MarkAngleRadius{#1}}%
% angular offset position of the label for marking an angle
\define@key[psset]{pst-eucl}{LabelAngleOffset}[0]{\edef\psk@LabelAngleOffset{#1}}%
% position radius of the label for marking an angle
\define@key[psset]{pst-eucl}{LabelSep}[1]{\edef\psk@LabelSep{#1}}%
% ref point of the label
\define@key[psset]{pst-eucl}{LabelRefPt}[c]{\edef\psk@LabelRefPt{#1}}%
% curve type for point list
\define@key[psset]{pst-eucl}{CurveType}[none]{\edef\psk@CurveType{#1}}%
% coefficient of homothetie
\define@key[psset]{pst-eucl}{HomCoef}[0.5]{\edef\psk@HomCoef{#1}}%
% angle of rotation
\define@key[psset]{pst-eucl}{RotAngle}[60]{\edef\psk@RotAngle{#1}}%
% label for coding the transfortion
\define@key[psset]{pst-eucl}{TransformLabel}[none]{\edef\psk@TransformLabel{#1}}%
% private parameter
\newif\ifPst@CentralSym
\define@key[psset]{pst-eucl}{Central@Sym}[false]{\@nameuse{Pst@CentralSym#1}}%
% for drawing the circum-circle
\newif\ifPst@DrawCirABC
\define@key[psset]{pst-eucl}{DrawCirABC}[true]{\@nameuse{Pst@DrawCirABC#1}}%
% for coding a construction
\define@boolkey[psset]{pst-eucl}[Pst@]{CodeFig}[true]{}
%\define@boolkey[psset]{pst-eucl}[Pst@]{CodeFigA}[true]{\def\psk@CodeFigA{#1}}
%\define@boolkey[psset]{pst-eucl}[Pst@]{CodeFigB}[true]{\def\psk@CodeFigB{#1}}
\newif\ifPst@CodeFigA
\define@key[psset]{pst-eucl}{CodeFigA}[undef]{\edef\psk@CodeFigA{#1}\@nameuse{Pst@CodeFigA#1}}%
\newif\ifPst@CodeFigB
\define@key[psset]{pst-eucl}{CodeFigB}[undef]{\edef\psk@CodeFigB{#1}\@nameuse{Pst@CodeFigB#1}}%

\define@key[psset]{pst-eucl}{CodeFigColor}[cyan]{\edef\psk@CodeFigColor{#1}}%
\define@key[psset]{pst-eucl}{CodeFigStyle}[dashed]{\edef\psk@CodeFigStyle{#1}}%
\newif\ifPst@CodeFigAarc%
\define@key[psset]{pst-eucl}{CodeFigAarc}[true]{\@nameuse{Pst@CodeFigAarc#1}}
\newif\ifPst@CodeFigBarc%
\define@key[psset]{pst-eucl}{CodeFigBarc}[true]{\@nameuse{Pst@CodeFigBarc#1}}
%% for specifying a distance for the circle
\define@key[psset]{pst-eucl}{Radius}[none]{\edef\psk@Radius{#1}}%
\define@key[psset]{pst-eucl}{RadiusA}[undef]{\edef\psk@RadiusA{#1}}%
\define@key[psset]{pst-eucl}{RadiusB}[undef]{\edef\psk@RadiusB{#1}}%
\define@key[psset]{pst-eucl}{Diameter}[none]{\edef\psk@Diameter{#1}}%
\define@key[psset]{pst-eucl}{DiameterA}[undef]{\edef\psk@DiameterA{#1}}%
\define@key[psset]{pst-eucl}{DiameterB}[undef]{\edef\psk@DiameterB{#1}}%
% for specifying a distance for the circle
\define@key[psset]{pst-eucl}{DistCoef}[none]{\edef\psk@DistCoef{#1}}%
\define@key[psset]{pst-eucl}{AngleCoef}[none]{\edef\psk@AngleCoef{#1}}%
% for curvilign abscissa placement
\newif\ifPst@CurvAbsNeg%
\define@key[psset]{pst-eucl}{CurvAbsNeg}[false]{\@nameuse{Pst@CurvAbsNeg#1}}%
% first and last point of a generic curve
\define@key[psset]{pst-eucl}{GenCurvFirst}[none]{\edef\psk@GenCurvFirst{#1}}%
\define@key[psset]{pst-eucl}{GenCurvLast}[none]{\edef\psk@GenCurvLast{#1}}%
% increment of a generic curve
\define@key[psset]{pst-eucl}{GenCurvInc}[1]{\edef\psk@GenCurvInc{#1}}%
%% Default values
% --------------
\def\resetEUCLvalues{%
\psset[pst-eucl]{%
  PointSymbol=*, %PointSymbolA=*, PointSymbolB=*, PointSymbolC=*,
  PointName=default, PointNameA=undef, PointNameB=undef, PointNameC=undef,
  PtNameMath=true, PointNameMathSize=\textstyle, PointNameSize=\normalsize,
  PointNameSep=default, PosAngle=undef, 
  PosAngleA=undef,
  PosAngleB=undef, PosAngleC=undef, Mark=undef, mark=undef,SegmentSymbol=MarkHashh,
  SegmentSymbolA=MarkHashh, SegmentSymbolB=MarkHash, SegmentSymbolC=MarkHashhh,
  RightAngleSize=.4, RightAngleType=default, LabelAngleOffset=0, LabelSep=1,
  LabelRefPt=c, MarkAngle=undef, MarkAngleRadius=.4, HomCoef=.5, RotAngle=60,
  CurveType=none, TransformLabel=none, Central@Sym=false, DrawCirABC=true,
  CodeFig=false, CodeFigColor=cyan, CodeFigStyle=dashed, CodeFigA=undef,
  CodeFigB=undef, CodeFigAarc=true, CodeFigBarc=true, Radius=none, RadiusA=undef,
  RadiusB=undef, Diameter=none, DiameterA=undef, DiameterB=undef, DistCoef=none,
  AngleCoef=none, CurvAbsNeg=false, GenCurvFirst=none, GenCurvLast=none,
  GenCurvInc=1}}
\resetEUCLvalues
%\SpecialCoor        %% for using polar coordinates, node position, ...
\psset{dimen=middle}% remark of ML
\def\@undef{undef}%
\def\@default{default}%
\def\@german{german}%
\def\@suisseromand{suisseromand}%
\def\@polygon{polygon}
\def\@polyline{polyline}
\def\@curve{curve}
\def\@none{none}
\def\tx@PtoC{ tx@Dict begin PtoC end }
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% list for marking segment
\def\SegSymLst{MarkHash,MarkHashh,MarkHashhh,MarkCros,MarkCross,pstslash,pstslashh,pstslashhh,circ,times,cup,triangle,wedge}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% create a curve after a points list
\def\pst@MngTransformCurve{%DR 25032005
  \ifx\psk@CurveType\@none\else
    \ifx\psk@CurveType\@polygon\expandafter\pspolygon\@@GenCourbe\else
      \ifx\psk@CurveType\@polyline\expandafter\psline\@@GenCourbe\else
        \ifx\psk@CurveType\@curve\expandafter\pscurve\@@GenCourbe
  \fi\fi\fi\fi}%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% macros for managing a list of parameters
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
       %% begin DR 2005/04/10
\def\@List#1{\xdef\@NewList{none}\@List@i#1,\@nil\ignorespaces}
\def\@List@i#1,{%
\@List@ii#1==\@nil
\@ifnextchar\@nil{\@gobble}{\@List@i}}
\def\@List@ii#1=#2\@nil{%
\ifx\@NewList\@none\xdef\@NewList{#1}\else\xdef\@NewList{\@NewList,#1}\fi}%
       %% end DR 2005/04/10
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\@InitListMng{%
  \def\LastValidPN{default}\def\LastValidPNS{default}\def\LastValidPA{undef}\def\LastValidPS{undef}}
%% car(liste) -- param1,param2,... -> param1
\def\PstParamListFirst#1,#2/{#1}
%% cdr(liste) -- param1,param2,... -> param2,...

\def\PstParamListLasts#1,#2/{#2}

\def\Pst@ManageParamList#1{%DR 02092004 #1->point node name
  \edef\OldPointName{\psk@PointName}%
  \edef\psk@PointName{\expandafter\PstParamListFirst\OldPointName,undef/}%
  \ifx\psk@PointName\@undef\edef\psk@PointName{\LastValidPN}\else\edef\LastValidPN{\psk@PointName}\fi
  \edef\OldPointNameSep{\psk@PointNameSep}%
  \edef\psk@PointNameSep{\expandafter\PstParamListFirst\OldPointNameSep,default/}%
  \ifx\psk@PointNameSep\@default\edef\psk@PointNameSep{\LastValidPNS}\else\edef\LastValidPNS{\psk@PointNameSep}\fi
  \edef\OldPosAngle{\psk@PosAngle}%
  \edef\psk@PosAngle{\expandafter\PstParamListFirst\OldPosAngle,undef/}%
  \ifx\psk@PosAngle\@undef\edef\psk@PosAngle{\LastValidPA}\else\edef\LastValidPA{\psk@PosAngle}\fi
  \edef\OldPointSymbol{\psk@PointSymbol}%
  \edef\psk@PointSymbol{\expandafter\PstParamListFirst\OldPointSymbol,undef/}%
  \ifx\psk@PointSymbol\@undef\edef\psk@PointSymbol{\LastValidPS}\else\edef\LastValidPS{\psk@PointSymbol}\fi
  \Pst@geonodelabel{#1}%DR 02092004
  \edef\psk@PointName{\expandafter\PstParamListLasts\OldPointName,undef/}%
  \edef\psk@PointNameSep{\expandafter\PstParamListLasts\OldPointNameSep,default/}%
  \edef\psk@PosAngle{\expandafter\PstParamListLasts\OldPosAngle,undef/}%
  \edef\psk@PointSymbol{\expandafter\PstParamListLasts\OldPointSymbol,undef/}}%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% create a point with an associated node,
%% #1 -> options
%% #2 -> coordinates
%% #3 -> node name
\def\pstGeonode{\@ifnextchar[\Pst@Geonode{\Pst@Geonode[]}}
\def\Pst@Geonode[#1]{\@ifnextchar({\Pst@Geonode@i[#1]}{\Pst@Geonode@i[#1](0,0)}}
\def\Pst@Geonode@i[#1]{%
  \begingroup
    \@InitListMng% DR 22032005
    \xdef\@@GenCourbe{}%%for accumulating points% DR 22032005
    \psset{#1}%
    \Pst@Geonode@ii}
\def\Pst@Geonode@ii(#1)#2{%
  \pnode(#1){#2}
  \xdef\@@GenCourbe{\@@GenCourbe(#2)}%%for accumulating points% DR 22032005
  \Pst@ManageParamList{#2}%
  \@ifnextchar(\Pst@Geonode@ii{\pst@MngTransformCurve\endgroup}}% DR 22032005

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% create a point with an associated node, in a new
%% landmark
%% #1 -> options
%% #2 -> coordinates
%% #3 -> node name
%% #4 -> O: new center of the landmark
%% #5 -> I: abscissa reference
%% #6 -> J: ordinate reference
\def\pstOIJGeonode{\@ifnextchar[\Pst@OIJGeonode{\Pst@OIJGeonode[]}}%
\def\Pst@OIJGeonode[#1]{%NEW DR 14112001 (for default (0,0) ccordinates)
  \@ifnextchar({\Pst@OIJGeonode@i[#1]}{\Pst@OIJGeonode[#1](0,0)}}%
\def\Pst@OIJGeonode@i[#1]{%
  \begingroup
    \@InitListMng% DR 22032005
    \edef\@@GenCourbe{}%%for accumulating points% DR 22032005
    \psset{#1}\Pst@OIJGeonode@ii}
\def\Pst@OIJGeonode@ii(#1)#2#3#4#5{\Pst@OIJGeonode@iii{#3}{#4}{#5}(#1){#2}}
\def\Pst@OIJGeonode@iii#1#2#3(#4)#5{%
  \rput(#1){%
    \pst@@getcoor{#4}%
    \rput(!\pst@coor\space
      tx@EcldDict begin /N@#2 GetNode /N@#3 GetNode end
      4 index mul 3 -1 roll 5 index mul add
      \pst@number\psyunit dup mul div  exch
      4 -1 roll mul 3 -1 roll 4 -1 roll mul add
      \pst@number\psxunit dup mul div exch){\pnode{#5}}}%
  \xdef\@@GenCourbe{\@@GenCourbe(#5)}%%for accumulating points% DR 22032005
  \Pst@ManageParamList{#5}%
  \@ifnextchar({\Pst@OIJGeonode@iii{#1}{#2}{#3}}{\pst@MngTransformCurve\endgroup}}% DR 22032005
%%end modif DR 11/2003
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% #1 -> point coordinates
\def\Pst@geonodelabel#1{%            % {nodename}
  \ifx\psk@PointSymbol\@none
    \ifx\psk@PointName\@none\else\Pst@PutPointLabel{#1}\fi
  \else
%      \ifx\psk@PointSymbol\@default \def\psk@PointSymbol{*}\fi%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      \psdot[dotstyle=\psk@PointSymbol](#1)%
      \Pst@PutPointLabel{#1}%DR 041104
  \fi%DR 02092004
%  \ifx\psk@PointName\@none\else\Pst@PutPointLabel{#1}\fi%DR 041104
}%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\Pst@PutPointLabel#1{%DR 041104
  \ifx\psk@PointName\@none\else
    \rput{*0}([nodesep=\ifx\psk@PointNameSep\@default{1em}\else\psk@PointNameSep\fi,
               angle=\ifx\psk@PosAngle\@undef{0}\else\psk@PosAngle\fi]#1)%
      {\ifPst@PtNameMath $\Point@Name@MathSize\Pst@WhichLabel{#1}$\else\Point@Name@Size\Pst@WhichLabel{#1}\fi}
  \fi}%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\Pst@WhichLabel#1{\ifx\psk@PointName\@default#1\else\psk@PointName\fi}%DR 0
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% #2 #3 -> nodes defining the segment to mark
\def\pstSegmentMark{\@ifnextchar[\Pst@SegmentMark{\Pst@SegmentMark[]}}%
\def\Pst@SegmentMark[#1]#2#3{%
  \bgroup
  \psset{#1}%            % Affectation of local parameters
  \ncline[nodesep=0]{#2}{#3}
  \ncput[nrot=:U]{$\expandafter\@nameuse\expandafter{\psk@SegmentSymbol}$}%  $
  \egroup%
}%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% macros for marking
\def\pstslash{/}%
\def\pstslashh{/\kern-2pt/}%
\let\pstslashslash=\pstslashh
\def\pstslashhh{/\kern-1.4pt/\kern-1.4pt/}%
\let\pstslashslashslash=\pstslashhh
\def\Anglepstslash{\rput{\ifx\psk@MarkAngle\@undef0\else\psk@MarkAngle\fi}(0,0){\pstslash}}
\def\Anglepstslashh{\rput{\ifx\psk@MarkAngle\@undef0\else\psk@MarkAngle\fi}(0,0){\pstslashh}}
\def\Anglepstslashhh{\rput{\ifx\psk@MarkAngle\@undef0\else\psk@MarkAngle\fi}(0,0){\pstslashhh}}
\let\Anglepstslashslash=\Anglepstslashh%
\let\Anglepstslashslashslash=\Anglepstslashhh%
%%begin modif alaindelplanque 11/2003
%%begin modif Germain Boyer 04/2014
\def\MarkHash{%
     \rput{\ifx\psk@MarkAngle\@undef45\else\psk@MarkAngle\fi}
     {\psline(-\psMarkHashLength,0)(\psMarkHashLength,0)}}
\def\MarkHashh{%
      \rput{\ifx\psk@MarkAngle\@undef45\else\psk@MarkAngle\fi}(-0.5\psMarkHashSep,0)
     {\psline(-\psMarkHashLength,0)(\psMarkHashLength,0)}
      \rput{\ifx\psk@MarkAngle\@undef45\else\psk@MarkAngle\fi}(0.5\psMarkHashSep,0)
     {\psline(-\psMarkHashLength,0)(\psMarkHashLength,0)}}
\def\MarkHashhh{%
     \rput{\ifx\psk@MarkAngle\@undef45\else\psk@MarkAngle\fi}(-\psMarkHashSep,0)
     {\psline(-\psMarkHashLength,0)(\psMarkHashLength,0)}
      \rput{\ifx\psk@MarkAngle\@undef45\else\psk@MarkAngle\fi}
     {\psline(-\psMarkHashLength,0)(\psMarkHashLength,0)}
      \rput{\ifx\psk@MarkAngle\@undef45\else\psk@MarkAngle\fi}(\psMarkHashSep,0)
     {\psline(-\psMarkHashLength,0)(\psMarkHashLength,0)}}
\iffalse         %%%%%% hv 2014/04/05
\def\MarkHash{%
  \rput{\ifx\psk@MarkAngle\@undef45\else\psk@MarkAngle\fi}
    {\psline(-10\pslinewidth,0)(10\pslinewidth,0)}}
\let\AngleMarkHash\MarkHash
\def\MarkHashh{%
  \rput{\ifx\psk@MarkAngle\@undef45\else\psk@MarkAngle\fi}(-3\pslinewidth,0)
    {\psline(-10\pslinewidth,0)(10\pslinewidth,0)}
  \rput{\ifx\psk@MarkAngle\@undef45\else\psk@MarkAngle\fi}(3\pslinewidth,0)
    {\psline(-10\pslinewidth,0)(10\pslinewidth,0)}}
\def\AngleMarkHashh{%
  \rput{\ifx\psk@MarkAngle\@undef0\else\psk@MarkAngle\fi}(0,0){%
    \psline(-10\pslinewidth,-3\pslinewidth)(10\pslinewidth,-3\pslinewidth)
    \psline(-10\pslinewidth,3\pslinewidth)(10\pslinewidth,3\pslinewidth)}}
\def\MarkHashhh{%
  \rput{\ifx\psk@MarkAngle\@undef45\else\psk@MarkAngle\fi}(-6\pslinewidth,0)
    {\psline(-10\pslinewidth,0)(10\pslinewidth,0)}
  \rput{\ifx\psk@MarkAngle\@undef45\else\psk@MarkAngle\fi}
    {\psline(-10\pslinewidth,0)(10\pslinewidth,0)}
  \rput{\ifx\psk@MarkAngle\@undef45\else\psk@MarkAngle\fi}(6\pslinewidth,0)
    {\psline(-10\pslinewidth,0)(10\pslinewidth,0)}}
\fi
\def\AngleMarkHashhh{%
  \rput[c]{\ifx\psk@MarkAngle\@undef0\else\psk@MarkAngle\fi}(0,0){%
    \psline(-10\pslinewidth,-4\pslinewidth)(10\pslinewidth,-4\pslinewidth)
    \psline(-10\pslinewidth,0)(10\pslinewidth,0)
    \psline(-10\pslinewidth,4\pslinewidth)(10\pslinewidth,4\pslinewidth)}}
\def\MarkCros{
  \psline(-4\pslinewidth,4\pslinewidth)(4\pslinewidth,-4\pslinewidth)
  \psline(-4\pslinewidth,-4\pslinewidth)(4\pslinewidth,4\pslinewidth)}
\let\AngleMarkCros\MarkCros
\def\MarkCross{
  \psline(-4\pslinewidth,8\pslinewidth)(4\pslinewidth,0)
  \psline(-4\pslinewidth,0)(4\pslinewidth,8\pslinewidth)
  \psline(-4\pslinewidth,-8\pslinewidth)(4\pslinewidth,0)
  \psline(-4\pslinewidth,0)(4\pslinewidth,-8\pslinewidth)}
\let\AngleMarkCross\MarkCross
\def\MarkCirc{\pscircle(0,0){2\pslinewidth}}
\let\AngleMarkCirc\MarkCirc
% MarkArrow >
\def\MarkArrow{%
  \psline[linestyle=none,veearrowlength=\psMarkHashLength,
          veearrowangle=90,veearrowlinewidth=\pslinewidth,
          ArrowInside=-v](-\psMarkHashLength,0)(\psMarkHashLength,0)}%
\def\MarkArroww{%
  \psline[linestyle=none,veearrowlength=\psMarkHashLength,
          veearrowangle=90,veearrowlinewidth=\pslinewidth,
          ArrowInsideNo=2,ArrowInside=-v](-2\psMarkHashLength,0)(2\psMarkHashLength,0)}%
\def\MarkArrowww{%
  \psline[linestyle=none,veearrowlength=\psMarkHashLength,
          veearrowangle=90,veearrowlinewidth=\pslinewidth,
          ArrowInsideNo=3,ArrowInside=-v](-2.5\psMarkHashLength,0)(2.5\psMarkHashLength,0)}%
%
%%end modif alaindelplanque 11/2003
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% #1 #2 #3 -> 3 nodes for defining the right angle
\def\pstRightAngle{\pst@object{pstRightAngle}}
\def\pstRightAngle@i#1#2#3{%
  \begingroup
  \addbefore@par{dimen=inner,dotscale=1}%linestyle=solid,linecolor=black,linewidth=\pslinewidth}
  \use@par%            % Affectation of local parameters
  %% not good at all, but \rput{0}(#3){\rput{(#2)}{stuff}} doesn't work...
  \rput(#2){%
    \ifx\psk@RightAngleType\@default
      \ifx\psk@fillstylename\@none\else
        \pspolygon[linestyle=none,dimen=inner](0,0)(!tx@EcldDict begin /N@#1 GetNode exch Atan \psk@RightAngleSize\space exch PtoC end)%
             (!tx@EcldDict begin /N@#1 GetNode exch Atan \psk@RightAngleSize\space exch PtoC end)%
             (!tx@EcldDict begin /N@#1 GetNode exch Atan /AngleNo1 ED
               tx@EcldDict begin /N@#3 GetNode exch Atan /AngleNo3 ED
               AngleNo1 AngleNo3 sub abs 180 gt { /Diff -45 def }{ /Diff 45 def } ifelse
               AngleNo1 AngleNo3 gt { AngleNo1 Diff sub }{ AngleNo3 Diff sub } ifelse
                 \psk@RightAngleSize\space 2 sqrt mul exch PtoC end)%
             (!tx@EcldDict begin /N@#3 GetNode exch Atan \psk@RightAngleSize\space exch PtoC end)%
      \fi
      \psline[fillstyle=none](!tx@EcldDict begin /N@#1 GetNode exch Atan \psk@RightAngleSize\space exch PtoC end)%
             (!tx@EcldDict begin /N@#1 GetNode exch Atan \psk@RightAngleSize\space exch PtoC end)%
             (!tx@EcldDict begin /N@#1 GetNode exch Atan /AngleNo1 ED
               tx@EcldDict begin /N@#3 GetNode exch Atan /AngleNo3 ED
               AngleNo1 AngleNo3 sub abs 180 gt { /Diff -45 def }{ /Diff 45 def } ifelse
               AngleNo1 AngleNo3 gt { AngleNo1 Diff sub }{ AngleNo3 Diff sub } ifelse
                 \psk@RightAngleSize\space 2 sqrt mul exch PtoC end)%
             (!tx@EcldDict begin /N@#3 GetNode exch Atan \psk@RightAngleSize\space exch PtoC end)%
    \else
      \ifx\psk@RightAngleType\@german
%        \ifx\psk@fillstylename\@none\else
%          \pscustom[linestyle=none,dimen=inner]{\psline(0,0)
%            \pstMarkAngle[MarkAngleRadius=\psk@RightAngleSize,LabelSep=\psk@RightAngleSize\space .5 mul]{#1}{#2}{#3}{}%
%            \psline(0,0)
%          }
%        \fi
        \pstMarkAngle[MarkAngleRadius=\psk@RightAngleSize,LabelSep=\psk@RightAngleSize\space .5 mul]{#1}{#2}{#3}%
           {\psscalebox{\psk@RightAngleSize}{\pscircle*{!.08 \psk@xdotscale\space mul}}}%
      \else
        \ifx\psk@RightAngleType\@suisseromand
          \rput{*0}%
            (!tx@EcldDict begin /N@#3 GetNode exch Atan /N@#1 GetNode exch Atan
              2 copy lt { exch 360 sub exch } if add 2 div .45 \psk@RightAngleSize\space mul exch PtoC end)%
              {\psscalebox{\psk@RightAngleSize}{\pscircle*{.08}}}%
            \psline(0,0)%
              (!tx@EcldDict begin /N@#3 GetNode exch Atan \psk@RightAngleSize\space exch PtoC end )%
              (!tx@EcldDict begin /N@#1 GetNode exch Atan \psk@RightAngleSize\space exch PtoC end )%
    \fi\fi\fi}%
  \endgroup\ignorespaces%  hv 20130312
}%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% #2 #3 #4 -> 3 nodes for defining the angle
%% #5 -> label
\def\pstMarkAngle{\@ifnextchar[\Pst@MarkAngle{\Pst@MarkAngle[]}}%
%\def\pstMarkAngle{\@ifnextchar[\Pst@MarkAngle@i{\Pst@MarkAngle@i[]}}%
%\def\Pst@MarkAngle@i[#1]{\@ifnextchar+{\Pst@MarkAngle@ii[#1]}{\Pst@MarkAngle@iii[#1]}}%
%\def\Pst@MarkAngle@ii[#1]+#2#3#4#5{%
%
%%  here we should check the angle size for right angles
%
\def\Pst@MarkAngle[#1]#2#3#4#5{{%
  \psset{%MarkAngle=0,
    #1}%
  \rput(#3){%
    \ifx\psk@fillstylename\@none\else
      \pscustom[linestyle=none,linewidth=0.01pt,arrows=-]{%
        \psline(0,0)
        \psarc(0,0){\psk@MarkAngleRadius}{(#2)}{(#4)}        
        \psline(0,0)
      }
    \fi
    \psarc[fillstyle=none](0,0){\psk@MarkAngleRadius}{(#2)}{(#4)}%
    \rput[\psk@LabelRefPt]{*0}(! tx@EcldDict begin
        /N@#4 GetNode exch Atan /N@#2 GetNode exch Atan end
        2 copy lt { exch 360 sub exch } if
        add 2 div dup /psRawLabelPos ED
        \psk@LabelAngleOffset\space add
        \psk@LabelSep\space exch PtoC){#5}%
    \def\pst@tempA{Angleundef}%
%% define \pst@rot@angle to make it compatible with xelatex for later use
    \edef\pst@rot@angle{ tx@EcldDict begin % expand the #4 and #2
        /N@#4 GetNode exch Atan /N@#2 GetNode exch Atan end
        2 copy lt \pslbrace exch 360 sub exch \psrbrace if
        add 2 div \psk@LabelAngleOffset\space add }%
    \rput[\psk@LabelRefPt]{!\pst@rot@angle\space \ifx\psk@MarkAngle\@undef 0 \else\psk@MarkAngle\space\fi add }%
      (! \psk@MarkAngleRadius\space psRawLabelPos PtoC)%
      {\ifx\psk@mark\pst@tempA\csname\psk@Mark\endcsname\else\csname\psk@mark\endcsname\fi}%
}%
}}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% #2 #4 #6 -> coordinates for nodes
%% #3 #5 #7 -> nodes name
\def\pstTriangle{\pst@object{pstTriangle}}%
\def\pstTriangle@i{\@ifnextchar(\pstTriangle@ii{\pstTriangle@ii(0,0)}}%
\def\pstTriangle@ii(#1)#2(#3)#4(#5)#6{%
  \pst@killglue
  %%begin modif alaindelplanque 11/2003
  \pst@getcoor{#1}\@@coordi
  \pst@getcoor{#3}\@@coordiii
  \pst@getcoor{#5}\@@coordv
  \pstVerb{
      \@@coordi\space\@@coordiii\space exch 4 1 roll \@@coordv\space exch 6 1 roll % x x x y y y
      add add 3 div /YS exch def add add 3 div /XS exch def
  }%
  \bgroup
  \use@keep@par
  \bgroup
  \ifx\psk@PosAngleA\@undef
    \psset{PosAngleA={!
      /AngleAB \@@coordi\space\@@coordiii\space tx@EcldDict begin ABVect end exch Atan def
      /AngleAC \@@coordi\space\@@coordv\space tx@EcldDict begin ABVect end exch Atan def
      AngleAB AngleAC add 2 div dup
      1 exch \tx@PtoC exch \@@coordi\space 4 1 roll add 3 1 roll add XS YS Pyth2 % test if inside/outside
      \@@coordi\space XS YS Pyth2 le { 180 add } if
    }}%% <------ hv
  \else
    \psset{PosAngle=\psk@PosAngleA}
  \fi
  \ifx\psk@PosAngleA\@undef\else\psset{PosAngle=\psk@PosAngleA}\fi
  \let\psk@PointSymbol=\psk@PointSymbolA
  \ifx\psk@PointNameA\@undef\else\psset{PointName=\psk@PointNameA}\fi
  \Pst@Geonode@i[](#1){#2}
  \egroup
  \bgroup
  \use@keep@par
  \ifx\psk@PosAngleB\@undef
    \psset{PosAngleB={!
      /AngleBC \@@coordiii\space\@@coordv\space tx@EcldDict begin ABVect end exch Atan def
      /AngleBA \@@coordiii\space\@@coordi\space tx@EcldDict begin ABVect end exch Atan def
      AngleBA AngleBC add 2 div dup 1 exch \tx@PtoC exch \@@coordiii\space  4 1 roll add 3 1 roll add XS YS Pyth2
      \@@coordiii\space XS YS Pyth2 le { 180 add } if
    }}%% <------ hv
  \else
    \psset{PosAngle=\psk@PosAngleB}
  \fi
  \ifx\psk@PosAngleB\@undef\else\psset{PosAngle=\psk@PosAngleB}\fi
  \let\psk@PointSymbol=\psk@PointSymbolB
  \ifx\psk@PointNameB\@undef\else\psset{PointName=\psk@PointNameB}\fi
  \Pst@Geonode@i[](#3){#4}%
  \egroup
  \ifx\psk@PosAngleC\@undef
   \psset{PosAngleC={!
      /AngleCB \@@coordv\space\@@coordiii\space tx@EcldDict begin ABVect end exch Atan def
      /AngleCA \@@coordv\space\@@coordi\space tx@EcldDict begin ABVect end exch Atan def
      AngleCB AngleCA add 2 div dup 1 exch \tx@PtoC exch \@@coordv\space  4 1 roll add 3 1 roll add XS YS Pyth2
      \@@coordv\space XS YS Pyth2 le { 180 add } if
   }}%% <------ hv
  \else
    \psset{PosAngle=\psk@PosAngleC}
  \fi
  \ifx\psk@PosAngleC\@undef\else\psset{PosAngle=\psk@PosAngleC}\fi
  \let\psk@PointSymbol=\psk@PointSymbolC
  \ifx\psk@PointNameC\@undef\else\psset{PointName=\psk@PointNameC}\fi
  \Pst@Geonode@i[](#5){#6}%%NEW DR 15112001
  \pst@TraceTriangle{#2}{#4}{#6}%
  \egroup
}%
%
\def\pst@TraceTriangle#1#2#3{\pspolygon(#1)(#2)(#3)}%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%            Line, circle, Arc
%% #2 #3 -> 2 nodes defining the line
\def\pstLineAB{\ncline}%@ifnextchar[\Pst@LineAB{\Pst@LineAB[]}}%
%\def\Pst@LineAB[#1]#2#3{\ncline[#1]{#2}{#3}}%
%% #2 #3 -> 2 nodes defining the center and a point on the circle
\def\pstCircleOA{\pst@object{pstCircleOA}}%
\def\pstCircleOA@i#1#2{%
  \bgroup\use@par%
  \rput(#1){%
    \begin@ClosedObj
      \def\pst@linetype{4}%
      \addto@pscode{%
        tx@EcldDict begin
          /N@#1 GetNode
          \ifx\psk@Radius\@none
            \ifx\psk@Diameter\@none
              2 copy /N@#2 GetNode ABDist
            \else\psk@Diameter 2 div
            \fi
          \else\psk@Radius\space
          \fi
        end
        \psk@dimen CLW mul sub 0 360 arc closepath}%
      \showpointsfalse
    \end@ClosedObj
  }%
  \egroup%
}%
%% #2 #3 -> 2 nodes defining a diameter of the circle
\def\pstCircleAB{\pst@object{pstCircleAB}}%
\def\pstCircleAB@i#1#2{%
  \bgroup\use@par%
    \Pst@MiddleAB[PointSymbol=none, PointName=none]{#2}{#1}{@MAB}{}
    \rput(#1){%
      \begin@ClosedObj
        \def\pst@linetype{4}%
        \addto@pscode{%
          tx@NodeDict begin
            tx@NodeDict /N@@MAB load GetCenter
          end
          2 copy
          tx@EcldDict begin /N@#2 GetNode ABDist end
          \psk@dimen CLW mul sub 0 360 arc closepath}%
        \showpointsfalse
      \end@ClosedObj
    }%
  \egroup%
}%
%% #2 #3 #4 -> 3 nodes defining the center and two points on the circle
\def\pstArcOAB{\pst@object{pstArcOAB}}%
\def\pstArcnOAB{\pst@object{pstArcnOAB}}%
\def\pstArcnOAB@i{\def\psarc@type{1}\pstArcOAB@i}%
\def\pstArcOAB@i{\pstArcOAB@ii}%\@ifnextchar[\pstArcOAB@ii{\pstArcOAB@ii[]}}%
%OLD%%\def\pstArcOAB@ii#1#2#3{%[#1]#2#3#4{%
%OLD%%  \bgroup\use@par%
%OLD%%  \rput(#1){\pstArcOAB@iii{#2}{#3}}%
%OLD%%  \egroup%
%OLD%%}%
%OLD%%\def\pstArcOAB@iii#1#2%
\def\pstArcOAB@ii#1#2#3{%
  \begin@OpenObj%
    %OLD%%\addto@pscode{\pstArcOAB@iv{#1}{#2} \pstArcOAB@v}%
    \addto@pscode{\pstArcOAB@iv{#1}{#2}{#3} \pstArcOAB@v}%
    \gdef\psarc@type{0}%
    \showpointsfalse
  \end@OpenObj%
}%% end \pstArcOAB@iii
%OLD%%\def\pstArcOAB@iv#1#2%
\def\pstArcOAB@iv#1#2#3{%
  %%\pst@coor /y ED /x ED /r
  %OLD%%0 0 /y ED /x ED /r %%new DR 2005/10/21
  tx@EcldDict begin /N@#1 GetNode end /y ED /x ED /r %%new DR 2005/10/21
  %OLD%%tx@EcldDict begin /N@#1 GetNode end
  tx@EcldDict begin /N@#2 GetNode /N@#1 GetNode ABVect end
  Pyth  def /c 57.2957 r \tx@Div def /angleA
  %OLD%%tx@EcldDict begin /N@#1 GetNode end
  tx@EcldDict begin /N@#2 GetNode /N@#1 GetNode ABVect end
  exch Atan \psk@arcsepA c mul 2 div
  \ifcase \psarc@type add \or sub \fi def
  /angleB
  %OLD%%tx@EcldDict begin /N@#2 GetNode end
  tx@EcldDict begin /N@#3 GetNode /N@#1 GetNode ABVect end
  exch Atan \psk@arcsepB c mul 2 div
  \ifcase \psarc@type sub \or add \fi def
  %ifshowpoints\psarc@showpoints\fi
  \ifx\psk@arrowA\@empty
    \ifnum\psk@liftpen=2 r angleA PtoC
      y add exch x add exch
      moveto
    \fi
  \fi%
}%% end \pstArcOAB@iv
\def\pstArcOAB@v{%
  x y r angleA
  \ifx\psk@arrowA\@empty\else
    { ArrowA CP } { \ifcase\psarc@type add \or sub \fi }%
    \tx@ArcArrow
  \fi
  angleB
  \ifx\psk@arrowB\@empty\else
    { ArrowB } { \ifcase\psarc@type sub \or add \fi }%
    \tx@ArcArrow
  \fi
  \ifcase\psarc@type arc \or arcn \fi%
}%% end \pstArcOAB@v
\def\pstArcOAB@showpoints{%
  gsave newpath x y moveto x y r \pst@tempa \pst@tempb
  \ifcase\psarc@type arc \or arcn \fi
  closepath CLW 2 div SLW [ \psk@dash\space ] 0 setdash stroke
  grestore %
}%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                     HOMOTETHIE
%% #2 -> centre
%% #3 -> antecedent
%% #4 -> node name of the homothetic of #1
\def\pstHomO{\@ifnextchar[\Pst@HomO{\Pst@HomO[]}}%
\expandafter\ifx\csname psteucl@old\endcsname\relax%% NEW SYNTAX %% DR 2005/04/10
\def\Pst@HomO[#1]#2{%
  \bgroup%
  \@InitListMng\def\LastValidSS{default}%%SS means SegmentSymbol
  \psset{#1}\def\@HomCtr{#2}% Affectation of local parameters
  \edef\@@GenCourbe{}%%for accumulating points
  \Pst@HomO@i%
}%
\def\Pst@HomO@i#1{%
  \@List{#1}\edef\@antecedentLst{\@NewList}
  \@ifnextchar[\Pst@HomO@ii{\Pst@HomO@ii[default]}%
}%
\def\Pst@HomO@ii[#1]{%
  \@List{#1}\edef\@imageLst{\@NewList}
  \edef\@antecedent{\expandafter\PstParamListFirst\@antecedentLst,undef/}
  \edef\@image{\expandafter\PstParamListFirst\@imageLst,default/}
  \Pst@HomO@iii%
}%
\def\Pst@HomO@iii{%
  \ifx\@image\@default\def\@image{\@antecedent '}\fi
  \rput(\@HomCtr){%
    \rput(!
      tx@EcldDict begin /N@\@antecedent\space GetNode end
      \psk@HomCoef\space mul exch \psk@HomCoef\space mul exch
      \pst@number\psyunit div exch \pst@number\psxunit div
      exch){\pnode{\@image}}%
      }%%end rput
  \xdef\@@GenCourbe{\@@GenCourbe(\@image)}%%for accumulating points
  \ifPst@CentralSym\ifPst@CodeFig
    \edef\psk@OldSegmentSymbol{\psk@SegmentSymbol}%
    \edef\psk@SegmentSymbol{\expandafter\PstParamListFirst\psk@OldSegmentSymbol,undef/}%
    \ifx\psk@SegmentSymbol\@undef\edef\psk@SegmentSymbol{\LastValidSS}\else\edef\LastValidSS{\psk@SegmentSymbol}\fi
    \bgroup%
    \psset{linecolor=\psk@CodeFigColor, linestyle=\psk@CodeFigStyle}%
    \pstSegmentMark{\@image}{\@HomCtr}%
    \pstSegmentMark{\@HomCtr}{\@antecedent}%
    \egroup%
    \edef\psk@SegmentSymbol{\expandafter\PstParamListLasts\psk@OldSegmentSymbol,undef/}%
  \fi\fi%
  \Pst@ManageParamList{\@image}%
  \edef\@antecedentLst{\expandafter\PstParamListLasts\@antecedentLst,undef/}%
  \edef\@imageLst{\expandafter\PstParamListLasts\@imageLst,default/}%
  \edef\@LastValidantecedent{\@antecedent}\def\@LastValidimage{\@image}
  \edef\@antecedent{\expandafter\PstParamListFirst\@antecedentLst,undef/}%
  \edef\@image{\expandafter\PstParamListFirst\@imageLst,default/}
  \ifx\@antecedent\@undef\def\@End{\pst@MngTransformCurve\egroup}
  \else\def\@End{\Pst@HomO@iii}\fi%
  \@End%
}%
\else%% OLD SYNTAX
\def\Pst@HomO[#1]#2{%
  \bgroup%
  \@InitListMng\def\LastValidSS{default}%%
  \psset{#1}\def\@HomCtr{#2}% Affectation of local parameters
  \edef\@@GenCourbe{}%%for accumulating points
  \Pst@HomO@i-%
}%
\def\Pst@HomO@i-#1#2{%
  \rput(\@HomCtr){%
    \rput(!
      tx@EcldDict begin /N@#1 GetNode end
      \psk@HomCoef\space mul exch \psk@HomCoef\space mul exch
      \pst@number\psyunit div exch \pst@number\psxunit div
      exch){\pnode{#2}}%
      }%%end rput
  \xdef\@@GenCourbe{\@@GenCourbe(#2)}%%for accumulating points
  \ifPst@CentralSym\ifPst@CodeFig
    \edef\psk@OldSegmentSymbol{\psk@SegmentSymbol}%
    \edef\psk@SegmentSymbol{\expandafter\PstParamListFirst\psk@OldSegmentSymbol,undef/}%
    \ifx\psk@SegmentSymbol\@undef\edef\psk@SegmentSymbol{\LastValidSS}\else\edef\LastValidSS{\psk@SegmentSymbol}\fi
    \bgroup%
    \psset{linecolor=\psk@CodeFigColor, linestyle=\psk@CodeFigStyle}%
    \pstSegmentMark{#2}{\@HomCtr}%
    \pstSegmentMark{\@HomCtr}{#1}%
    \egroup%
    \edef\psk@SegmentSymbol{\expandafter\PstParamListLasts\psk@OldSegmentSymbol,undef/}%
  \fi\fi%
  \Pst@ManageParamList{#2}%
  \@ifnextchar-{\Pst@HomO@i}{\pst@MngTransformCurve\egroup}%
}%
\fi% END OLD SYNTAX %% DR 2005/04/10
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                   Central Symmetry
%% #2 -> centre
%% #3 -> antecedent
%% #4 -> node name of the symmetrical point of #3
\def\pstSymO{\@ifnextchar[\Pst@SymO{\Pst@SymO[]}}%
\def\Pst@SymO[#1]{\Pst@HomO[SegmentSymbol=\SegSymLst,#1, HomCoef=-1, Central@Sym=true]}%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                   Middle of a Segment
%% #2 #3 -> 2 nodes defining the segment
%% #4    -> node name of the middle of [#2 #3]
\def\pstMiddleAB{\@ifnextchar[\Pst@MiddleAB{\Pst@MiddleAB[]}}%
\def\Pst@MiddleAB[#1]#2#3#4{%
  \bgroup\psset{#1, HomCoef=.5}% % Affectation of local parameters
  %%begin modif alaindelplanque 11/2003
  \ifx\psk@PosAngle\@undef% Calcul automatique de PosAngle
    \psset{PosAngle={!tx@EcldDict begin /N@#3 GetNode exch /N@#2 GetNode end
        4 1 roll sub 3 1 roll sub Atan}}
  \fi
  %%end modif alaindelplanque 11/2003
  \expandafter\ifx\csname psteucl@old\endcsname\relax\Pst@HomO[]{#2}{#3}[#4]%
  \else\Pst@HomO[]{#2}{#3}{#4}\fi%%%DR 14042005
  \ifPst@CodeFig
    \psset{linecolor=\psk@CodeFigColor, linestyle=\psk@CodeFigStyle}%
    \pstSegmentMark{#2}{#4}%
    \pstSegmentMark{#4}{#3}%
  \fi%
  \egroup
}%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%           Centre of Gravity of a Triangle
%% #2 #3 #4 -> 3 nodes defining the triangle
%% #5       -> node name of the centre of gravity of #2 #3 #4
\def\pstCGravABC{\@ifnextchar[\Pst@CGravABC{\Pst@CGravABC[]}}%
\def\Pst@CGravABC[#1]#2#3#4#5{%
  \bgroup\psset{#1}% % Affectation of local parameters
  \Pst@OIJGeonode@i[](! 1 3 div dup){#5}{#2}{#3}{#4}%DR: 22/03/03
  \egroup
}%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%           Centre of the circoncrit circle
%% #2 #3 #4 -> 3 nodes defining the triangle
%% #5       -> node name of the centre of the circle
\def\pstCircleABC{\@ifnextchar[\Pst@CircleABC{\Pst@CircleABC[]}}%
\def\Pst@CircleABC[#1]#2#3#4#5{%
  \bgroup\psset{#1}% % Affectation of local parameters
  \rput(#2){%DR: 22/03/03
    \rput(!
      tx@EcldDict begin
        /N@#3 GetNode 2 copy Pyth 3 1 roll exch Atan %Rb Thetab
        dup 3 1 roll %Thetab Rb Thetab
        /N@#4 GetNode 2 copy Pyth 3 1 roll exch Atan %Thetab Rb Thetab Rc Thetac
        3 -1 roll sub dup cos 2 index mul 3 1 roll sin mul %Xb Xc Yc
        dup dup mul 2 index dup mul add 3 -1 roll 3 index mul sub 2 div exch div
        exch 2 div exch 3 -1 roll Rotate
        \pst@number\psyunit div exch \pst@number\psxunit div exch
     end){\Pst@Geonode@i[](0,0){#5}}}%
  %\Pst@InterLL[]{@Middle#2#3}{@Middle#2#3P}{@Middle#2#4}{@Middle#2#4P}{#5}%DR: 22/03/03
  \ifPst@DrawCirABC\pstCircleOA{#5}{#2}\fi
  \ifPst@CodeFig
    \psset{PointSymbol=none, PointName=none, linecolor=\psk@CodeFigColor, linestyle=\psk@CodeFigStyle, nodesep=-1}%
    \expandafter\ifx\csname psteucl@old\endcsname\relax%% NEW SYNTAX 14042005
      \Pst@HomO[HomCoef=.5]{#2}{#3}[@Middle#2#3]%
      \Pst@Rotation[RotAngle=90, CodeFig=false]{@Middle#2#3}{#2}[@Middle#2#3P]%
      \Pst@HomO[HomCoef=.5]{#2}{#4}[@Middle#2#4]%
      \Pst@Rotation[RotAngle=90, CodeFig=false]{@Middle#2#4}{#2}[@Middle#2#4P]%
      \Pst@HomO[HomCoef=.5]{#4}{#3}[@Middle#4#3]%
    \else%% OLD SYNTAX
      \Pst@HomO[HomCoef=.5]{#2}{#3}{@Middle#2#3}%
      \Pst@Rotation[RotAngle=90, CodeFig=false]{@Middle#2#3}{#2}{@Middle#2#3P}%
      \Pst@HomO[HomCoef=.5]{#2}{#4}{@Middle#2#4}%
      \Pst@Rotation[RotAngle=90, CodeFig=false]{@Middle#2#4}{#2}{@Middle#2#4P}%
      \Pst@HomO[HomCoef=.5]{#4}{#3}{@Middle#4#3}%
    \fi
    \ncline{#5}{@Middle#4#3}%
    \ncline{#5}{@Middle#2#3}%
    \ncline{#5}{@Middle#2#4}%
    \psset{linestyle=solid}%
    \pstRightAngle[]{#5}{@Middle#4#3}{#4}%
    \pstRightAngle[]{#5}{@Middle#2#3}{#3}%
    \pstRightAngle[]{#5}{@Middle#2#4}{#2}%
    \Pst@SegmentMark[SegmentSymbol=\psk@SegmentSymbolA]{#4}{@Middle#4#3}%
    \Pst@SegmentMark[SegmentSymbol=\psk@SegmentSymbolA]{@Middle#4#3}{#3}%
    \Pst@SegmentMark[SegmentSymbol=\psk@SegmentSymbolB]{#3}{@Middle#2#3}%
    \Pst@SegmentMark[SegmentSymbol=\psk@SegmentSymbolB]{@Middle#2#3}{#2}%
    \Pst@SegmentMark[SegmentSymbol=\psk@SegmentSymbolC]{#2}{@Middle#2#4}%
    \Pst@SegmentMark[SegmentSymbol=\psk@SegmentSymbolC]{@Middle#2#4}{#4}%
  \fi
  \egroup
}%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                     TRANSLATION
%% #2 #3 -> 2 nodes defining the translation vector
%% #4 -> antecedent
%% #5 -> node name of the image
\expandafter\ifx\csname psteucl@old\endcsname\relax%% NEW SYNTAX %% DR 2005/04/10
\def\pstTranslation{\@ifnextchar[\Pst@Translation{\Pst@Translation[]}}%
\def\Pst@Translation[#1]#2#3{%
  \bgroup%
  \@InitListMng%
  \psset{#1}\def\@VectorOrigin{#2}\def\@VectorEnd{#3}%
  \edef\@@GenCourbe{}%%for accumulating points
  \Pst@Translation@i%
}%
\def\Pst@Translation@i#1{%
  \@List{#1}\edef\@antecedentLst{\@NewList}
  \@ifnextchar[\Pst@Translation@ii{\Pst@Translation@ii[default]}%
}%
\def\Pst@Translation@ii[#1]{%
  \@List{#1}\edef\@imageLst{\@NewList}
  \edef\@antecedent{\expandafter\PstParamListFirst\@antecedentLst,undef/}
  \edef\@image{\expandafter\PstParamListFirst\@imageLst,default/}
  \Pst@Translation@iii%
}%
\def\Pst@Translation@iii{%
  \ifx\@image\@default\def\@image{\@antecedent '}\fi
  \rput(\@VectorOrigin){%
    \rput(!
      tx@EcldDict begin /N@\@VectorEnd\space GetNode
      \ifx\psk@DistCoef\@none
      \else\psk@DistCoef\space mul exch \psk@DistCoef\space mul exch\fi
      /N@\@antecedent\space GetNode end
      3 -1 roll add exch 3 -1 roll add exch
      \pst@number\psyunit div exch \pst@number\psxunit div exch)%
    {\pnode{\@image}}%
    }%
  \xdef\@@GenCourbe{\@@GenCourbe(\@image)}%%for accumulating points
  \ifPst@CodeFig
    \bgroup
    \psset{linecolor=\psk@CodeFigColor, linestyle=\psk@CodeFigStyle}%
    \ncline[arrows=->,nodesep=0]{\@antecedent}{\@image}
    \ifx\psk@TransformLabel\@none
    \else
      \ifx\psk@TransformLabel\@default%
        \ncput*{$\ifx\psk@DistCoef\@none\else\psk@DistCoef\fi\overrightarrow{\@VectorOrigin\@VectorEnd}$}
      \else\ncput{\psk@TransformLabel}\fi
    \fi%
    \egroup%
  \fi%
  \Pst@ManageParamList{\@image}%
  \edef\@antecedentLst{\expandafter\PstParamListLasts\@antecedentLst,undef/}%
  \edef\@imageLst{\expandafter\PstParamListLasts\@imageLst,default/}%
  \edef\@LastValidantecedent{\@antecedent}\def\@LastValidimage{\@image}
  \edef\@antecedent{\expandafter\PstParamListFirst\@antecedentLst,undef/}%
  \edef\@image{\expandafter\PstParamListFirst\@imageLst,default/}
  \ifx\@antecedent\@undef\def\@End{\pst@MngTransformCurve\egroup}
  \else\def\@End{\Pst@Translation@iii}\fi%
  \@End%
}%
\else%% OLD SYNTAX
\def\pstTranslation{\@ifnextchar[\Pst@Translation{\Pst@Translation[]}}%
\def\Pst@Translation[#1]#2#3{%
  \bgroup
  \@InitListMng%
  \psset{#1}\def\@VectorOrigin{#2}\def\@VectorEnd{#3}%
  \edef\@@GenCourbe{}%%for accumulating points
  \Pst@Translation@i-%
}%
\def\Pst@Translation@i-#1#2{%
  \rput(\@VectorOrigin){%
    \rput(!
      tx@EcldDict begin /N@\@VectorEnd\space GetNode
      \ifx\psk@DistCoef\@none
      \else\psk@DistCoef\space mul exch \psk@DistCoef\space mul exch\fi
      /N@#1 GetNode end
      3 -1 roll add exch 3 -1 roll add exch
      \pst@number\psyunit div exch \pst@number\psxunit div exch)%
    {\pnode{#2}}%
    }%
  \xdef\@@GenCourbe{\@@GenCourbe(#2)}%%for accumulating points
  \ifPst@CodeFig%
    \bgroup
    \psset{linecolor=\psk@CodeFigColor, linestyle=\psk@CodeFigStyle, nodesep=0}%
    \ncline[arrows=->]{#1}{#2}
    \ifx\psk@TransformLabel\@none
    \else%
      \ifx\psk@TransformLabel\@default%
      \ncput*{\ifx\psk@DistCoef\@none\else\psk@DistCoef\fi$\overrightarrow{\@VectorOrigin\@VectorEnd}$}
      \else\ncput{\psk@TransformLabel}\fi
    \fi%
    \egroup
  \fi
  \Pst@ManageParamList{#2}%
  \@ifnextchar-{\Pst@Translation@i}{\pst@MngTransformCurve\egroup}%
}%
%%%%%%%%%%%%%%%%%%%%%
\fi% END OLD SYNTAX %% DR 2005/04/10
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                     ROTATION
%% #2 -> centre of rotation
%% #3 -> antecedent
%% #4 -> node name of the image
\expandafter\ifx\csname psteucl@old\endcsname\relax%% NEW SYNTAX %% DR 2005/04/10
\def\pstRotation{\@ifnextchar[\Pst@Rotation{\Pst@Rotation[]}}%
\def\Pst@Rotation[#1]#2{%
  \bgroup
  \@InitListMng%
  \psset{#1}\def\@RotCtr{#2}\edef\@@GenCourbe{}%%for accumulating points
  \Pst@Rotation@i%
}%
\def\Pst@Rotation@i#1{%
  \@List{#1}\edef\@antecedentLst{\@NewList}
  \@ifnextchar[\Pst@Rotation@ii{\Pst@Rotation@ii[default]}%
}%
\def\Pst@Rotation@ii[#1]{%
  \@List{#1}\edef\@imageLst{\@NewList}
  \edef\@antecedent{\expandafter\PstParamListFirst\@antecedentLst,undef/}
  \edef\@image{\expandafter\PstParamListFirst\@imageLst,default/}
  \Pst@Rotation@iii%
}%
\def\Pst@Rotation@iii{%
  \ifx\@image\@default\def\@image{\@antecedent '}\fi
  \rput(\@RotCtr){%
    \rput(!tx@EcldDict begin /N@\@antecedent\space GetNode \psk@RotAngle\space Rotate end
           \pst@number\psyunit div exch \pst@number\psxunit div exch)%
         {\pnode{\@image}}%
    }%% end \rput
  \xdef\@@GenCourbe{\@@GenCourbe(\@image)}%%for accumulating points
  \ifPst@CodeFig%
    \bgroup
    \psset{linecolor=\psk@CodeFigColor, linestyle=\psk@CodeFigStyle}%
    \pstArcOAB[arrows=->]{\@RotCtr}{\@antecedent}{\@image}%
    \ncline{\@RotCtr}{\@antecedent}\ncline{\@RotCtr}{\@image}
    \ifx\psk@TransformLabel\@none\else\pstMarkAngle{\@antecedent}{\@RotCtr}{\@image}{$\psk@TransformLabel$}\fi
    \egroup
  \fi%
  \Pst@ManageParamList{\@image}%
  \edef\@antecedentLst{\expandafter\PstParamListLasts\@antecedentLst,undef/}%
  \edef\@imageLst{\expandafter\PstParamListLasts\@imageLst,default/}%
  \edef\@LastValidantecedent{\@antecedent}\def\@LastValidimage{\@image}
  \edef\@antecedent{\expandafter\PstParamListFirst\@antecedentLst,undef/}%
  \edef\@image{\expandafter\PstParamListFirst\@imageLst,default/}
  \ifx\@antecedent\@undef\def\@End{\pst@MngTransformCurve\egroup}
  \else\def\@End{\Pst@Rotation@iii}\fi%
  \@End%
}%
%%%%%%%%%%%%%%%%%%%%%
\else%% OLD SYNTAX
\def\pstRotation{\@ifnextchar[\Pst@Rotation{\Pst@Rotation[]}}%
\def\Pst@Rotation[#1]#2{%
  \bgroup
  \@InitListMng%
  \psset{#1}\def\@RotCtr{#2}
  \edef\@@GenCourbe{}%%for accumulating points
  \Pst@Rotation@i-%
}%
\def\Pst@Rotation@i-#1#2{%
  \rput(\@RotCtr){%
    \rput(!tx@EcldDict begin /N@#1 GetNode \psk@RotAngle\space Rotate end
           \pst@number\psyunit div exch \pst@number\psxunit div exch)%
         {\pnode{#2}}%
    }%% end \rput
  \xdef\@@GenCourbe{\@@GenCourbe(#2)}%%for accumulating points
  \ifPst@CodeFig%
    \bgroup
    \psset{linecolor=\psk@CodeFigColor, linestyle=\psk@CodeFigStyle}%
    \pstArcOAB[arrows=->]{\@RotCtr}{#1}{#2}%
    \ncline{\@RotCtr}{#1}\ncline{\@RotCtr}{#2}
    \ifx\psk@TransformLabel\@none\else\pstMarkAngle{#1}{\@RotCtr}{#2}{$\psk@TransformLabel$}\fi
    \egroup
  \fi%
  \Pst@ManageParamList{#2}%
  \@ifnextchar-{\Pst@Rotation@i}{\pst@MngTransformCurve\egroup}%
}%
\fi% END OLD SYNTAX %% DR 2005/04/10
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%        Intersection between two lines
%% #2 #3 -> nodes defining the first line
%% #4 #5 -> nodes defining the second line
%% #6 -> node name of the image
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\pstInterLL{\@ifnextchar[\Pst@InterLL{\Pst@InterLL[]}}%
\def\Pst@InterLL[#1]#2#3#4#5#6{%
  \bgroup\psset{#1}%             % Affectation of local parameters
  \pnode(!
    tx@EcldDict begin
      /N@#2 GetNode /N@#3 GetNode /N@#4 GetNode /N@#5 GetNode InterLines
    end
    \pst@number\psyunit div exch \pst@number\psxunit div exch
    2 copy
    /#6.Y exch def /#6.X exch def % save the coors for futher use
    ){#6}%
  \Pst@geonodelabel{#6}%
  \egroup%
}%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%   Intersection between one line and one circle
%% #2 #3 -> nodes defining the first line
%% #4 #5 -> nodes defining the center and a point onto C
%% #6 -> node name of the first point
%% #7 -> label
%% #8 -> node name of the second point
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\pstInterLC{\pst@object{pstInterLC}}
\def\pstInterLC@i#1#2#3#4#5#6{%
  \begingroup
  \pst@killglue
  \use@par
  \rput(#3){%
    \pnode(!
    tx@EcldDict begin
      /N@#1 GetNode /N@#2 GetNode 4 copy EqDr
      \ifx\psk@Radius\@none
        \ifx\psk@Diameter\@none
          /N@#3 GetNode /N@#4 GetNode ABDist
        \else\psk@Diameter 2 div
        \fi
      \else\psk@Radius
      \fi
    InterLineCircle /Glby exch def /Glbx exch def
      \pst@number\psyunit div exch \pst@number\psxunit div exch
    2 copy end
    /#5.Y exch def /#5.X exch def % save the coors for futher use
    ){#5}%
  \rput(!
    tx@EcldDict begin
      Glbx \pst@number\psxunit div Glby \pst@number\psyunit div
    end){\pnode{#6}}
  }%
  \begingroup
  \ifx\psk@PosAngleA\@undef    \else\psset{PosAngle=\psk@PosAngleA}\fi
  \let\psk@PointSymbol\psk@PointSymbolA
  \ifx\psk@PointNameA\@undef   \else\psset{PointName=\psk@PointNameA}\fi
  \Pst@geonodelabel{#5}
  \endgroup
  \ifx\psk@PosAngleB\@undef\else\psset{PosAngle=\psk@PosAngleB}\fi
  \let\psk@PointSymbol\psk@PointSymbolB
  \ifx\psk@PointNameB\@undef\else\psset{PointName=\psk@PointNameB}\fi
  \Pst@geonodelabel{#6}%
  \endgroup
  \ignorespaces
}%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%   Intersection between two circles
%% #2 #3 -> nodes defining the first circle
%% #4 #5 -> nodes defining the second circle
%% #6 -> node name of the first point
%% #7 -> node name of the second point
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\pstInterCC{\@ifnextchar[\Pst@InterCC{\Pst@InterCC[]}}%
\def\Pst@InterCC[#1]#2#3#4#5#6#7{%
  \bgroup\psset{#1}%        % Affectation of local parameters
  \rput(#2){%
    \rput(!
      tx@EcldDict begin
        \ifx\psk@RadiusA\@undef
          \ifx\psk@DiameterA\@undef
            \ifx\psk@Radius\@none
              \ifx\psk@Diameter\@none
                /N@#3 GetNode Pyth
              \else\psk@Diameter 2 div
              \fi
            \else\psk@Radius\space
            \fi
          \else\psk@DiameterA 2 div
          \fi
        \else\psk@RadiusA\space
        \fi
        \ifx\psk@RadiusB\@undef
          \ifx\psk@DiameterB\@undef
            \ifx\psk@Radius\@none
              \ifx\psk@Diameter\@none
                /N@#4 GetNode /N@#5 GetNode ABDist
              \else\psk@Diameter 2 div
              \fi
            \else\psk@Radius\space
            \fi
          \else\psk@DiameterB 2 div
          \fi
        \else\psk@RadiusB\space
        \fi
        /N@#4 GetNode Pyth InterCircles /N@#4 GetNode
        exch Atan dup /xoC exch def Rotate /Glby exch def /Glbx exch def
        xoC Rotate
      end
      \pst@number\psyunit div exch \pst@number\psxunit div exch)
    {\pnode{#6}}%
    \rput(!
      tx@EcldDict begin
        Glbx \pst@number\psxunit div Glby \pst@number\psyunit div
      end)%
    {\pnode{#7}}%
    }%
  \bgroup
%  \ifx\psk@PosAngleA\@undef\else\psset{PosAngle=\psk@PosAngleA}\fi
%  \ifx\psk@PointSymbolA\@undef\else\psset{PointSymbol=\psk@PointSymbolA}\fi
%  \ifx\psk@PointNameA\@undef\else\psset{PointName=\psk@PointNameA}\fi
  \ifx\psk@PosAngleA\@undef\else\ifx\psk@PosAngleA\@none\else\psset{PosAngle=\psk@PosAngleA}\fi\fi
  \ifx\psk@PointSymbolA\@none\let\psk@PointSymbol=\@none\else\let\psk@PointSymbol=\psk@PointSymbolA\fi
  \ifx\psk@PointNameA\@undef\else\ifx\psk@PointNameA\@none\else\psset{PointName=\psk@PointNameA}\fi\fi
  \ifx\psk@PosAngleA\@undef\else\ifx\psk@PosAngle\@none\else\Pst@geonodelabel{#6}\fi\fi
  \egroup
  \bgroup
%  \ifx\psk@PosAngleB\@undef\else\psset{PosAngle=\psk@PosAngleB}\fi
%  \ifx\psk@PointSymbolB\@undef\else\psset{PointSymbol=\psk@PointSymbolB}\fi
%  \ifx\psk@PointNameB\@undef\else\psset{PointName=\psk@PointNameB}\fi
  \ifx\psk@PosAngleB\@undef\else\ifx\psk@PosAngleB\@none\else\psset{PosAngle=\psk@PosAngleB}\fi\fi
  \ifx\psk@PointSymbolB\@none\let\psk@PointSymbol=\@none\else\let\psk@PointSymbol=\psk@PointSymbolB\fi
  \ifx\psk@PointNameB\@undef\else\ifx\psk@PointNameB\@none\else\psset{PointName=\psk@PointNameB}\fi\fi
  \ifx\psk@PosAngleB\@undef\else\ifx\psk@PosAngleB\@none\else\Pst@geonodelabel{#7}\fi\fi
  \egroup
  \psset{linecolor=\psk@CodeFigColor, linestyle=\psk@CodeFigStyle, arcsep=-1}%
  \ifx\psk@CodeFigA\@undef%
    \ifx\psk@CodeFigB\@undef\ifPst@CodeFig\pstArcOAB{#2}{#6}{#7}\fi\fi
  \else%
    \ifPst@CodeFigAarc\pstArcOAB{#2}{#6}{#7}\else\pstArcnOAB{#2}{#6}{#7}\fi%
  \fi
  \ifx\psk@CodeFigB\@undef%
    \ifx\psk@CodeFigA\@undef\ifPst@CodeFig\pstArcOAB{#4}{#6}{#7}\fi\fi
  \else%
    \ifPst@CodeFigBarc\pstArcOAB{#4}{#6}{#7}\else\pstArcnOAB{#4}{#6}{#7}\fi%
  \fi
  \egroup
}%
%%   Intersection between two functions
%% #2 #3 -> f and g (functions)
%% #4 -> approximation of the root
%% #5 -> node name of the first point
\def\pstInterFF{\@ifnextchar[\Pst@InterFF{\Pst@InterFF[]}}%
\def\Pst@InterFF[#1]#2#3#4#5{%
  \bgroup\psset{#1}%             % Affectation of local parameters
%  \rput(!
%  tx@EcldDict begin
%    #4 { #3 } { #2 } NewtonSolving pop
%  end){\pnode{#5}}%
  \pnode(!
    tx@EcldDict begin
    #4
    { \ifPst@algebraic (#3) AlgParser cvx exec \else #3  \fi }
    { \ifPst@algebraic (#2) AlgParser cvx exec \else #2  \fi }
    NewtonSolving pop
    2 copy end
    /#5.Y exch def /#5.X exch def % save the coors for futher use
  ){#5}%
  \Pst@geonodelabel{#5}%
  \egroup%
}
%%   Intersection between a function and a line
%% #2 -> f (function)
%% #3 #4 -> points defining the line
%% #5 -> approximation of the root
%% #6 -> node name of the first point
\def\pstInterFL{\@ifnextchar[\Pst@InterFL{\Pst@InterFL[]}}%
\def\Pst@InterFL[#1]#2#3#4#5#6{%
  \bgroup\psset{#1}%             % Affectation of local parameters
%  \rput(!
%  tx@EcldDict begin
%    #5 { /N@#3 GetNode /N@#4 GetNode EqDr 1 index div
%  \pst@number\psxunit div 3 1 roll div x mul add } { #2 }
%  NewtonSolving pop
%  end){\pnode{#6}}%
  \pnode(!
    tx@EcldDict begin
    #5
    { /N@#3 GetNode /N@#4 GetNode EqDr 1 index div
      \pst@number\psxunit div 3 1 roll div x mul add }
    { \ifPst@algebraic (#2) AlgParser cvx exec \else #2  \fi }
    NewtonSolving pop 2 copy end
    /#5.Y exch def /#5.X exch def % save the coors for futher use
    ){#6}%
  \Pst@geonodelabel{#6}%
  \egroup%
}
%%   Intersection between a function and a circle
%% #1 -> f (function)
%% #2 #3 -> points defining the circle (center and point)
%% #4 -> approximation of the root
%% #5 -> node name of the first point
\def\pstInterFC{\pst@object{pstInterFC}}%
\def\pstInterFC@i#1#2#3#4#5{%
  \begingroup
  \pst@killglue
  \use@par
  \edef\@function{ \ifPst@algebraic (#1) AlgParser cvx exec \else #1 \fi\space }%
  \pnode(!
    tx@EcldDict begin
    #4
    { /N@#2 GetNode 2 copy /N@#3 GetNode ABDist \pst@number\psxunit div
      3 1 roll \pst@number\psyunit div exch \pst@number\psxunit div exch x \@function
       ABDist sub }
    { 0 }
    NewtonSolving pop
    pop dup /x exch def
    \@function
    2 copy end
    /#4.Y exch def /#4.X exch def % save the coors for futher use
    ){#5}%
  \Pst@geonodelabel{#5}%
  \endgroup
  \ignorespaces
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%              ORTHOGONAL PROJECTION
%% #2 #3 -> nodes defining the line where to project
%% #4 -> antecedent
%% #5 -> node name of the image
%% #6 -> label
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\expandafter\ifx\csname psteucl@old\endcsname\relax%% NEW SYNTAX %% DR 2005/04/10
\def\pstProjection{\@ifnextchar[\Pst@Projection{\Pst@Projection[]}}%
\def\Pst@Projection[#1]#2#3{%
  \bgroup%
  \@InitListMng%
  \psset{#1}\def\@FrstPt{#2}\def\@ScdPt{#3}% Affectation of local parameters
  \edef\@@GenCourbe{}%%for accumulating points
  \Pst@Projection@i%
}%
\def\Pst@Projection@i#1{%
  \@List{#1}\edef\@antecedentLst{\@NewList}
  \@ifnextchar[\Pst@Projection@ii{\Pst@Projection@ii[default]}%
}%
\def\Pst@Projection@ii[#1]{%
  \@List{#1}\edef\@imageLst{\@NewList}
  \edef\@antecedent{\expandafter\PstParamListFirst\@antecedentLst,undef/}
  \edef\@image{\expandafter\PstParamListFirst\@imageLst,default/}
  \Pst@Projection@iii%
}%
\def\Pst@Projection@iii{%
  \Pst@Projection@iv{\@antecedent}{\@image}
  %%begin modif alaindelplanque 11/2003
  %% automatic computation of PosAngle
  \ifx\psk@PosAngle\@undef%
    \psset{PosAngle={!tx@EcldDict begin /N@\@image\space GetNode exch /N@\@antecedent\space GetNode end 4 1 roll
                     sub 3 1 roll sub neg exch atan=20}}
  \fi
  %%end modif alaindelplanque 11/2003
  \xdef\@@GenCourbe{\@@GenCourbe(\@image)}%%for accumulating points
  \Pst@ManageParamList{\@image}%
  \ifPst@CodeFig%
    \psset{linecolor=\psk@CodeFigColor, linestyle=\psk@CodeFigStyle}%
    \pstRightAngle[linestyle=solid]{\@ScdPt}{\@image}{\@antecedent}%
    \ncline{\@antecedent}{\@image}%
  \fi%
  \edef\@antecedentLst{\expandafter\PstParamListLasts\@antecedentLst,undef/}%
  \edef\@imageLst{\expandafter\PstParamListLasts\@imageLst,default/}%
  \edef\@LastValidantecedent{\@antecedent}\def\@LastValidimage{\@image}
  \edef\@antecedent{\expandafter\PstParamListFirst\@antecedentLst,undef/}%
  \edef\@image{\expandafter\PstParamListFirst\@imageLst,default/}
  \ifx\@antecedent\@undef\def\@End{\pst@MngTransformCurve\egroup}
  \else\def\@End{\Pst@Projection@iii}\fi%
  \@End%
}%
\def\Pst@Projection@iv#1#2{%
  \ifx\@image\@default\def\@image{\@antecedent '}\fi
  \rput(\@FrstPt){% translation onto #1
    \rput(!tx@EcldDict begin /N@#1 GetNode /N@\@ScdPt\space GetNode Project end
          \pst@number\psyunit div exch \pst@number\psxunit div exch)%
         {\pnode{#2}}%
    }%
}%
%%%%%%%%%%%%%%%%%%%%%
\else%% OLD SYNTAX
\def\pstProjection{\@ifnextchar[\Pst@Projection{\Pst@Projection[]}}%
\def\Pst@Projection[#1]#2#3{%
  \bgroup%
  \@InitListMng%
  \psset{#1}\def\@FrstPt{#2}\def\@ScdPt{#3}% Affectation of local parameters
  \edef\@@GenCourbe{}%%for accumulating points
  \Pst@Projection@i-%
}%
\def\Pst@Projection@i-#1#2{%
  \Pst@Projection@ii{#1}{#2}
  %%begin modif alaindelplanque 11/2003
  %% automatic computation of PosAngle
  \ifx\psk@PosAngle\@undef%
    \psset{PosAngle={!tx@EcldDict begin /N@#2 GetNode exch /N@#1 GetNode end 4 1 roll
                     sub 3 1 roll sub neg exch atan=20}}
  \fi
  %%end modif alaindelplanque 11/2003
  \xdef\@@GenCourbe{\@@GenCourbe(#2)}%%for accumulating points
  \Pst@ManageParamList{#2}%
  \ifPst@CodeFig%
    \psset{linecolor=\psk@CodeFigColor, linestyle=\psk@CodeFigStyle}%
    \pstRightAngle[linestyle=solid]{#1}{#2}{\@ScdPt}%
    \ncline{#1}{#2}%
  \fi%
  \@ifnextchar-{\Pst@Projection@i}{\pst@MngTransformCurve\egroup}%
}%
\def\Pst@Projection@ii#1#2{%
  \rput(\@FrstPt){% translation onto #1
    \rput(!tx@EcldDict begin /N@#1 GetNode /N@\@ScdPt\space GetNode Project end
          \pst@number\psyunit div exch \pst@number\psxunit div exch)%
         {\pnode{#2}}%
    }%
}%
\fi% END OLD SYNTAX %% DR 2005/04/10
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%              ORTHOGONAL SYMMETRY
%% #2 #3 -> nodes defining the symmetrical axis
%% #4 -> antecedent node
%% #5 -> node name of the symmetrical point
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\expandafter\ifx\csname psteucl@old\endcsname\relax%% NEW SYNTAX %% DR 2005/04/10
\def\pstOrtSym{\@ifnextchar[\Pst@OrtSym{\Pst@OrtSym[]}}%
\def\Pst@OrtSym[#1]#2#3{%
  \bgroup%
  \@InitListMng%
  \psset{#1}\def\@FrstPt{#2}\def\@ScdPt{#3}%             % Affectation of local parameters
  \edef\@@GenCourbe{}%%for accumulating points
  \Pst@OrtSym@i%
}
\def\Pst@OrtSym@i#1{
  \@List{#1}\edef\@antecedentLst{\@NewList}
  \@ifnextchar[\Pst@OrtSym@ii{\Pst@OrtSym@ii[default]}%
}%
\def\Pst@OrtSym@ii[#1]{
  \@List{#1}\edef\@imageLst{\@NewList}
  \edef\@antecedent{\expandafter\PstParamListFirst\@antecedentLst,undef/}
  \edef\@image{\expandafter\PstParamListFirst\@imageLst,default/}
  \Pst@OrtSym@iii%
}%
\def\Pst@OrtSym@iii{
  \ifx\@image\@default\def\@image{\@antecedent '}\fi
  \rput(\@FrstPt){% translation onto #1
    \rput(!
      tx@EcldDict begin /N@\@antecedent\space GetNode 2 copy /N@\@ScdPt\space GetNode Project
      /N@\@antecedent\space GetNode ABVect 2 mul 3 -1 roll exch add 3 1 roll 2 mul add exch end
      \pst@number\psyunit div exch \pst@number\psxunit div exch)%
      {\pnode{\@image}}%
    }%
  \ifPst@CodeFig%
    \bgroup
    \Pst@Projection@iv{\@antecedent}{@ProjOrth\@antecedent on\@FrstPt\@ScdPt}
    \psset{linecolor=\psk@CodeFigColor, linestyle=\psk@CodeFigStyle}%
    \pstRightAngle[linestyle=solid]{\@FrstPt}{@ProjOrth\@antecedent on\@FrstPt\@ScdPt}{\@antecedent}%
    \Pst@SegmentMark[]{\@image}{@ProjOrth\@antecedent on\@FrstPt\@ScdPt}%
    \Pst@SegmentMark[]{@ProjOrth\@antecedent on\@FrstPt\@ScdPt}{\@antecedent}%
    \egroup
  \fi%
  \xdef\@@GenCourbe{\@@GenCourbe(\@image)}%%for accumulating points
  \Pst@ManageParamList{\@image}%
  \edef\@antecedentLst{\expandafter\PstParamListLasts\@antecedentLst,undef/}%
  \edef\@imageLst{\expandafter\PstParamListLasts\@imageLst,default/}%
  \edef\@LastValidantecedent{\@antecedent}\def\@LastValidimage{\@image}
  \edef\@antecedent{\expandafter\PstParamListFirst\@antecedentLst,undef/}%
  \edef\@image{\expandafter\PstParamListFirst\@imageLst,default/}
  \ifx\@antecedent\@undef\def\@End{\pst@MngTransformCurve\egroup}
  \else\def\@End{\Pst@OrtSym@iii}\fi%
  \@End%
}%
%%%%%%%%%%%%%%%%%%%%%
\else%% OLD SYNTAX
\def\pstOrtSym{\@ifnextchar[\Pst@OrtSym{\Pst@OrtSym[]}}%
\def\Pst@OrtSym[#1]#2#3{%
  \bgroup%
  \@InitListMng%
  \psset{#1}\def\@FrstPt{#2}\def\@ScdPt{#3}%             % Affectation of local parameters
  \edef\@@GenCourbe{}%%for accumulating points
  \Pst@OrtSym@i-%
}
\def\Pst@OrtSym@i-#1#2{
  \rput(\@FrstPt){% translation onto #1
    \rput(!
      tx@EcldDict begin /N@#1 GetNode 2 copy /N@\@ScdPt\space GetNode Project
      /N@#1 GetNode ABVect 2 mul 3 -1 roll exch add 3 1 roll 2 mul add exch end
      \pst@number\psyunit div exch \pst@number\psxunit div exch)%
      {\pnode{#2}}%
    }%
  \ifPst@CodeFig%
    \bgroup
    \Pst@Projection@ii{#1}{@ProjOrth#1on\@FrstPt\@ScdPt}
    \psset{linecolor=\psk@CodeFigColor, linestyle=\psk@CodeFigStyle}%
    \pstRightAngle[linestyle=solid]{\@FrstPt}{@ProjOrth#1on\@FrstPt\@ScdPt}{#1}%
    \Pst@SegmentMark[]{#2}{@ProjOrth#1on\@FrstPt\@ScdPt}%
    \Pst@SegmentMark[]{@ProjOrth#1on\@FrstPt\@ScdPt}{#1}%
    \egroup
  \fi%
  \xdef\@@GenCourbe{\@@GenCourbe(#2)}%%for accumulating points
  \Pst@ManageParamList{#2}%
  \@ifnextchar-{\Pst@OrtSym@i}{\pst@MngTransformCurve\egroup}%
}%
\fi% END OLD SYNTAX %% DR 2005/04/10
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%              mediator line
%% #2 #3 -> nodes defining the segment
%% #4 -> middle of the segment
%% #5 -> node belonging to the mediator line
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\pstMediatorAB{\@ifnextchar[\Pst@MediatorAB{\Pst@MediatorAB[]}}%
\def\Pst@MediatorAB[#1]#2#3#4#5{%
  \bgroup\psset{#1}%             % Affectation of local parameters
  \bgroup
    \let\PointSymbol=\psk@PointSymbolA
    \ifx\psk@PointNameA\@undef\else\psset{PointName=\psk@PointNameA}\fi
  %\Pst@HomO[HomCoef=.5]{#2}{#3}{#4}
  \Pst@MiddleAB[]{#2}{#3}{#4}
  \egroup
  \bgroup
    \let\PointSymbol=\psk@PointSymbolB
    \ifx\psk@PointNameB\@undef\else\psset{PointName=\psk@PointNameB}\fi
  \expandafter\ifx\csname psteucl@old\endcsname\relax%
    \Pst@Rotation[RotAngle=90, CodeFig=false]{#4}{#3}[#5]%%%DR 26032005
  \else\Pst@Rotation[RotAngle=90, CodeFig=false]{#4}{#3}{#5}\fi%%%DR 14042005
  \egroup
  \ifPst@CodeFig
    \bgroup\psset{linecolor=\psk@CodeFigColor}
    \pstRightAngle[]{#3}{#4}{#5}
    \Pst@SegmentMark[]{#2}{#4}\Pst@SegmentMark[]{#4}{#3}%
    \egroup
  \fi
  \ncline{#4}{#5}
  \egroup
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%              bissectrice
%% #2 #3 #4 -> nodes defining the angle in #3 anti-clockwise
%% #5 -> node belonging to the bissectrice
%% #6 -> label
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\pstBissectBAC{\@ifnextchar[\Pst@BissectBAC{\Pst@BissectBAC[]}}%
\def\Pst@BissectBAC[#1]#2#3#4#5{%
  \bgroup\psset{#1}%             % Affectation of local parameters
  \rput(#3){%
    \rput(!
      tx@EcldDict begin /N@#4 GetNode exch Atan /N@#2 GetNode end
      2 copy 5 2 roll exch Atan 2 copy lt { exch 360 sub exch } if sub
      2 div tx@EcldDict begin Rotate end
      \pst@number\psyunit div exch \pst@number\psxunit div exch)%
      {\pnode{#5}}%
    \Pst@geonodelabel{#5}%
    \ncline{#3}{#5}%
    }%% end \rput
  \egroup%
}%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%              outside bissectrice
%% #2 #3 #4 -> nodes defining the angle in #3 anti-clockwise
%% #5 -> node belonging to the bissectrice
%% #6 -> label
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\pstOutBissectBAC{\@ifnextchar[\Pst@OutBisBAC{\Pst@OutBisBAC[]}}%
\def\Pst@OutBisBAC[#1]#2#3#4#5{%
  \bgroup\psset{#1}%             % Affectation of local parameters
  \rput(#3){%
    \rput(!
      tx@EcldDict begin /N@#4 GetNode exch Atan /N@#2 GetNode end
      2 copy 5 2 roll exch Atan 2 copy lt { exch 360 sub exch } if sub
      2 div 90 add tx@EcldDict begin Rotate end
      \pst@number\psyunit div exch \pst@number\psxunit div exch)%
      {\pnode{#5}}%
    \Pst@geonodelabel{#5}%
    \ncline{#3}{#5}%
    }%% end \rput
  \egroup%
}%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Creation of a point according to a curvilign abscissa
%% #2 -> center of the circle
%% #3 -> point origin of the circle
%% #4 -> point to be placed
\def\pstCurvAbsNode{\@ifnextchar[\Pst@CurvAbsNode{\Pst@CurvAbsNode[]}}%
\def\Pst@CurvAbsNode[#1]#2#3#4#5{%
  \bgroup\psset{#1}%             % Affectation of local parameters
  \Pst@@CurvAbsNode{#2}{#3}{#4}{#5}%
  %%begin modif alaindelplanque 11/2003
  %% \ifx\psk@PointSymbol\@none\else{\Pst@geonodelabel{#4}}\fi%
  \ifx\psk@PointSymbol\@none
  \else
    %% automatic computation of PosAngle
    \ifx\psk@PosAngle\@undef%
      \psset{PosAngle={!tx@EcldDict begin /N@#4 GetNode exch /N@#2 GetNode end 4 1 roll
                        sub 3 1 roll sub neg exch Atan}}
    \fi
    \Pst@geonodelabel{#4}
  \fi%
  %%end modif alaindelplanque 11/2003
  \Pst@geonodelabel{#4}%
  \egroup%
  %% AJOUTER LE MARQUAGE CodeFig
}%
\def\Pst@@CurvAbsNode#1#2#3#4{%
  \rput(#1){%
    \rput(!
      tx@EcldDict begin
        /N@#2 GetNode 2 copy 0 0 ABDist #4 exch div Pi div 180 mul
        \ifPst@CurvAbsNeg neg \fi Rotate
      end
      \pst@number\psyunit div exch \pst@number\psxunit div exch)%
    {\pnode{#3}}%
    }%% end \rput
}%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%        GENERIC CURVES
%% #2 -> Radical name
%% #3 -> initial counter value
%% #4 -> maximal counter value
\def\pstGenericCurve{\@ifnextchar[\Pst@GenericCurve{\Pst@GenericCurve[]}}%
\def\Pst@GenericCurve[#1]#2#3#4{%
  \bgroup\psset{#1}%       % Affectation of local parameters
    \edef\@@GenCourbe{\ifx\psk@GenCurvFirst\@none\else(\psk@GenCurvFirst)\fi}%
    \pst@cnth=#4
    \advance\pst@cnth by -#3%\@GenCurve% del DR
    \advance\pst@cnth by \psk@GenCurvInc%1 modif DR 020225
    \divide\pst@cnth by \psk@GenCurvInc
    \multido{\i@GenCurve=#3+\psk@GenCurvInc}{\pst@cnth}{%
      \xdef\@@GenCourbe{\@@GenCourbe(#2\i@GenCurve)}}
    \edef\@@GenCourbe{%
      \@@GenCourbe%
      \ifx\psk@GenCurvLast\@none\else(\psk@GenCurvLast)\fi}%
    %\psset{showpoints=true}
    \expandafter\pscurve\@@GenCourbe
  \egroup%
}%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%              Parallel line
%% #2 #3 -> nodes defining the line
%% #3 -> antecedent node
%% #4 -> node name of the image
%% #5 -> label
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%              Orthogonal line
%% #2 #3 -> nodes defining the line
%% #3 -> antecedent node
%% #4 -> node name of the image
%% #5 -> label
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Special macros for parameters
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\def\pstTriangleIC{\pst@object{pstTriangleIC}}%  inner circle of a triangle
\def\pstTriangleIC@i#1#2#3{%
  \begingroup
  \psset{PointSymbol=none,PointName=none,linestyle=none,CodeFig=false}
  \pstBissectBAC{#3}{#1}{#2}{IC_BC}
  \pstBissectBAC{#2}{#3}{#1}{IC_AB} 
  \pstInterLL{#3}{IC_AB}{#1}{IC_BC}{IC_O}
  \pstProjection{#1}{#2}{IC_O}[IC_OAB] 
  \endgroup
  \begingroup
  \use@par
  \pstCircleOA{IC_O}{IC_OAB}
  \endgroup
}
%
\def\pstTriangleOC{\pst@object{pstTriangleOC}}%  inner circle of a triangle
\def\pstTriangleOC@i#1#2#3{%
  \begingroup
  \addbefore@par{PointSymbol=none,PointName=none}
  \use@par
  \pstCircleABC{#1}{#2}{#3}{OC_O}
  \endgroup
}
%
%% Distance between two points
\def\pstDistAB#1#2{%
  tx@EcldDict begin /N@#1 GetNode /N@#2 GetNode ABDist end
  \ifx\psk@DistCoef\@none\else
    \psk@DistCoef\space mul
  \fi
}
%% Distance specified with a number
\def\pstDistVal#1{%
 #1 \pst@number\psxunit mul
  \ifx\psk@DistCoef\@none\else
    \psk@DistCoef\space mul
  \fi
}
\def\pstDistCalc#1{%
  \pscalculate{#1} \pst@number\psxunit mul
  \ifx\psk@DistCoef\@none\else
    \psk@DistCoef\space mul
  \fi
}
%% angle defined by three points
\def\pstAngleAOB#1#2#3{%
%  \pstGeonode[PointName=none,PointSymbol=none](#1){temp@1}(#2){temp@2}(#3){temp@3}%
%  \pstAngleAOB@i{temp@1}{temp@2}{temp@3}}
%\def\pstAngleAOB@i#1#2#3{%
  tx@EcldDict begin /N@#2 GetNode /N@#3 GetNode ABVect /N@#2 GetNode /N@#1 GetNode ABVect end
  4 copy exch 4 -1 roll mul
  3 -2 roll mul add
  4 -2 roll mul 4 -2 roll mul sub exch Atan
  \ifx\psk@AngleCoef\@none\else
    \psk@AngleCoef\space mul
  \fi
}
%
\def\psGetDistanceAB{\pst@object{psGetDistanceAB}}%   Thmoas S\"{o}ll 20140512
\def\psGetDistanceAB@i(#1)(#2)#3{%
\begingroup%
\pst@killglue
\use@par
\pst@getcoor{#1}\pst@tempA
\pst@getcoor{#2}\pst@tempB
\pnode(!
  15 dict begin
  /dec \psk@decimals\space def
  \psk@PSfont findfont \psk@fontscale scalefont setfont
  /laenge {10 dec exp mul round 10 dec exp div 15 string cvs stringwidth } def
  /Wert { dec -1 le { /dec 15 def } if 10 dec exp mul round 10 dec exp div dec 0 eq {cvi 15 string cvs} {15 string cvs } ifelse
          \ifPst@comma dot2comma \fi show } def
  \pst@tempA \tx@UserCoor /y1 ED /x1 ED
  \pst@tempB \tx@UserCoor /y2 ED /x2 ED
  \pst@tempA /y3 ED /x3 ED
  \pst@tempB /y4 ED /x4 ED
  x3 x4 sub y3 y4 sub Pyth laenge /dx ED
  x3 x4 add 2 div dx 2 div sub \psk@xShift\space add y3 y4 add 2 div \psk@yShift\space add
  moveto %
  x1 x2 sub y1 y2 sub Pyth Wert
  x1 x2 add 2 div y1 y2 add 2 div
  end ){#3}
\endgroup
\ignorespaces
}
%
\define@boolkey[psset]{pst-eucl}[Pst@]{AngleValue}[false]{}
\define@boolkey[psset]{pst-eucl}[Pst@]{AngleArc}[true]{}
\define@boolkey[psset]{pst-eucl}[Pst@]{ShowWedge}[true]{}
\define@key[psset]{pst-eucl}{ArcColor}{\def\psk@ArcColor{#1}}%
\define@key[psset]{pst-eucl}{ArcLinestyle}{\def\psk@ArcLinestyle{#1}}%
\define@key[psset]{pst-eucl}{ArcLinewidth}{\def\psk@ArcLinewidth{#1}}%
\define@key[psset]{pst-eucl}{WedgeColor}{\def\psk@WedgeColor{#1}}%
\define@key[psset]{pst-eucl}{WedgeFillstyle}{\def\psk@WedgeFillstyle{#1}}%
\define@key[psset]{pst-eucl}{WedgeOpacity}{\def\psk@WedgeOpacity{#1}}%
\psset[pst-eucl]{ArcColor=black,WedgeColor=blue,WedgeOpacity=0.2,AngleValue=false,
                  AngleArc,ShowWedge,ArcLinestyle=solid,ArcLinewidth=0.8pt,WedgeFillstyle=solid}

\def\psGetAngleABC{\pst@object{psGetAngleABC}}%   Thmoas S\"{o}ll 20151018
\def\psGetAngleABC@i(#1)(#2)(#3)#4{%
  \begingroup
  \use@par
  \pst@killglue
  \pst@getcoor{#1}\pst@tempA
  \pst@getcoor{#2}\pst@tempB
  \pst@getcoor{#3}\pst@tempC
  \pst@Verb{
    \pst@tempA \tx@UserCoor /y1 ED /x1 ED
    \pst@tempB \tx@UserCoor /y2 ED /x2 ED
    \pst@tempC \tx@UserCoor /y3 ED /x3 ED
    y1 y2 sub x1 x2 sub Atan neg /delta1 ED
    y3 y2 sub x3 x2 sub Atan neg /delta2 ED
    delta1 delta2 le {180 delta2 delta1 add 2 div neg add /WiM ED} {delta2 delta1 add 2 div neg /WiM ED} ifelse
  }
  \ifPst@ShowWedge
    \pswedge[fillstyle=\psk@WedgeFillstyle,fillcolor=\psk@WedgeColor,opacity=\psk@WedgeOpacity](#2){\psk@MarkAngleRadius}{! delta1}{! delta2}%
  \fi
  \ifPst@AngleArc
    \psarc[linestyle=\psk@ArcLinestyle,linewidth=\psk@ArcLinewidth,linecolor=\psk@ArcColor](#2){\psk@MarkAngleRadius}{! delta1}{! delta2}%
  \fi
  \pnode(! %
    /dec \psk@decimals\space def
    \psk@PSfont findfont \psk@fontscale scalefont setfont \pst@usecolor\pslinecolor 
    \ifpst@psfonts
      /s1 { /Symbol findfont \psk@fontscale\space scalefont setfont } bind def
    \else
      /s1 { /StandardSymL findfont \psk@fontscale\space scalefont setfont } bind def
    \fi
    /laenge {10 dec exp mul round 10 dec exp div 15 string cvs stringwidth } def
    /WertZeigen { dec -1 le { /dec 15 def } if 10 dec exp mul round 10 dec exp div dec 0 eq  {cvi 15 string cvs} {15 string cvs } ifelse
    \ifPst@comma dot2comma \fi show s1 (\string\260) show} def
    \pst@tempA \tx@UserCoor /y1 ED /x1 ED
    \pst@tempB \tx@UserCoor /y2 ED /x2 ED
    \pst@tempC \tx@UserCoor /y3 ED /x3 ED
    y1 y2 sub x1 x2 sub Atan neg /delta1 ED
    y3 y2 sub x3 x2 sub Atan neg /delta2 ED
    delta1 delta2 le {360 delta2 delta1 sub abs sub /WiWert ED} {delta2 delta1 sub abs /WiWert ED} ifelse
    delta1 delta2 le {180 delta2 delta1 add 2 div neg add /WiM ED} {delta2 delta1 add 2 div neg /WiM ED} ifelse
    \psk@MarkAngleRadius\space delta2 delta1 add 2 div PtoC \pst@tempB exch pop add /ym1 ED \pst@tempB pop add /xm1 ED
    xm1 \psk@MarkAngleRadius\space WiM cos mul \pst@number\psxunit mul add \psk@xShift\space add ym1
    \psk@MarkAngleRadius\space WiM sin mul \pst@number\psxunit mul add \psk@yShift\space add moveto %
    \ifPst@AngleValue WiWert WertZeigen \fi
    x2 0.8 WiM cos mul add y2 0.8 WiM sin mul add){#2-M}%
  \uput{\psk@LabelSep}[! WiM]{0}(#2){#4}%
  \endgroup
  \ignorespaces
}
%
\catcode`\@=\PstAtCode\relax
%
\endinput
%% END: pst-euclide.tex
%
