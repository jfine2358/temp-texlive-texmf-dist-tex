%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++%
%                                                                          %
% This is file 'ltxtools-base.sty', version 0.0.1, December 2011.          %
%                                                                          %
% This package and accompanying files may be distributed and/or            %
% modified under the conditions of the LaTeX Project Public License,       %
% either version 1.3 of this license or any later version. The latest      %
% version of this license is in http://www.latex-project.org/lppl.txt      %
% and version 1.3 or later is part of all distributions of LaTeX           %
% version 2005/12/01 or later.                                             %
%                                                                          %
% The LPPL maintenance status of this software is 'author-maintained'.     %
%                                                                          %
% This software is provided 'as it is', without warranty of any kind,      %
% either expressed or implied, including, but not limited to, the          %
% implied warranties of merchantability and fitness for a particular       %
% purpose.                                                                 %
%                                                                          %
% Copyright (c) 2011 Ahmed Musa (amusa22@gmail.com).                       %
%                                                                          %
%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++%

\@ifpackageloaded{catoptions}{%
  \@ifpackagelater{catoptions}{2011/12/10}{}{%
    \@latex@error{Loaded version of catoptions package is
      not current}\@ehc
  }%
}{%
  \RequirePackage{catoptions}[2011/12/10]%
}
\UseNormalCatcodes
\StyleFilePurpose{The base/core of ltxtools packages (AM)}
\StyleFileRCSInfo
$Id: ltxtools-base.sty,v 0.0.1 2011/12/12 09:00:00 Ahmed Musa Exp $
\ProvidesPackage{ltxtools-base}[\StyleFileInfo]
\NeedsTeXFormat{LaTeX2e}[2011/06/27]
\ifdefTF\LTS@err{}{%
  \SetStyleFileMessages[LTS@]{info}{warn}{err}%
}
\ifdefTF\LTS@verbosewarn{}{%
  \robust@def*\LTS@verbosewarn#1{\ifLTS@verbose\LTS@warn{#1}\fi}%
  \robust@def*\LTS@verboseinfo#1{\ifLTS@verbose\LTS@info{#1}\fi}%
}
\catcode`\&=\thr@@
\loadifnotloaded{ltxkeys}[2011/12/12]
\cptnewvariables{if}[LTS@]{st,pl,cl,rt,pm,lt,verbose}[false]
\cptnewvariables{dimen}[LTS@]{dima,dimb}
\def\@empty{}
\new@def\LTS@car#1#2\car@nil{#1}
\new@def\LTS@cartwo#1#2#3\car@nil{#1#2}
\new@def\LTS@cartworev#1#2#3\car@nil{#2#1}
\new@def\LTS@cdr#1#2\cdr@nil{#2}
\new@def\LTS@cdrtwo#1#2#3\cdr@nil{#3}
\new@def\LTS@carcube#1#2#3#4\car@nil{#1#2#3}
\newletcs\LTS@nil\relax
\new@def*\LTS@nnil{\LTS@nil}
\long\def\@firstofone#1{#1}
\long\def\@firstoftwo#1#2{#1}
\long\def\@secondoftwo#1#2{#2}
\long\def\@firstofthree#1#2#3{#1}
\long\def\@secondofthree#1#2#3{#2}
\long\def\@thirdofthree#1#2#3{#3}
\long\def\@gobbleone#1{}
\long\def\@gobbletwo#1#2{}
\long\def\@gobblethree#1#2#3{}
\long\def\@gobblefour#1#2#3#4{}
\letcsntocs{LTS@0of1}\@gobbleone
\letcsntocs{LTS@1of1}\@firstofone
\letcsntocs{LTS@1of2}\@firstoftwo
\letcsntocs{LTS@2of2}\@secondoftwo
\newletcs\ltsfi\fi
\newletcs\ltselse\else
\new@def\ltsafterfi#1\ltsfi{\fi#1}
\new@def\ltsaftertest@i#1\ltselse#2\ltsfi{\fi#1}
\new@def\ltsaftertest@ii#1\ltselse#2\ltsfi{\fi#2}
\new@def\ltsafterfifi@i#1\ltsfi#2\ltsfi{\fi\fi#1}
\new@def\ltsafterfifi@ii#1\ltsfi#2\ltsfi{\fi\fi#2}
\robust@def*\csnaftergroup{\aftercsname\aftergroup}
\robust@def*\csnendgroup{\aftercsname\endgroup}
\robust@def\iftokennilTF#1{%
  \edef\reserved@a{\unexpanded{#1}}%
  \ifx\reserved@a\@nnil
  \expandafter\iofii\else\expandafter\iiofii\fi
}
\robust@def*\ifsentinelTF#1{%
  \edef\reserved@a{\unexpanded{#1}}%
  \ifx\reserved@a\currsentinel
  \expandafter\iofii\else\expandafter\iiofii\fi
}
\robust@def*\LTS@detokenize@trimspaces#1{%
  \expandafter\cpttrimspaces\expandafter{\detokenize{#1}}%
}
\newletcs\ltsdetoktrim\LTS@detokenize@trimspaces
\robust@def*\usecsrelax#1{\ifdefTF#1{#1\let#1\relax}{}}
\robust@def*\usecsnrelax#1{\ifcsndefTF{#1}{#1\letcsntocs{#1}\relax}{}}
\new@def*\realmeaning#1{%
  \ifsingletokenTF{#1}{%
    \ifdefTF{#1}{\expandafter\strip@prefix\meaning#1}{undefined}%
  }{%
    '\ltsdetoktrim{#1}' isn't one token%
  }%
}
\robust@def*\sanitizecs#1{\edef#1{\realmeaning#1}}
\new@edef*\LTS@hashchar{\string#}
% Eg, \toks@\expandafter\expandafter
%   \expandafter{\ltssupergobble 3ab11cd}:
\newcommand*\ltssupergobble[1]{%
  \romannumeral-`\q\expandafter\@gobble\romannumeral-`\q
  \expandafter\LTS@supergobble
  \romannumeral\the\numexpr#1000{m\endcsname}%
}
\newcommand*\LTS@supergobble[1]{%
  \csname LTS@superg@bble#1\LTS@supergobble
}
\newcommand*\LTS@superg@bblem[1]{\endcsname}

\new@def*\newcomment{%
  \begingroup
  \def\comment@envir{newcomment}%
  \def\do##1{\catcode`##1=12\relax}%
  \dospecials
  \endlinechar`\^^M\catcode`\^^M=12\relax
  \LTS@commentloop
}
\new@def*\LTS@commentend{%
  \ifx\@currenvir\comment@envir
    \let\endnewcomment\relax
    \def\next{\endgroup\end{newcomment}}%
  \else
    \let\next\endgroup
  \fi
  \next
}
\begingroup
\catcode`\^^M=12 %
\endlinechar\m@one%
\robust@gdef*\LTS@commentloop#1^^M{%
  \def\comment@stuff{#1}%
  \ifx\comment@stuff\endnewcomment
    \let\next\LTS@commentend
  \else
    \ifx\comment@stuff\end@newcomment
      \let\next\LTS@commentend
    \else
      \ifx\comment@stuff\end@comment
        \def\next{\@latex@error
          {Bad end for \string\newcomment}\@ehc}%
      \else
        \let\next\LTS@commentloop
      \fi
    \fi
  \fi
  \next
}
\endgroup
\begingroup
\catcode`\{=12
\catcode`\}=12
\catcode`\!=0
\catcode`\[=1
\catcode`\]=2
\catcode`\\=12
!gdef!end@newcomm@nt[\endnewcomment]
!gdef!end@newcomment[\end{newcomment}]
!gdef!end@comment[\end{comment}]
!endgroup

% \advancenr <nr> <optional 'by'> <no> <spr>
% <nr> can be \chardef'd, \countdef'd, or a macro.
% <spr> = space or \relax if 'no' is a literal number.
% Eg, \chardef\elt=1
%     \advancenr\elt by 12 %
% This isn't meant for dimensions.
\robust@def*\advancenr#1{%
  \ifcounterTF{#1}\advance\LTS@advancenr@a#1%
}
\robust@def*\LTS@advancenr@a#1#2{%
  \begingroup
  \toks@{}\@tempcnta\z@pt
  \def\LTS@advancenr@b##1{%
    \ifcondTF\if##1y\fi{%
      \LTS@advancenr@c
    }{%
      \LTS@err{'b##1' not a number or 'by'}\@ehc
    }%
  }%
  \def\LTS@advancenr@c{%
    \futurelet\@let@token\LTS@advancenr@d
  }%
  \def\LTS@advancenr@d{%
    \ifcondTF\ifx\@let@token\@sptoken\fi{%
      \LTS@advancenr@e
    }{%
      \ifcondTF\ifx\@let@token\relax\fi{%
        \LTS@advancenr@e
      }{%
        \LTS@advancenr@f
      }%
    }%
  }%
  \def\LTS@advancenr@e{%
    \ifnumcmpTF\@tempcnta=\z@pt{%
      \LTS@err{No number after 'by'}\@ehc
    }{%
      \LTS@advancenr@g{0}%
    }%
  }%
  \def\LTS@advancenr@f##1{%
    \advance\@tempcnta\@ne
    \ifinsetTF{##1}{0123456789}{%
      \toks@\expandafter{\the\toks@##1}%
      \LTS@advancenr@c
    }{%
      \LTS@advancenr@g{##1}%
    }%
  }%
  \def\LTS@advancenr@g##1{%
    \edef#1{\the\numexpr\ifdefTF#1{#1+}{}\the\toks@+##1}%
    \postgroupdef#1\endgroup
  }%
  \ifcondTF\if#2b\fi{%
    \LTS@advancenr@b
  }{%
    \LTS@advancenr@f{#2}%
  }%
}
\ltxkeys@definekeys*[LTS]{multido}[ltsmd@]{%
  counter=\nr;
  start=0;
  step=1;
  for=1;
  repeat=1/\setaliaskey{for};
}
% Eg,
% \ltsmultido[counter=\ncolr,start=1,step=1,for=2]{%
%   \csn@edef{x@\romannumeral\ncolr}{\number\ncolr}}
\robust@def*\ltsmultido{\cpt@teststopt\LTS@multido{}}
\robust@def*\LTS@multido[#1]#2#{%
  \iflacus#2\dolacus
    \expandafter\cptgobbletorelax
  \fi
  \ifboolTF{cpt@st}{%
    \ltxkeys@launchkeys[LTS]{multido}{#1}%
  }{%
    \cptexpanded{\ltxkeys@launchkeys[LTS]{multido}{\expandcsonce{#1}}}%
  }%
  \ifnum\ltsmd@for=\z@pt
    \expandafter\cptgobbletorelax
  \fi
  \expandafter\ifescapedTF\expandafter{\ltsmd@counter}{}{%
    \LTS@err{\noexpand\ltsmultido counter must be escaped}\@ehc
  }%
  \expandafter\ifcounterTF\expandafter{\ltsmd@counter}{%
    \let\ltsmd@sw\cptswtrue
    \ltsmd@counter\ltsmd@start\relax
  }{%
    \let\ltsmd@sw\cptswfalse
    \expandafter\edef\ltsmd@counter{\number\ltsmd@start}%
  }%
  \cptloop
    #2\relax
    \if\ltsmd@sw
      \advance\ltsmd@counter\ltsmd@step\relax
    \else
      \expandafter\edef\ltsmd@counter
        {\the\numexpr\ltsmd@counter+\ltsmd@step}%
    \fi
    \ifnum\ltsmd@counter>\ltsmd@for\relax\else
  \cptrepeat
  \cpt@relax
}

\robust@def*\ltssetlength#1#2{%
  \@defaultunits#1=\dimexpr#2\unitlength\relax\@nnil
}
\robust@def*\ltsmultiput(#1,#2){%
  \ltssetlength\@xdim{#1}%
  \ltssetlength\@ydim{#2}%
  \cpt@testopt\LTS@multiput{[0,0]}%
}
\robust@def\LTS@multiput[#1,#2]#3#{\LTS@m@ltiput[#1,#2]{#3}}
\robust@def\LTS@m@ltiput[#1,#2]#3#4{%
  \@killglue\noindent
  \begingroup
  \@multicnt#3\relax
  \ltssetlength\LTS@dima{#1}%
  \ltssetlength\LTS@dimb{#2}%
  \cptwhilenum\@multicnt>\z@pt\do{%
    \raise\@ydim\hb@xt@\z@pt{\kern\@xdim #4\hss}%
    \advance\@multicnt\m@one
    \advance\@xdim\LTS@dima
    \advance\@ydim\LTS@dimb
  }%
  \endgroup
  \ignorespaces
}
% Call \ltssetupstrcmp to define \ifstrcmpTF if \pdfstrcmp or
% \pdf@strcmp didn't exist:
\new@def*\ltssetupstrcmp{%
  \let\ltssetupstrcmp\relax
  \long\def\LTS@str@car##1##2\LTS@str@carnil{##1}%
  \newcommand\LTS@ifstrcmp@a[3]{%
    \expandafter\cptswapbracefirst\expandafter{%
      \LTS@str@car##2\LTS@str@carnil
    }{%
      \expandafter##1\expandafter{\LTS@str@car##3\LTS@str@carnil}%
    }%
  }%
  \newcommand\LTS@ifstrcmp@b[3]{%
    \expandafter\cptswapbracefirst\expandafter{##1##2}%
    {\expandafter\expandafter\expandafter\@gobble
    \expandafter\ifstrcmpTF\expandafter{##1##3}}%
  }%
  \newcommand\ifstrcmpTF[4]{%
    \romannumeral0%
    \ifnullTF{##1}{%
      \ifnullTF{##2}{ ##3}{ ##4}%
    }{%
      \ifnullTF{##2}{ ##4}{%
        \ifbracedTF{##1}{%
          \ifbracedTF{##2}{%
            \LTS@ifstrcmp@a\ifstrcmpTF{##1}{##2}{%
              \LTS@ifstrcmp@b\@gobble{##1}{##2}{##3}{##4}%
            }{ ##4}%
          }{ ##4}%
        }{%
          \ifbracedTF{##2}{ ##4}{%
            \ifleadspaceTF{##1}{%
              \ifleadspaceTF{##2}{%
                \LTS@ifstrcmp@b\@gobblespace{##1}{##2}{##3}{##4}%
              }{ ##4}%
            }{%
              \ifleadspaceTF{##2}{ ##4}{%
                \LTS@ifstrcmp@a\ifxTF{##1}{##2}{%
                  \LTS@ifstrcmp@b\@gobble{##1}{##2}{##3}{##4}%
                }{ ##4}%
              }%
            }%
          }%
        }%
      }%
    }%
  }%
}
% \ltspushcmds<idcmd>{<cmda>,<cmdb>,...}<counter>
% \ltspopcmds<idcmd>
% Eg, \ltspushcmds\x{\y,\z}\cnta (down)
%     \ltspushcmds\x{\y,\z}\cnta (down)
%     \ltspopcmds\x (up)
%     \ltspopcmds\x (up)
\robust@def*\ltspushcmds#1#2#3{\LTS@ppcmds\m@one#1{#2}#3}
\robust@def*\ltspopcmds#1{\LTS@ppcmds\@ne#1\relax\relax}
\newcommand*\LTS@ppcmds[4]{%
  \ifcondTF\ifnum#1=1\fi{%
    \cptexpanded{%
      \def\noexpand\reserved@a####1####{%
        ####1\gdef\noexpandcsn{\cptremovescape#2@stack}%
      }%
      \noexpand\reserved@a\expandcsnonce{\cptremovescape#2@stack}%
    }%
  }{%
    \global\advance#4\@ne
    \begintoksgroup
    \toks1{}%
    \def\LTS@tempa##1{\noexpandcsn{\cptremovescape##1@\romannumeral#4}}%
    \cptfor#3\dofor{%
      \cptexpanded{%
        \toks@{\the\toks@\let\LTS@tempa{##1}\noexpand##1}%
        \toks1{\the\toks1\let\noexpand##1\LTS@tempa{##1}%
          \let\LTS@tempa{##1}\noexpand\LTS@undefined}%
      }%
    }%
    \csn@xdef{\cptremovescape#2@stack}{%
      \the\toks1\global\advance#4\m@one
      \ifcsndefTF{\cptremovescape#2@stack}{%
        {\expandcsnonce{\cptremovescape#2@stack}}%
      }{{}}%
    }%
    \endtoksgroup
  }%
}
\def\ltsmakeallother{%
  \begintoksgroup
  \@tempcnta=0
  \loop
    \toks0\expandafter{\the\toks\expandafter
      0\expandafter\catcode\number\@tempcnta=12 %
    }%
    \advance\@tempcnta 1
    \ifnum\@tempcnta<256
  \repeat
  \endtoksgroup
}
\cptnewvariables{read}[LTS@]{infile}
\cptnewvariables{write}[LTS@]{outfile}
% File transfer:
% #1: receiving filename
\new@def*\ltscopytoendcopy#1{%
  \IfFileExists{#1}{%
    \LTS@err{File '#1' already exists}\@ehc
  }{}%
  \immediate\openout\LTS@outfile=#1 %
  \begingroup
  \@tempcnta\z@pt
  \edef\endcopy{\@backslashchar endcopy}%
  \LTS@copytoend@setup\LTS@copytoend@do
}
\def\LTS@copytoend@setup{%
  \def\do##1{\catcode`##1=12}%
  \dospecials
  \catcode`\|=12
  \obeylines%
}
\def\LTS@copytoend@removespace{%
  \expandafter\futurelet\expandafter\next
  \expandafter\LTS@copytoend@ifspace\string
}
\def\LTS@copytoend@ifspace{%
  \ifx\next\@sptoken\expandafter\LTS@copytoend@gobblespace
    \else\expandafter\LTS@copytofile\fi
}
\newcsndef*{LTS@copytoend@gobblespace} {\LTS@copytofile}
\robust@def*\LTS@copytofile#1\LTS@nil{%
  \immediate\write\LTS@outfile{#1}%
}

\begingroup
\obeylines%
% User: don't reposition left brace or put comment
% sign at end of next line:
\gdef\LTS@copytoend@do#1
  {\def\next{#1}%
    \ifx\next\endcopy%
      \let\next=\endgroup%
    \else%
      \ifnum\@tempcnta=\z@pt%
        \LTS@copytoend@removespace#1\LTS@nil%
      \else%
        \LTS@copytofile#1\LTS@nil%
      \fi%
      \let\next=\LTS@copytoend@do%
    \fi%
    \@tempcnta\@ne%
    \next%
}%
\gdef\ltstransferfiles#1#2{%
  \begingroup%
  \let\do\@makeother%
  \dospecials%
  \catcode`\|=12 %
  \obeylines %
  \def^^M{}%
  \IfFileExists{#1}{%
    \IfFileExists{#2}{%
      \LTS@err{File '#2' already exists}\@ehc
    }{}%
  }{%
    \LTS@err{File '#1' doesn't exist}\@ehc
  }%
  \immediate\openin\LTS@infile=#1 %
  \immediate\openout\LTS@outfile=#2 %
  \loop%
    \read\LTS@infile to\data%
    \ifeof\LTS@infile%
      \@tempswafalse%
    \else
      \immediate\write\LTS@outfile{\data}%
      \@tempswatrue%
    \fi%
    \if@tempswa%
  \repeat%
  \closein\LTS@infile%
  \immediate\closeout\LTS@outfile%
  \endgroup%
}%
\endgroup

\robust@def*\preservebracedefQ#1#2{%
  \def\preserve@prefix{#1}%
  \def\preserve@delimiter{#2}%
}
\preservebracedefQ\relax\@nil
\robust@def*\preservebracedef#1{%
  \LTS@preservebrace@setup\reserved@a#1.%
}
\robust@def*\PreserveBraceDef#1#2{%
  \LTS@preservebrace@setup
  \long\edef\preserve@after{\unexpanded{#1}}%
  \afterassignment\preserve@after
  \reserved@a#2.%
}
\robust@def*\LTS@preservebrace@setup{%
  \cptexpandsecondonce{\def\reserved@a##1##2}%
  \preserve@delimiter{%
    \preserve@prefix\edef##1{%
      \unexpanded\expandafter{\cpt@removetodot##2}%
    }%
  }%
}
% */' -> don't define, otherwise attempt to define:
\robust@def*\ltsmaybedef{\LTS@teststpm\LTS@maybedef}
\robust@def*\LTS@maybedef#1{%
  \ifboolTF{cpt@st}\@firstoftwo{%
    \ifboolTF{cpt@pm}\iofii\iiofii
  }{%
    \@gobble
  }{%
    \new@def#1%
  }%
}
% Get the default optional argument of a LaTeX command:
\robust@def*\getdefaultoptarg#1{%
  \begingroup
  \edef\LTS@tempa##1{%
    \def##1####1\cptoxdetok{\@backslashchar#1}####2&%
  }%
  \LTS@tempa\LTS@tempa{%
    \ifblankTF{##2}{%
      \endgroup\def\@optarg{}%
    }{%
      \xifinsetTF{\cptoxdetok{\@backslashchar#1}}{##2}{%
        \edef\LTS@tempa####1{%
          \def####1########1\cptoxdetok{\@backslashchar#1}&%
        }%
        \LTS@tempa\LTS@tempa{\endgroup
          \def\@optarg{####1}%
          \cptscantokens\@optarg
        }%
        \LTS@tempa##2&%
      }{%
        \endgroup\def\@optarg{}%
      }%
    }%
  }%
  \edef\LTS@tempb##1{##1\cptoxdetok{\@backslashchar#1}&}%
  \LTS@tempb{\expandafter\LTS@tempa\meaning#1}%
}
% Eg, \edef\x{\ltsifcase{4}{1{X}2{Y}3{Z}}[No match]}
% #3 is not optional because of the need for expandability,
% and we don't want to use expandable \@testopt (unlike
% in \cptifstreqcase of catoptions package). If #3 is nil, then
% submit it as '[]'.
\new@def*\ltsifcase#1#2[#3]{%
  \LTS@ifcase{#1}#2{#1}{#3}\cpt@nnil
}
\new@def*\LTS@ifcase#1#2#3{%
  \ifstrcmpTF{#1}{#2}{%
    #3\cpt@removetonnil
  }{%
    \LTS@ifcase{#1}%
  }%
}
% Eg, \ltsifincase[,](\def\x{No match})
%     {4}{{a,1,b}{\def\x{X}}{c,2,d}{\def\x{Y}}}
\robust@def*\ltsifincase{\cpt@testopt\LTS@ifincase,}
\robust@def*\LTS@ifincase[#1]{\cpt@testpnopt{\LTS@ifinc@se{#1}}{}}
\robust@def*\LTS@ifinc@se#1(#2)#3#4{%
  \begintoksgroup
  \def\LTS@tempa##1##2{%
    \xifinsetTF{#1#3#1}{#1##1#1}{%
      \toks@{##2}\cpt@removetonnil
    }{%
      \LTS@tempa
    }%
  }%
  \LTS@tempa#4{#3}{#2}\cpt@nnil
  \endtoksgroup
}
\new@def\ltstrimsuffix#1#2{%
  \begingroup
  \ifblankTF{#2}{%
    \LTS@err{Invalid blank suffix for \string\ltstrimsuffix}\@ehc
  }{%
    \ltsifmacroTF{#1}{}{\cpt@notcserr{#1}}%
  }%
  \defpass\LTS@tempa{%
    \xifinsetFT{\detokenize{#2}&}{\cptoxdetok{#1}&}{}{%
      \def\reserved@a####1#2{%
        \edef#1{\unexpanded{####1}}%
        \LTS@tempa
      }%
      \expandafter\reserved@a#1%
    }%
  }%
  \postgroupdef#1\endgroup
}
\new@def\ltstrimprefix#1#2{%
  \begingroup
  \ifblankTF{#2}{%
    \LTS@err{Invalid blank prefix for \string\ltstrimprefix}\@ehc
  }{%
    \ltsifmacroTF{#1}{}{\cpt@notcserr{#1}}%
  }%
  \defpass\LTS@tempa{%
    \xifinsetFT{&\detokenize{#2}}{&\cptoxdetok{#1}}{}{%
      \def\reserved@a#2####1&{%
        \edef#1{\unexpanded{####1}}%
        \LTS@tempa
      }%
      \expandafter\reserved@a#1&%
    }%
  }%
  \postgroupdef#1\endgroup
}
% If one of the listed files is already loaded, do #2:
\robust@def*\ifoneloadedTF#1#2{%
  \begingroup
  \cpt@choicefdfalse
  \gdef\ltspkgcls{}%
  \cptdocommalist{#1}{%
    \ifcsndefTF{ver@##1.sty}{%
      \loopbreak\gdef\ltspkgcls{##1}%
    }{}%
  }%
  \expandafter\endgroup
  \ifcpt@choicefd\ltsafterfi#2\ltsfi
}
\robust@def*\LTS@split@at#1#2{%
  \def\reserved@a##1#1##2\LTS@nil{%
    \def\mpt{#1}\def\lpt{##1}\def\rpt{##2}%
  }%
  \expandafter\reserved@a#2\LTS@nil
}
% \ifx ... \LTS@texdie{I am exiting now}\stop\fi
\robust@def\LTS@texdie#1#2\fi{\fi\immediate\write16{#1}\batchmode#2}
\robust@def*\LTS@emergencystop{%
  \immediate\write\sixt@@n{OK, I'm exiting now.}%
  \interactionmode\z@pt\stop
}
% \let assignment, including subsidiaries of commands
% with optional arguments:
\robust@def*\ltsfulllet#1#2{%
  \def\reserved@e##1##2{%
    \LTS@stfalse\LTS@cltrue\LTS@ifonetoken{##1}{}{##2}%
  }%
  \reserved@e{#1}{%
    \LTS@err{Multiple or blank arguments '\detokenize{#1}'}\@ehc
  }%
  \reserved@e{#2}{%
    \LTS@err{Multiple or blank arguments '\detokenize{#2}'}\@ehc
    \@gobble
  }%
  \let#1=#2%
  \ifdefFT#2{}{%
    \ifcsndefTF{\string#2}{%
      \letcsntocsn{\string#1}{\string#2}%
    }{%
      \ifcsndefFT{\cptgobblescape#2\@space}{}{%
        \letcsntocsn{\cptgobblescape#1\@space}
          {\cptgobblescape#2\@space}%
        \ifcsndefFT{\string#2\@space}{}{%
          \letcsntocsn{\string#1\@space}{\string#2\@space}%
        }%
      }%
    }%
  }%
}
\newletcsset{%
  \ifstremptyTF\ifnullTF,\ifstremptyFT\ifnullFT,
  \oifstremptyTF\oifnullTF,\oifstremptyFT\oifnullFT,
  \xifstremptyTF\xifnullTF,\xifstremptyFT\ifnullFT
}
\robust@def*\LTS@suffixerr#1#2#3{%
  \if\detokenize{#1#2}\relax
    \LTS@err{Invalid suffix '#1' to command '\string#3'}\@ehc
  \fi
}
\robust@def*\LTS@blankargerr#1#2{%
  \LTS@err{Invalid blank/empty argument to command
    '\string#1'}\@ehc
}
% Get the last element of a csv list:
% #1: parser, #2: csv list
\robust@def*\ltsgetlastcsv#1#2{%
  \cpt@ch@cklistparser{#1}%
  \def\rest{}%
  \def\LTS@getlastcsv##1#1##2#1{%
    \ifx##2\noboundary
      \edef\last{\unexpanded{##1}}%
      \expandafter\cpt@removetonnil
    \else
      \edef\rest{\csliststack#1\rest\unexpanded{##1}}%
      \expandafter\LTS@getlastcsv
    \fi
    ##2#1%
  }%
  \LTS@getlastcsv#2#1\noboundary#1\noboundary#1\cpt@nnil
}
% Get the last element of a tsv list:
\robust@def*\ltsgetlasttsv#1{%
  \def\rest{}%
  \LTS@getlasttsv#1\noboundary\noboundary\cpt@nnil
}
\robust@def*\LTS@getlasttsv#1#2{%
  \ifx#2\noboundary
    \edef\last{\unexpanded{#1}}%
    \expandafter\cpt@removetonnil
  \else
    \edef\rest{\expandcsonce\rest\unexpanded{#1}}%
    \expandafter\LTS@getlasttsv
  \fi
  #2%
}
\robust@def*\ltsifstringcase{\LTS@testst\LTS@ifstringcase}
\robust@def\LTS@ifstringcase#1#2:{%
  \ifblankTF{#2}{%
    \LTS@blankargerr\ifstringcase{second}%
  }{%
    \LTS@testopt{\LTS@ifstringcase@a{#1}#2}{}%
  }%
}
\robust@def\LTS@ifstringcase@a#1#2[#3]{%
  \ifLTS@st
    \let\LTS@ifstringcase@b\ifstrcmpTF
  \else
    \let\LTS@ifstringcase@b\ifstreqTF
  \fi
	\def\LTS@ifstringcase@c##1##2##3\LTS@nil{%
    \LTS@ifstringcase@b{#1}{##1}{##2}{%
      \ifnullTF{##3}{#3}{%
        \LTS@ifstringcase@c##3\LTS@nil
      }%
    }%
  }%
	\LTS@ifstringcase@c#2\LTS@nil
}
\robust@def\ltsifstringcases#1#2:{%
  \ifblankTF{#2}{%
    \LTS@blankargerr\ifstringcases{second}%
  }{%
    \LTS@testopt{\LTS@ifstringcases{#1}#2}{}%
  }%
}
\long\def\LTS@ifstringcases#1#2[#3]{%
  \begingroup
  \toks@{}%
  \long\def\LTS@tempa##1##2{%
    \ifstrcmpTF{##1}{\LTS@nil}{%
      \oifblankFT{\the\toks@}{}{\toks@{#3}}%
    }{%
      \ifstrcmpTF{#1}{##1}{%
        \toks@\expandafter{\the\toks@##2}%
        \LTS@tempa
      }{%
        \LTS@tempa
      }%
    }%
  }%
  \LTS@tempa#2\LTS@nil\LTS@nil
  \expandafter\endgroup\the\toks@\relax
}
\robust@def\ltsifmembercases#1#2:{%
  \ifblankTF{#2}{%
    \LTS@blankargerr\ifmembercases{second}%
  }{%
    \LTS@testopt{\LTS@ifmembercases{#1}#2}{}%
  }%
}
\robust@def\LTS@ifmembercases#1#2[#3]{%
  \begingroup
  \toks@{}%
  \long\def\LTS@tempa##1##2{%
    \ifstrcmpTF{##1}{\LTS@nil}{%
      \oifblankFT{\the\toks@}{}{\toks@{#3}}%
    }{%
      \ifinsetTF{,#1,}{,##1,}{%
        \toks@\expandafter{\the\toks@##2}%
        \LTS@tempa
      }{%
        \LTS@tempa
      }%
    }%
  }%
  \LTS@tempa#2\LTS@nil\LTS@nil
  \expandafter\endgroup\the\toks@\relax
}
\robust@def\ltsifnumcase{%
  \let\LTS@ifnumcase@b\LTS@ifnumcase
  \LTS@ifnumcase@a
}
\robust@def\LTS@ifnumcase@a#1#2:{%
  \LTS@suffixerr{*}{#1}\ltsifnumcase
  \ifblankTF{#2}{%
    \LTS@blankargerr\ltsifnumcase{second}%
  }{%
    \LTS@testopt{\LTS@ifnumcase@b{#1}#2}{}%
  }%
}
\robust@def\LTS@ifnumcase#1#2[#3]{%
	\def\LTS@ifnumcase@c##1##2##3\LTS@nil{%
    \ifnumcmpTF#1=##1{%
      ##2%
    }{%
      \ifnullTF{##3}{%
        #3%
			}{%
        \LTS@ifnumcase@c##3\LTS@nil
      }%
    }%
  }%
	\LTS@ifnumcase@c#2\LTS@nil
}
\robust@def\ltsifnumcases{%
  \let\LTS@ifnumcase@b\LTS@ifnumcases
  \LTS@ifnumcase@a
}
\robust@def\LTS@ifnumcases#1#2[#3]{%
	\begingroup
  \toks@{}%
  \long\def\LTS@tempa##1##2{%
    \ifstrcmpTF{##1}{\LTS@nil}{%
      \oifblankFT{\the\toks@}{}{\toks@{#3}}%
    }{%
      \ifnumcmpTF#1=##1{%
        \toks@\expandafter{\the\toks@##2}%
        \LTS@tempa
      }{%
        \LTS@tempa
      }%
    }%
  }%
  \LTS@tempa#2\LTS@nil\LTS@nil
  \expandafter\endgroup\the\toks@\relax
}
% Putting > or < before =
\new@def*\LTS@numcasse@setcmptor#1#2#3\@nil{%
  \romannumeral
  \ifstrcmpTF{#1}={%
    \ifstrcmpTF{#2}<{0<=#3}{%
      \ifstrcmpTF{#2}>{0>=#3}{0 #1#2#3}%
    }%
  }{0 #1#2#3}%
}
\new@def*\LTS@docasseelse#1\endif{#1}
\new@def*\LTS@docassecbk#1#2\endif{#1}
\new@def*\LTS@gobbletoendif#1\endif{}
\new@def*\LTS@ifnumcassecmp#1#2{%
  \expandafter\expandafter\expandafter
  \ltsifnumcasse@eqin\LTS@numcasse@setcmptor#2\@nil=\@nil{%
    \cptbexpandnext{\ltsifnumcasse@dimwitheq{#1}}
    {\LTS@numcasse@setcmptor#2\@nil}\@nil
  }{%
    \ifdim#1pt#2pt %
  }%
}
\new@def*\ltsifnumcasse@eqin#1=#2\@nil{%
  \ltsifblankTF{#2}\@secondoftwo{%
    \ltsifblankTF{#1}\@secondoftwo\@firstoftwo
  }%
}
\new@def*\ltsifnumcasse@dimwitheq#1#2=#3\@nil{%
  \unless\ifdim#1pt\if<#2>\else<\fi#3pt
}
% Eg,
% \edef\foo{%
%   \ltsifnumcasse{5}% <- number to test
%     {<=1}{less than or equal to 1}
%     {<=3}{less than or equal to 3}
%     {=4}{equal 4}
%     {=>5}{greater than or equal to 5}
%   \elseif
%     no match%
%   \endif
% }
\new@def*\ltsifnumcasse#1#2{%
  \ifstrcmpTF{#2}\elseif\LTS@docasseelse{%
    \ifstrcmpTF{#2}\endif{}{%
      \LTS@ifnumcassecmp{#1}{#2}%
      \expandafter\@firstoftwo\else\expandafter\@secondoftwo\fi
      \LTS@docassecbk{\ltsifnumcasse@i{#1}}%
    }%
  }%
}
\new@def*\ltsifnumcasse@i#1#2{\ltsifnumcasse{#1}}
\let\ltsifcassethen\iffalse
\new@def*\ltsifcassenumcmp#1#2\ltsifcassethen{\LTS@ifcassenumcmp{#1}{#2}}
\new@def*\ltsifcassecmdcmp#1#2\ltsifcassethen{\ifx#1#2}
\new@def*\ltsifcassestrcmp#1#2\ltsifcassethen{%
  \ifnum\pdfstrcmp{\detokenize{#1}}{\detokenize{#2}}=\z@pt
}
% Eg,
% \edef\x{%
%   \ltsifcasse\ltsifcassenumcmp{3.14}% <- number to test
%     {<=2}{less than or equal to 2}
%     {=<3}{less than or equal to 3}
%     {=>4}{greater than or equal to 4}
%     {<10}{less than 10}
%   \elseif
%     no match
%   \endif
% }
% Comparator commands are \ltsifcassenumcmp, \ltsifcassecmdcmp
% and \ltsifcassestrcmp.
% #1=comparator command, #2=testtoken1
\new@def*\ltsifcasse#1#2{%
  \ifstrcmpTF{#1}\elseif{%
    \LTS@gobbletoendif
  }{%
    \ifstrcmpTF{#1}\endif{}{%
      \ifstrcmpTF{#2}\elseif{%
        \LTS@gobbletoendif
      }{%
        \ifstrcmpTF{#2}\endif{}{%
          \ltsifcasse@i{#1}{#2}%
        }%
      }%
    }%
  }%
}
\new@def*\ltsifcasse@i#1#2#3{%
  \ifstrcmpTF{#3}\elseif{%
    \LTS@docasseelse
  }{%
    \ifstrcmpTF{#3}\endif{}{%
      #1{#2}{#3}\ltsifcassethen
      \expandafter\@firstoftwo\else\expandafter\@secondoftwo\fi
      {\LTS@docassecbk}{\ltsifcasse@ii{#1}{#2}}%
    }%
  }%
}
\new@def*\ltsifcasse@ii#1#2#3{\ltsifcasse@i{#1}{#2}}
% \dkreplicate <nr>{<callback>}
\newcommand*\dkreplicate[1]{%
  \csname LTS@repl\expandafter\LTS@replicate
  \romannumeral\number\number#1000q\endcsname
}
\long\def\LTS@replicate#1#2\endcsname#3{#1\endcsname{#3}#2}
\long\def\LTS@replm#1#2{#1\csname LTS@repl#2\endcsname{#1}}
\let\LTS@replq\@gobble

\def\reserved@a#1{%
  \new@def\LTS@ifleadspace##1\@nil#1##2\@nil\@nil{\ltsifblankFT{##2}}%
  \new@def\ltsifleadspace##1{%
    \LTS@ifleadspace\@nil##1\@nil#1\@nil\@nil
  }%
  \new@def\LTS@iftrailspace##1#1\@nil##2\@nil#1{\ltsifblankFT{##2}}%
  \new@def\ltsiftrailspace##1{%
    \LTS@iftrailspace##1\@nil#1\@nil\@nil#1%
  }%
}
\reserved@a{ }
\robust@def*\ltsmakecsn#1#2{%
  \ifblankTF{#1}{}{%
    \edef#2{\cpttrimspaces{#1}}%
    \edef#2{\expandafter\cptgobblescape#2}%
  }%
}
\ltsmakecsn{\\}\@backslashchar
\robust@def*\ltsgetcsname{\LTS@testst\LTS@getcsname}
\new@def*\LTS@getcsname#1#2{%
  \begingroup
  \ifcsnullTF#1{%
     \edef#2{\ifLTS@st{}\fi}%
  }{%
    \escapechar\m@one
    \ifLTS@st
      \edef#2{{\expandafter\string#1}}%
    \else
      \edef#2{\expandafter\string#1}%
    \fi
  }%
  \postgroupdef#2\endgroup
}
\robust@def*\ltsemptify{%
  \cpt@checkoptprefix{\LTS@teststcl\LTS@emptify}%
}
\def\LTS@emptify#1{%
  \LTS@long@or@relax\LTS@global@or@relax
  \glob@lrel@x\l@ngrel@x\def#1{}%
}
\robust@def*\ltsemptifycsset{%
  \cpt@checkoptprefix{\LTS@testplcl\LTS@emptifycsset}%
}
\robust@def*\ltsemptifycsset@{%
  \LTS@plfalse\LTS@clfalse\LTS@emptifycsset
}
\new@def*\LTS@emptifycsset#1{%
  \LTS@global@or@relax
  \def\csv@do##1{%
    \ifLTS@pl
      \glob@lrel@x\cptemptifycsn{##1}%
    \else
      \ltsensurescape{##1}%
      \glob@lrel@x\def##1{}%
    \fi
  }%
  \csv@@parse[,]{#1}%
}
\new@def\ltsswapbracetwo#1#2{{#2}{#1}}
\new@def\ltsswapbracefirst#1#2{#2{#1}}
\newletcs\ltspassarg\ltsswapbracefirst
\new@def\ltsswapbracesecond#1#2{{#2}#1}
\new@def\ltsswapfirstthird#1#2#3{#3{#2}{#1}}
\new@edef*\LTS@istrue{\string\iftrue}
\new@edef*\LTS@isfalse{\string\iffalse}

% \ltsinputfiles[x]{a,b}[tex]{if file exists}:
\robust@def*\ltsinputfiles{\cpt@testopt\LTS@Inp@tFiles{}}
\def\LTS@Inp@tFiles[#1]#2{\cpt@testopt{\LTS@Inp@tF@les[#1]#2}{tex}}
\def\LTS@Inp@tF@les[#1]#2[#3]#4{%
  \begingroup
  \toks@{}%
  \def\csv@do##1{%
    \toks@\expandafter{\the\toks@\InputIfFileExists{#1##1.#3}%
      {#4}{\@missingfileerror{#1##1}{#3}}}%
  }%
  \edef\LTS@tempa{\cptzapspaces{#2}}%
  \csv@@loop*[,]\LTS@tempa
  \expandafter\endgroup\the\toks@
}
\robust@def\ltssafefullexpand#1{%
  \begingroup
  \ltssafeactivesedef\reserved@a{\endgroup#1}\reserved@a
}
\robust@def\ltssafeexpandarg#1#2{%
  \begingroup
  \ltssafeactivesedef\reserved@a{\endgroup\unexpanded{#1}{#2}}%
  \reserved@a
}
\robust@def\ltssafeexpandsecond#1#2{%
  \begingroup
  \ltssafeactivesedef\reserved@a{\endgroup\unexpanded{#1}#2}%
  \reserved@a
}
\robust@def\ltsexpandargs#1#2#3#4\LTS@nil{%
  \cptpassexpanded{%
    \ifcase#1\relax
      \unexpanded{#2}{#3}%
    \or
      \unexpanded{#2#3}{#4}%
    \or
      \unexpanded{#2}{#3}{#4}%
    \or
      \unexpanded{#2}{#3}\unexpanded{#4}%
    \else
      \LTS@err{Unknown expansion type '\string#1' for
        \string\ltsexpandargs}{I expected your first argument
        '\string#1' to \string\ltsexpandargs\MsgBrk to be
        in the interval [0,3].}%
    \fi
  }%
}
\robust@def*\ltssafeexpandtwoargs#1#2#3{%
  \begingroup
  \ltssafeactivesedef\reserved@a{\endgroup\noexpand#1{#2}{#3}}%
  \reserved@a
}
\robust@def*\expanddetoktwoargs#1#2#3{%
  \cptexpandtwoargs#1{\cptoxdetok{#2}}{\cptoxdetok{#3}}%
}
%% Ulrich Diez:
\new@def*\ltsstepexpandarg#1{%
  0\csname @space\expandafter\LTS@stepexpandarg
  \romannumeral\number\number#1000D\endcsname
}
\new@def*\LTS@stepexpandarg#1{%
  \if#1m\expandafter\expandafter
    \csname endcsname\expandafter\LTS@stepexpandarg\fi
}
%%--

\robust@def*\ltsStepExpandArg{\LTS@testopt\LTS@StepExpandArg{}}
\robust@def*\LTS@StepExpandArg[#1]#{%
  \begingroup
  \edef\LTS@tempa{\endgroup\unexpanded{#1}}%
  \expandafter\LTS@tempa\romannumeral\ltsstepexpandarg
}
\robust@def*\ltsnameidef#1#2#3{%
  \expandafter\def\csname#1\expandafter
  \endcsname\expandafter{\romannumeral\ltsstepexpandarg{#2}#3}%
}
\robust@def*\ltsnamejdef#1#{\romannumeral\LTS@namejdef{#1}}
\new@def*\LTS@namejdef#1#2#3#{\LTS@n@mejdef{#1}{#2}{#3}}
\newcommand\LTS@n@mejdef[5]{%
  \expandafter\cptswap\expandafter{%
    \csname#2\expandafter\cptswap\expandafter{\expandafter{%
      \romannumeral\ltsstepexpandarg{#4}#5%
    }}{\endcsname #3}%
  }{0 #1}%
}
\new@def*\ltsexpandtimes#1{%
  \expandafter\LTS@expandtimes\expandafter
    {\romannumeral\number#1000}%
}
\new@def*\LTS@expandtimes#1#2{%
  \ifnullTF{#1}{%
    \unexpanded{#2}%
  }{%
    \expandafter\ifnullTF\expandafter{\@gobble#1}{%
      \unexpanded\expandafter{#2}%
    }{%
      \expandafter\ltsswapbracefirst\expandafter{#2}%
      {\expandafter\LTS@expandtimes\expandafter{\@gobble#1}}%
    }%
  }%
}
\new@def*\ltsprotectedtokens#{%
  \ifx\protect\@typeset@protect
    \LTS@protectedtoken\@firstofone\fi
  \ifx\protect\@unexpandable@protect
    \LTS@protectedtoken\ltsunexpandable\fi
  \ifx\protect\noexpand
    \LTS@protectedtoken\unexpanded\fi
  \ifx\protect\string
    \LTS@protectedtoken\detokenize\fi
  \relax\@firstofone
}
\new@def*\LTS@protectedtoken#1#2\relax\@firstofone{\fi#1}
\new@def\ltsunexpandable#1{\unexpanded{\ltsprotectedtokens{#1}}}
\new@def\ltsneverexpand#1{%
  \unexpanded{\unexpanded{\unexpanded{\unexpanded{%
  \unexpanded{\unexpanded{\unexpanded{\unexpanded{#1}}}}}}}}%
}

% Reverse condition. Eg, turn \iffoundTF into \iffoundFT,
% \iffoundFT into \iffoundTF, \iffoundT to \iffoundF, etc.
% If there is no 'TF' (or 'T' or 'F') at end of csname,
% then use \unless:
\new@def*\revcond#1{%
  \LTS@revcond@b{#1}\LTS@cartworev{TF}{%
    \LTS@revcond@c{#1}\LTS@cdrtwo{FT}%
  }{%
    \LTS@revcond@b{#1}\LTS@cartworev{FT}{%
      \LTS@revcond@c{#1}\LTS@cdrtwo{TF}%
    }{%
      \LTS@revcond@b{#1}\LTS@car{T}{%
        \LTS@revcond@c{#1}\LTS@cdr{F}%
      }{%
        \LTS@revcond@b{#1}\LTS@car{F}{%
          \LTS@revcond@c{#1}\LTS@cdr{T}%
        }{%
          \unless#1%
        }%
      }%
    }%
  }%
}
\def\LTS@revcond@a#1{%
  \expandafter\expandafter\expandafter\directreverse
  \expandafter\expandafter\expandafter
  {\cptremovescape{#1}}%
}
\new@def*\LTS@revcond@b#1#2#3{%
  \expandafter\ifstrcmpTF\expandafter{\romannumeral0\expandafter#2%
  \romannumeral0\LTS@revcond@a{#1}\car@nil}{#3}%
}
\new@def*\LTS@revcond@c#1#2#3{%
  \usename{\expandafter\expandafter\expandafter\directreverse
  \expandafter\expandafter\expandafter{\expandafter#2\romannumeral0%
  \LTS@revcond@a{#1}\cdr@nil}#3}%
}
\robust@def*\ifonetokenTF{%
  \cpt@checkoptprefix{\LTS@teststcl\LTS@ifonetoken}%
}
\robust@def*\LTS@ifonetoken#1{%
  \begingroup
  \ifbracedTF{#1}{%
    \aftergroup\@secondoftwo
  }{%
    \def\reserved@a##1\LTS@nil{%
      \def\reserved@a{%
        \csnaftergroup{LTS@\s@expandarg\ifnullTF{\@gobble##1}12of2}%
      }%
      \ifLTS@cl
        \ifblankTF{##1}{\aftergroup\@secondoftwo}{\reserved@a}%
      \else
        \ifblankTF{##1}{\aftergroup\@firstoftwo}{\reserved@a}%
      \fi
    }%
    \ifLTS@st\expandafter\expandafter\fi\reserved@a#1\LTS@nil
  }%
  \endgroup
}
\robust@def*\ifonetokenFT#1{\ifonetokenTF{#1}\iiofii\iofii}
\robust@def*\ifonetoken#1\do#2{%
  \LTS@stfalse\LTS@cltrue
  \LTS@ifonetoken{#1}{#2}{%
    \LTS@err{More than one token in '\detokenize{#1}'}\@ehc
  }%
}
\new@def*\ifboxvoidTF#1{%
  \usename{@\ifvoid#1\@empty first\else second\fi ftwo}%
}
\new@def*\ifboxvoidFT#1{\usename{LTS@\ifboxvoidTF{#1}21of2}}
\new@def*\ifdefinedTF#1{%
  \usename{LTS@\iflacus#1\dolacus2\else
    \ifdefined#11\else2\fi\fi of2}%
}
\new@def*\ifdefinedFT#1{\usename{LTS@\ifdefinedTF{#1}21of2}}
% Eg,
%   \ifmoduloTF{4}{6}{true}{false}
%   \ifmoduloTF{4}{20}{true}{false}
\new@def*\ifmoduloTF#1#2{%
  \ifnumcmpTF((#2)/(#1))*(#1)-(#2)=\z@pt
}
\let\then\iffalse
\new@def*\ifnnum#1\then{%
  \ifdim\LTS@ptlt\LTS@ptgt\LTS@pteq#1pt%
    \cpt@removetonnil<=>\cpt@nnil\@space
}
\new@def*\LTS@ptlt#1<{#1pt<}
\new@def*\LTS@ptgt#1>{#1pt>}
\new@def*\LTS@pteq#1={#1pt=}
\new@def*\realnumcmp{TT\fi\ifnum\ltsrealnums}
\new@def*\ltsrealnums#1\then{%
	\dimexpr\LTS@dptlt\LTS@dptgt\LTS@dpteq#1pt%
    \cpt@removetonnil<=>\cpt@nnil\@space
}
\new@def*\LTS@dptlt#1<{#1pt<\dimexpr}
\new@def*\LTS@dptgt#1>{#1pt>\dimexpr}
\new@def*\LTS@dpteq#1={#1pt=\dimexpr}
\begingroup
\catcode`\Y=12
\catcode`\Z=12
\lccode`\Y=`\p
\lccode`\Z=`\t
\lowercase{%
  \defpass\x{\endgroup
    \new@def*\LTS@ifinteger@a##1.##2YZ{%
      \expandafter\ifx\expandafter\\\romannumeral0%
      \ifnum##2>\z@pt\else\expandafter\@gobble\fi
      \LTS@ifinteger@b\@space\\\cpt@removetonnil\cpt@nnil
    }%
  }%
}
\new@def\LTS@ifinteger@b#1\cpt@nnil{\noexpand\cpt@nnil}
\new@def\LTS@ifinteger#1\then{%
  \expandafter\LTS@ifinteger@a
  \the\dimexpr\LTS@mminus\LTS@pplus#1\p@
  \cpt@removetonnil+-\cpt@nnil\relax
}
\def\LTS@mminus#1-{#1\p@-}
\def\LTS@pplus#1+{#1\p@+}
\new@def\ifintegerTF#1#{%
  \usename{LTS@\LTS@ifinteger#1\then1\else2\fi of2}%
}
\new@def\LTS@IfInteger#1\then{%
  \begingroup
  \toks@{}%
  \LTS@integerparse{#1}{-}%
  \toks@\expandafter{\expandafter}\expandafter
  \LTS@integerparse\expandafter{\the\toks@}{+}%
  \defpass\LTS@tempa{%
    \xifinsetFT{\p@\p@\LTS@nil}{\the\toks@\LTS@nil}{}{%
      \def\LTS@tempb####1\p@\LTS@nil{%
        \toks@{####1}%
        \LTS@tempa
      }%
      \expandafter\LTS@tempb\the\toks@\LTS@nil
    }%
  }%
  \edef\LTS@tempa{\the\dimexpr\the\toks@}%
  \expandafter\endgroup\expandafter\LTS@ifinteger
    \expandafter\rem@pt\LTS@tempa\then
}
\new@def\LTS@integerparse#1#2{%
  \def\LTS@tempa##1#2##2\LTS@nil{%
    \ifblankTF{##2}{%
      \toks@\expandafter{\the\toks@##1\p@}%
    }{%
      \ifstrcmpTF{#2}{##2}{%
        \toks@\expandafter{\the\toks@##1\p@}%
      }{%
        \toks@\expandafter{\the\toks@##1\p@#2}%
        \LTS@tempa##2#2\LTS@nil
      }%
    }%
  }%
  \LTS@tempa#1\LTS@nil
}
\new@def\IfIntegerTF#1#{%
  \LTS@ifinteger#1\then
  \expandafter\iofii\else\expandafter\iiofii\fi
}
\newletcs\ltsifnumtest\ifnnum
\newcommand*\ltssortnumlt{\LTS@sort\LTS@sortnumlt}
\newcommand*\ltssortnumgt{\LTS@sort\LTS@sortnumgt}
\newcommand*\ltssortalpha{\LTS@sort\LTS@sortalpha}
\newcommand\LTS@sort[2]{%
  \iflacus#2\dolacus
  \expandafter\iofii\else\expandafter\iiofii\fi
  {}{%
    \LTS@sortbegin#1{}#2\LTS@nnil\LTS@sortbegin
  }%
}
\def\ifLTS@sortnil#1{%
  \expandafter\ifx\expandafter\LTS@nnil\cpt@car#1\car@nil
  \expandafter\iofii\else\expandafter\iiofii\fi
}
\def\LTS@sortbegin#1#2#3#4\LTS@sortbegin{%
  \ifLTS@sortnil{#4}{%
    \sortendfmt{#3}\LTS@sort#1{#2}%
  }{%
    \LTS@sortdo#1{#2}{#3}#4\LTS@sortdo
  }%
}
\def\LTS@sortdo#1#2#3#4#5\LTS@sortdo{%
  #1{#3}{#4}{\LTS@sortresult#1{#2}{#5}}%
}
\def\LTS@sortresult#1#2#3#4#5{%
  \ifLTS@sortnil{#3}{%
    \sortoutputfmt{#4}\LTS@sort#1{#2{#5}}%
  }{%
    \LTS@sortbegin#1{#2{#5}}{#4}#3\LTS@sortbegin
  }%
}
\def\LTS@sortnumlt#1#2#3{%
  \ltsifnumtest#1<#2\then
  \expandafter\iofii\else\expandafter\iiofii\fi
  {#3{#1}{#2}}{#3{#2}{#1}}%
}
\def\LTS@sortnumgt#1#2#3{%
  \ltsifnumtest#1>#2\then
  \expandafter\iofii\else\expandafter\iiofii\fi
  {#3{#1}{#2}}{#3{#2}{#1}}%
}
\def\LTS@sortalpha#1#2#3{%
  \ifnum\cpt@pdfstrcmp{#1}{#2}<\z@pt
    \expandafter\iofii\else\expandafter\iiofii\fi
    {#3{#1}{#2}}{#3{#2}{#1}}%
}

\robust@def*\ifonedefTF{%
  \begingroup\def\casenr{0}\LTS@testpl\LTS@ifonedef
}
\robust@def*\ifonedefFT{%
  \begingroup\def\casenr{1}\LTS@testpl\LTS@ifonedef
}
\robust@def*\LTS@ifonedef#1{%
  \cpt@choicefdfalse
  \def\csv@do##1{%
    \usename{if\ifLTS@pl csn\fi defFT}{##1}{}{%
      \cpt@choicefdtrue\loopbreak
    }%
  }%
  \csv@@parse[,]{#1}%
  \LTS@onecase
}
\robust@def*\ifonetrueTF{%
  \begingroup
  \def\casenr{0}%
  \LTS@testst{\LTS@testopt\LTS@ifonetrue{}}%
}
\robust@def*\ifonetrueFT{%
  \begingroup
  \def\casenr{1}%
  \LTS@testst{\LTS@testopt\LTS@ifonetrue{}}%
}
\robust@def*\LTS@ifonetrue[#1]#2{%
  \cpt@choicefdfalse
  \edef\reserved@a{\ifLTS@st*\fi}%
  \def\csv@do##1{%
    \uselivecsn{if#1##1}%
      \cpt@choicefdtrue\loopbreak
    \fi
  }%
  \expandafter\csv@@parse\reserved@a[#1]{#2}%
  \LTS@onecase
}
\robust@def*\LTS@onecase{%
  \edef\next##1##2##3{%
    \ifcase\casenr
      ##11##22##32\or##12##21##32\or##11##20##31\or
      ##10##21##31%
    \fi
  }%
  \csnendgroup{LTS@\next\ifcpt@choicefd\else{\fi of}}%
}
\new@def*\ifcsndefeqTF#1#2{%
  \ifcsndefFT{#1}\@secondoftwo
    {\ifcsndefFT{#2}\@secondoftwo
    {\aftercsname\ifxTF{#1\aftercsname}{#2}}}%
}
\new@def*\ifcsndefeqFT#1#2{\usename{LTS@\ifcsndefeqTF{#1}{#2}21of2}}
\robust@def*\LTS@notdefinable{%
  \PackageError{ltxtools}%
    {Command '\@backslashchar\LTS@rsvda' or
      '\@backslashchar\@qend\LTS@rsvda' already defined}%
    {Command '\@backslashchar\LTS@rsvda' already defined,
      or name '\@backslashchar\@qend\LTS@rsvda' illegal.}%
}
\robust@def*\ltssaveprimitive#1#2{%
  \begingroup
  \cpt@swafalse
  \edef\LTS@tempa{\string#1}%
  \edef\LTS@tempb{\meaning#1}%
  \ifx\LTS@tempa\LTS@tempb
    \cpt@swatrue
  \else
    \edef\LTS@tempb{\meaning#2}%
    \ifx\LTS@tempa\LTS@tempb\else\LTS@saveprimitive#1#2\fi
  \fi
  \expandafter\endgroup\ifcpt@swa\let#2#1\fi
}
\robust@def*\LTS@saveprimitive#1#2{%
  \def\LTS@tempb##1#1##2##3\edef{\edef\LTS@tempb{##2}\edef}%
  \LTS@tempb
    \nullfont{select font nullfont}%
    \topmark{\string\topmark:}%
    \firstmark{\string\firstmark:}%
    \botmark{\string\botmark:}%
    \splitfirstmark{\string\splitfirstmark:}%
    \splitbotmark{\string\splitbotmark:}%
    #1{\string#1}%
  \edef\LTS@tempa{\expandafter\strip@prefix\meaning\LTS@tempb}%
  \edef\LTS@tempb{\meaning#1}%
  \ifx\LTS@tempa\LTS@tempb
    \cpt@swatrue
  \else
    \@latex@error{Command \noexpand#1 no longer a primitive}\@ehc
  \fi
}
\robust@def*\LTS@badargerr#1#2{%
  \LTS@err{Bad '\string#2' argument for command '\string#1'}{%
    Bad '\string#2' argument for command '\string#1'.\MsgBrk
    You need to look again at user instruction\MsgBrk
    for command '\string#1'.
  }%
}
\newletcs\ifpackageloadedTF\@ifpackageloaded
\newletcs\ifclassloadedTF\@ifclassloaded
\new@def*\ifpackageloadedFT#1{\ifpackageloadedTF{#1}\iiofii\iofii}
\new@def*\ifclassloadedFT#1{\ifclassloadedTF{#1}\iiofii\iofii}
\new@def*\LTS@ifclasscurr{\LTS@ifpkg@cls@curr\@clsextension}
\new@def*\LTS@ifpackagecurr{\LTS@ifpkg@cls@curr\@pkgextension}
\new@def*\LTS@ifpkg@cls@curr#1#2#3{%
  \usename{LTS@\ifnum\cptsevenxp\@parse@version
    \usename{ver@#2.#1}//00\@nil<\expandafter
    \@parse@version#3//00\@nil2\else1\fi of2}%
}
\new@def*\ifclasscurrentTF{\LTS@ifloadedcurr{class}}
\new@def*\ifpackagecurrentTF{\LTS@ifloadedcurr{package}}
\newletcs\ifpkgcurrTF\ifpackagecurrentTF
\new@def*\LTS@ifloadedcurr#1#2#3{%
  \usename{if#1loadedTF}{#2}{%
    \usename{LTS@if#1curr}{#2}{#3}{%
      \@firstoftwo
    }{%
      \LTS@err{Loaded version of #2 package is not current}%
        {You need a higher version of #2 package:\MsgBrk
        The version of #2 package available on your TeX\MsgBrk
        installation is lower than you require.}%
      \@secondoftwo
    }%
  }{%
    \@secondoftwo
  }%
}
\new@def*\ifpackagecurrentFT#1{\ifpackagecurrentTF{#1}\iiofii\iofii}
\new@def*\ifclasscurrentFT#1{\ifclasscurrentTF{#1}\iiofii\iofii}
\robust@def*\NeedPackage#1{\LTS@testopt{\LTS@needpackage{#1}}{}}
\newletcs\needpackage=\NeedPackage
\robust@def*\LTS@needpackage#1[#2]{%
  \iflacus#2\dolacus
    \LTS@err{No date given for package '#1'}\@ehc
  \fi
  \def\reserved@a##1/##2/##3/##4\@nil{%
    \ifcase0\ifnum##1<1983 1 \fi\ifnum##2<1 1 \fi\ifnum##3<1 1\fi
    \relax\else
      \LTS@err{Invalid package date '#2'}\@ehc
    \fi
  }%
  \reserved@a#2///\@nil
  \edef\reserved@a{%
    \ifx\documentclass\@twoclasseserror\noexpand\usepackage
      \else\noexpand\RequirePackage\fi
  }%
  \cptexpanded{\LTS@testopt{\LTS@needp@ckage{#1}{#2}%
    \expandcsonce\reserved@a}}{}%
}
\robust@def*\LTS@needp@ckage#1#2#3[#4]{%
  \ifpackagecurrentTF{#1}{#2}{}{#3[#4]{#1}[#2]}%
}
\newcommand*\ltsremoveouterbraces[1]{%
  \romannumeral\ifstrcmpTF{#1}{all}{%
    \LTS@r@movebraces
  }{%
    \expandafter\LTS@removeouterbraces
    \expandafter{\romannumeral#1000}%
  }%
}
\newcommand\LTS@removeouterbraces[2]{%
  \ifnullTF{#1}{0 #2}{%
    \expandafter\ifnullTF\expandafter{\@gobble#2}{%
      \ifbracedTF{#2}{%
        \expandafter\ltsswapbracefirst\expandafter{\@iden#2}%
        {\expandafter\LTS@removeouterbraces\expandafter{\@gobble#1}}%
      }{0 #2}%
    }{0 #2}%
  }%
}
\newcommand\LTS@r@movebraces[1]{%
  \expandafter\ifnullTF\expandafter{\@gobble#1}{%
    \ifbracedTF{#1}{%
      \expandafter\LTS@r@movebraces\expandafter{\@iden#1}%
    }{0 #1}%
  }{0 #1}%
}

% Eg, \stripbracesinarg{St\"o{\ss}er}
\newcommand*\stripbracesinarg[1]{%
  \romannumeral
  \LTS@stripbracesinarg\strip@nil#1\strip@nil
}
\new@def\LTS@stripbracesinarg#1\strip@nil#2#3\strip@nil{%
  \iflacus#3\dolacus
    \expandafter\@firstoftwo
  \else
    \expandafter\@secondoftwo
  \fi
  {0 #1#2}{\LTS@stripbracesinarg#1#2\strip@nil#3\strip@nil}%
}

\robust@def*\ltsensuremacro#1{%
  \ifmacroTF{#1}{}{\cpt@notcserr{#1}}%
}
\robust@def*\ltsensurescape#1{%
  \ifescapedTF{#1}{}{\cpt@notescapederr{#1}}%
}
\robust@def*\ltsensurenoscape#1{%
  \ifescapedTF{#1}{\cpt@isescapederr{#1}}{}%
}
\robust@def*\ltsensurescape@csset#1#2{%
  \cptdocommalist{#2}{%
    \usename{LTS@ensure\ifnullTF{#1}{}{no}scape}{##1}%
  }%
}
\robust@def\ltsifnextchar#1#2#3{%
  \LTS@ifn@xtchar\bgroup
    {\LTS@ifn@xtchar{#1}{#2}{#3}}%
    {\LTS@ifnextchar{#1}{#2}{#3}}%
}
\new@def\LTS@ifnextchar#1#2#3#4{%
  \csname LTS@\if\detokenize{#1#4}1\else2\fi of2\endcsname
  {#2}{#3}#4%
}
\newcsndef{LTS@ifnextch} {\futurelet\next\LTS@ifn@@tchar}
\new@def\LTS@ifn@xtchar#1#2#3{%
  \begingroup
  \let\reserved@a=#1\toks@{#2}\toks1{#3}%
  \futurelet\next\LTS@ifn@@tchar
}
\new@def*\LTS@ifn@@tchar{%
  \ifx\next\@sptoken
    \let\LTS@next\LTS@ifnextch
  \else
    \ifx\next\reserved@a
      \edef\LTS@next{\endgroup\the\toks@}%
    \else
      \edef\LTS@next{\endgroup\the\toks1}%
    \fi
  \fi
  \LTS@next
}
\robust@def*\nogobblespaceifnextchar#1#2#3{%
  \begingroup
  \let\reserved@a=#1\toks@{#2}\toks1{#3}%
  \futurelet\next\LTS@nogobblespaceifnext
}
\new@def*\LTS@nogobblespaceifnext{%
  \cptpassexpanded{\endgroup
    \ifxTF\next\reserved@a{\the\toks@}{\the\toks1}%
  }%
}
\robust@def*\LTS@ifchar#1#2#3{%
  \ltsifnextchar#1{\begingroup\defpass\x#1{\endgroup#2}}{#3}%
}
\robust@def*\LTS@ifstar{\LTS@ifchar*}
\robust@def*\LTS@ifplus{\LTS@ifchar+}
\robust@def*\LTS@ifclam{\LTS@ifchar!}
\robust@def*\LTS@ifdot{\LTS@ifchar.}
\robust@def*\LTS@ifright{\LTS@ifchar>}
\robust@def*\LTS@ifleft{\LTS@ifchar<}
\robust@def*\LTS@ifprime{\LTS@ifchar'}
\robust@def*\ifnextisbrack#1#2{\ltsifnextchar[{#1}{#2}}
\robust@def*\ifnextisparen#1#2{\ltsifnextchar({#1}{#2}}
\robust@def*\ifnextisleftang#1#2{\ltsifnextchar<{#1}{#2}}
\robust@def*\LTS@testst#1{\LTS@ifstar{\LTS@sttrue#1}{\LTS@stfalse#1}}
\robust@def*\LTS@testpl#1{\LTS@ifplus{\LTS@pltrue#1}{\LTS@plfalse#1}}
\robust@def*\LTS@testcl#1{\LTS@ifclam{\LTS@cltrue#1}{\LTS@clfalse#1}}
\robust@def*\LTS@testpm#1{\LTS@ifprime{\LTS@pmtrue#1}{\LTS@pmfalse#1}}
\robust@def*\LTS@testrt#1{\LTS@ifright{\LTS@rttrue#1}{\LTS@rtfalse#1}}
\robust@def*\LTS@testlt#1{\LTS@ifleft{\LTS@lttrue#1}{\LTS@ltfalse#1}}
\robust@def*\LTS@teststpl#1{\LTS@testst{\LTS@testpl{#1}}}
\robust@def*\LTS@teststplcl#1{\LTS@testst{\LTS@testpl{\LTS@testcl{#1}}}}
\robust@def*\LTS@teststplpm#1{\LTS@testst{\LTS@testpl{\LTS@testpm{#1}}}}
\robust@def*\LTS@teststclpm#1{\LTS@testst{\LTS@testcl{\LTS@testpm{#1}}}}
\robust@def*\LTS@teststcl#1{\LTS@testst{\LTS@testcl{#1}}}
\robust@def*\LTS@teststpm#1{\LTS@testst{\LTS@testpm{#1}}}
\robust@def*\LTS@testplcl#1{\LTS@testpl{\LTS@testcl{#1}}}
\robust@def*\LTS@testopt#1#2{\ifnextisbrack{#1}{#1[{#2}]}}
\robust@def*\LTS@teststopt#1#2{\LTS@testst{\LTS@testopt{#1}{#2}}}
\robust@def*\LTS@testltopt#1#2{\ifnextisleftang{#1}{#1<{#2}>}}
\robust@def*\LTS@testpnopt#1#2{\ifnextisparen{#1}{#1({#2})}}
\new@def*\LTS@Test@pt#1{\usename{LTS@\ifnullTF{#1}12of2}}
\new@def*\LTS@IfBrack#1#2#3{\LTS@IfBr@ck#1&[&{#2}{#3{#1}}}
\new@def*\LTS@IfBr@ck#1[#2&#3#{\LTS@Test@pt{#1#2}}
\new@def*\LTS@TestOpt#1#2#3{\LTS@IfBr@ck#1&[&{#2#1}{#2[{#3}]{#1}}}
\new@def*\LTS@IfStar#1#2#3{\LTS@IfSt@r#1&*&{#2}{#3{#1}}}
\new@def*\LTS@IfSt@r#1*#2&#3#{\LTS@Test@pt{#1#2}}
\new@def*\LTS@IfPlus#1#2#3{\LTS@IfPl@s#1&+&{#2}{#3{#1}}}
\new@def*\LTS@IfPl@s#1+#2&#3#{\LTS@Test@pt{#1#2}}
\robust@def\ltsifnextchars#1#2#3{%
  \begingroup
  \long\def\special@car{\futurelet\next\special@car@a}%
  \long\def\special@car@a##1##2\car@nil{%
    \ifx\next\temp@bgroup\toks@{{##1}}\else\toks@{##1}\fi
  }%
  \let\temp@bgroup\bgroup
  \let\bgroup\LTS@undefined
  \def\LTS@tempa{#1}\def\LTS@tempb{#2}%
  \def\LTS@tempc{#3}\def\LTS@tempd{}%
  \LTS@ifnextchars@a
}
\def\LTS@ifnextchars@a{\futurelet\next\LTS@ifnextchars@b}
\def\LTS@ifnextchars@b{%
  \ifxTF\next\@sptoken{%
    \afterassignment\LTS@ifnextchars@a\let\next= %
  }{%
    \LTS@ifnextchars@c
  }%
}
\def\LTS@ifnextchars@c#1{%
  \ifx\next\temp@bgroup\toks1{{#1}}\else\toks1{#1}\fi
  \expandafter\special@car\LTS@tempa\car@nil
  \xifstrcmpTF{\the\toks@}{\the\toks1}{%
    \edef\LTS@tempd{\expandcsonce\LTS@tempd\the\toks@}%
    \toks@\cptthreexp{\expandafter\cpt@cdr\LTS@tempa\cdr@nil}%
    \edef\LTS@tempa{\the\toks@}%
    \ifcsnullTF\LTS@tempa{%
      \cptthreexp\endgroup\expandafter\LTS@tempb\LTS@tempd
    }{%
      \LTS@ifnextchars@a
    }%
  }{%
    \edef\LTS@tempd{\expandcsonce\LTS@tempd\the\toks1}%
    \cptthreexp\endgroup\expandafter\LTS@tempc\LTS@tempd
  }%
}
\robust@def*\ltsgetbasechars{\LTS@teststopt\LTS@getbasechars{1}}
\robust@def*\LTS@getbasechars[#1]#2#3{%
  \begingroup
  \def#3{}\@tempcnta\z@
  \cptexpandarg
  \cpttfor{\ifboolTF{LTS@st}\cptoxdetok\detokenize{#2}}\dofor{%
    \edef#3{#3##1}%
    \advance\@tempcnta\@ne
    \ifnum\@tempcnta>#1\relax
      \edef#3{#3\string\ETC}%
      \forbreaktrue
    \fi
  }%
  \postgroupdef#3\endgroup
}
% Eg, \ltstypeoutaligned[;]{xx,aa;yy,bb}
\robust@def*\ltstypeoutaligned{\cpt@testopt\LTS@typeoutaligned{20}}
\robust@def*\LTS@typeoutaligned[#1]#2{%
  \begingroup
  \def\\{ }%
  \ltsdocsvlist[;]{#2}{%
    \@tempcnta\z@pt
    \def\LTS@tempb{}%
    \def\reserved@a####1,####2,####3\LTS@nil{%
      \expandafter
      \cpttfor\detokenize{####1}%
        \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\dofor{%
        \advance\@tempcnta\@ne
        \ifnum\@tempcnta>#1\relax
          \typeout{\LTS@tempb ####2}%
          \forbreaktrue
        \else
          \edef\LTS@tempb{\LTS@tempb########1}%
        \fi
      }%
    }%
    \reserved@a##1,,\LTS@nil
  }%
  \endgroup
}
\robust@def*\ltsgetpackagenames{%
  \AtBeginDocument{%
    \let\ltsgetpackagenames\relax
    \begingroup
    \def\LTS@tempb{%
      \def\\{ }\@tempcnta\z@pt
      \def\LTS@tempa{}%
      \def\siso@do####1{%
        \advance\@tempcnta\@ne
        \ifnum\@tempcnta>20\relax
          \typeout{\LTS@tempa\ifcsnullTF\reserved@f{}{[\reserved@f]}}%
          \loopbreaktrue
        \else
          \edef\LTS@tempa{\LTS@tempa####1}%
        \fi
      }%
      \expandafter\siso@@loop\expandafter{\filename@base
        \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\}%
    }%
    \typeout{^^J *** Package List ***}%
    \def\csv@do##1{%
      \filename@parse{##1}%
      \ifx\filename@ext\@pkgextension
        \ifcsndefTF{\filename@base}{%
          \edef\reserved@e{\expandafter\meaning
            \csname\filename@base\endcsname}%
          \xifinsetTF{\detokenize{macro:}}\reserved@e{%
            \edef\reserved@f{\expandafter\strip@prefix\reserved@e}%
          }{%
            \let\reserved@f\reserved@e
          }%
        }{%
          \def\reserved@f{}%
        }%
        \LTS@tempb
      \fi
    }%
    \csv@@loop*[,]\@filelist
    \typeout{ **************^^J}%
    \endgroup
  }%
}
\cptonlypreamble{\ltsgetpackagenames}
% Eg,
% \begingroup
% \catcode`\;=13
% \catcode`\,=13
% \gdef\y{a , ,b, c, ,}
% \gdef\z{x ; ;y; z; ;}
% \endgroup
% \ltsdeclarelistparser\alistparser{,}
% \ltsdeclarelistparser\blistparser{;}
% ! -> expand and execute the processor.
% \def\do#1{#1}
% \edef\x{\cptexpandbracenext{\alistparser!}{\y}\do}
%
% Nesting is possible:
% \def\@do#1{#1}
% \def\do#1{|#1|\cptexpandbracenext{\blistparser!}\z\@do}
% \edef\x{\cptexpandbracenext{\alistparser!}\y\do}
\robust@def*\ltsdeclarelistparser#1#2{%
  \cptexpandbracenext{\ltssetupnormalizer{#1}}{\string#2}%
  \begingroup
  \def\elta##1{\noexpandcsn{\cptgobblescape#1@list@aux@##1}}%
  \def\eltb{\noexpand\romannumeral-`\noexpand\q%
    \noexpandcsn{\cptgobblescape#1@list@normalizer}%
  }%
  \def\eltc##1{\noexpand\expandafter\elta{b}\noexpand
    \expandafter##1\eltb{########1}#2\noexpand\parselist@nil#2%
    \noexpand\parselist@nnil
  }%
  \cptexpanded{\endgroup
    \def\noexpand#1####1{%
      \noexpand\ifstrcmpTF{####1}{!}{\elta{a}}{\eltc{+}}%
    }%
    \def\elta{a}####1{\eltc{!}}%
    \def\elta{b}####1####2#2####3\noexpand\parselist@nnil####4{%
      \noexpand\ifstrcmpTF{####2}\noexpand\listbreak{}{%
        \noexpand\ifstrcmpTF{####2}\noexpand\parselist@nil{}{%
          \noexpand\ifstrcmpTF{####1}{!}{%
            ####4{####2}%
          }{%
            \noexpand\unexpanded{####4{####2}}%
          }%
          \elta{b}{####1}####3\noexpand\parselist@nnil{####4}%
        }%
      }%
    }%
  }%
}
% Dynamic, arbitrary parser, list normalizer:
\robust@def*\ltssetupnormalizer#1#2{%
  \begingroup
  \lccode`\~=`#2%
  \lowercase{\endgroup
    \csn@def{\cptgobblescape#1@list@normalizer}##1{%
      \unexpanded\expandafter{\romannumeral-`\q
        \usename{\cptgobblescape#1@activeparser}#2##1#2~\LTS@nil}%
    }%
    \csn@def{\cptgobblescape#1@activeparser}##1~##2\LTS@nil{%
      \ifblankTF{##2}
        {\usename{\cptgobblescape#1@spaceparser}##1 #2\LTS@nil}
        {\usename{\cptgobblescape#1@activeparser}##1#2##2\LTS@nil}%
    }%
  }%
  \csn@def{\cptgobblescape#1@spaceparser}##1 #2##2\LTS@nil{%
    \ifblankTF{##2}
      {\usename{\cptgobblescape#1@parserspace}##1#2 \LTS@nil}
      {\usename{\cptgobblescape#1@spaceparser}##1#2##2\LTS@nil}%
  }%
  \csn@def{\cptgobblescape#1@parserspace}##1#2 ##2\LTS@nil{%
    \ifblankTF{##2}
      {\usename{\cptgobblescape#1@doubleparser}##1#2#2\LTS@nil}
      {\usename{\cptgobblescape#1@parserspace}##1#2##2\LTS@nil}%
  }%
  \csn@def{\cptgobblescape#1@doubleparser}##1#2#2##2\LTS@nil{%
    \ifblankTF{##2}
      {\ifblankTF{##1}{}{\expandafter\noexpand\@gobble##1}}
      {\usename{\cptgobblescape#1@doubleparser}##1#2##2\LTS@nil}%
  }%
}
% \ltsforcsvlist[<parser>]{<list>}{<callback>}
% \ltsforcsvlist*[<parser>]<listcmd>{<callback>}
% \ltsdocsvlist[<parser>]{<list>}
% \ltsdocsvlist*[<parser>]<listcmd>
% For \ltsdocsvlist, first define \def\ltsdo<param>\ltsdo{<dfn>}.
% General list parsers. Preserve braces and accept arbitrary parser.
% Use '#1' in <callback> for current item on horizontal level 1,
% ##1 on horizontal level 2, etc. Nesting of the loops
% gives rise to vertical levels. Use \csvbreak or \loopbreak
% to break out of the loop on any level. Loop breaks are vertical
% level dependent: eg, breaking level 1 doesn't affect other
% active levels. An empty list is executed once.
\robust@def*\ltsforcsvlist{\def\do@def{01}\LTS@teststopt\LTS@forcsvlist,}
\robust@def*\ltsdocsvlist{\def\do@def{00}\LTS@teststopt\LTS@docsvlist,}
\robust@def*\LTS@docsvlist[#1]#2{\LTS@forcsvlist[#1]{#2}{}}
\robust@def*\LTS@forcsvlist[#1]#2#3{%
  \pushfunctions\ltsforcsvlist
    {\LTS@csvdo,\LTS@csvact,\ifloopbreak,\do@def}\cpt@csvdepth
  \cpt@stchoose{LTS@st}{#2}\LTS@csvarg\ltsforcsvlist
  \if\do@def\else\def\LTS@csvact##1{#3}\fi
  \def\LTS@csvdo##1#1{%
    \s@expandarg\ifcsvbreakTF{\@gobble##1}\loopbreak\relax
    \ifboolTF{loopbreak}{%
      \gobble@to@sentinel\cpt@csvnil#1%
    }{%
      \edef\LTS@csvarg{\unexpanded\expandafter{\@gobble##1}}%
      \ifcseqTF\LTS@csvarg\cpt@csvnnil{}{%
        \ifswitchTF{do@def}{%
          \expandafter\ltsdo\LTS@csvarg\ltsdo
        }{%
          \s@expandarg\LTS@csvact\LTS@csvarg\relax
        }%
        \LTS@csvdo.%
      }%
    }%
  }%
  \csv@@normalize*[#1]\LTS@csvarg
  \loopbreakfalse
  \expandafter\LTS@csvdo\expandafter.\LTS@csvarg#1\cpt@csvnil#1%
  \popfunctions\ltsforcsvlist\cpt@csvdepth
  \ifnum\cpt@csvdepth=\z@pt\undefcs\ltsdo\fi
}
\cptnewvariables{if}{lastfox}[false]
\newcommand*\LTS@foxnil{\LTS@foxnil}
% \foxloop[<parser>]{<list>}{<callback>}
% \foxloop*[<parser>]{<listcmd>}{<callback>}
% 1.  You can use \currfox<level>, \nextfox<level>, and
%     \currfoxnr<level> within <callback> to access the current
%     element of <list>, the next element of <list>, and
%     the serial number of the current item, respectively, at
%     various levels of nesting. <level> is given in roman numerals,
%     eg, \currfoxi, \currfoxii.
% 2.  You can use \foxlevel to access the level/depth of nesting.
% 3.  You can inset \csvbreak as an element of <list> to break
%     out of the loop. Similarly, you can use \loopbreak within
%     <callback> to break out of the loop.
% 4.  You can insert \csvpause as an element of <list> to pause
%     the loop.
\robust@def*\foxloop{%
  \LTS@testst{\LTS@testopt\LTS@fox@@a{,}}%
}
\robust@def*\LTS@fox@@a[#1]{%
  \cpt@checklistparser{#1}\relax
  \usename{LTS@fox@\ifLTS@st b\else a\fi}[#1]%
}
\robust@def*\LTS@fox@a[#1]#2{%
  \declarefoxlistparser{#1}%
  \LTS@fox@@b{#2}%
}
\robust@def*\LTS@fox@b[#1]#2{%
  \declarefoxlistparser{#1}%
  \expandafter\LTS@fox@@b\expandafter{#2}%
}
\robust@def*\declarefoxlistparser#1{%
  \long\def\LTS@fox@@b##1##2{%
    \pushfunctions\foxloop{%
      \getnextfox,\LTS@foxrema,\foxparser,\LTS@fox@@d,%
      \currfox,\nextfox,\currfoxnr,\iflastfox,\ifloopbreak
    }\cpt@csvdepth
    \pushnumber\foxlevel
    \def\foxparser{#1}%
    \long\def\LTS@foxrema####1\LTS@foxnil#1{%
      \long\edef\foxremainder{\unexpanded{####1}}%
      \ifcsemptyTF\foxremainder\relax
        {\cpt@trimparsers[#1]\foxremainder}%
    }%
    \chardef\currfoxnr\z@pt
    \def\getnextfox####1#1####2\getnextfox{%
      \edef\nextfox{\expandcsonce{\cpt@removetodot####1}}%
      \ifxTF\nextfox\LTS@foxnil{%
        \lastfoxtrue
        \let\nextfox\@empty
        \letcsntocs{nextfox\romannumeral\cpt@csvdepth}\@empty
      }{%
        \lastfoxfalse
        \letcsntocs{nextfox\romannumeral\cpt@csvdepth}\nextfox
      }%
    }%
    \def\LTS@fox@@c####1####2{%
      \getnextfox.####1\getnextfox
      ####2\relax
      \ifboolTF{loopbreak}{}{%
        \LTS@fox@@d.####1\LTS@fox@@d{####2}%
      }%
    }%
    \long\def\LTS@fox@@d####1#1####2\LTS@fox@@d####3{%
      \edef\currfox{\expandcsonce{\cpt@removetodot####1}}%
      \letcsntocs{currfox\romannumeral\cpt@csvdepth}\currfox
      \edef\currfoxnr{\the\numexpr\currfoxnr+1}%
      \letcsntocs{currfoxnr\romannumeral\cpt@csvdepth}\currfoxnr
      \ifxTF\currfox\LTS@foxnil{}{%
        \ifxTF\currfox\cpt@csvbreak{%
          \LTS@foxrema####2%
        }{%
          \ifxTF\currfox\cpt@csvpause{%
            \message{^^J! List pause:
            ^^JType x or X to quit, or <RETURN> to proceed^^J}%
            {\endlinechar-1\global\read-1 to\@gtempa}%
            \lowercase\expandafter{\expandafter\def\expandafter
              \@gtempa\expandafter{\@gtempa}}%
            \xifstrcmpTF\@gtempa{x}{%
              \LTS@foxrema####2%
            }{%
              \LTS@fox@@c{####2}{####3}%
            }%
          }{%
            \LTS@fox@@c{####2}{####3}%
          }%
        }%
      }%
    }%
    \loopbreakfalse\lastfoxfalse
    \cpt@stfalse\cpt@csvnormalize[#1]{##1}%
    \expandafter\LTS@fox@@d\expandafter
      .\normalized@list#1\LTS@foxnil#1\LTS@fox@@d{##2}%
    \popfunctions\foxloop\cpt@csvdepth
    \popnumber\foxlevel
  }%
}
% For use with comma-lists, where nesting isn't needed:
% \cfoxloop{<commalist>}<fn>
\robust@def\cfoxloop#1#2{%
  \chardef\currfoxnr\z@pt
  \edef\foxlevel{\ifdefTF\foxlevel{\the\numexpr\foxlevel+1}{1}}%
  \ifnum\foxlevel>\@ne
    \LTS@err{\noexpand\cfoxloop shouldn't be nested}\@ehc
  \fi
  \def\fox@do##1,{%
    \edef\currfox{\expandcsonce{\@gobble##1}}%
    \ifcseqTF\currfox\cpt@nnil{}{%
      \ifboolTF{loopbreak}{%
        \defpass\reserved@a####1\cpt@nil,{%
          \s@expandarg\cptdoremainder{\@gobble##1,####1}%
        }%
      }{%
        \defpass\reserved@a####1,{%
          \edef\nextfox{\expandcsonce{\@gobble####1}}%
          \edef\currfoxnr{\the\numexpr\currfoxnr+1}%
          \ifcseqFT\nextfox\cpt@nnil{}{%
            \lastfoxtrue\let\nextfox\@empty
          }%
          \expandafter#2\expandafter{\currfox}%
          \fox@do####1,%
        }.%
      }%
    }%
  }%
  \edef\reserved@a{\cptcommanormalize{#1}}%
  \loopbreakfalse\lastfoxfalse
  \expandafter\fox@do\expandafter.\reserved@a,\cpt@nil,%
  \undefcs\foxlevel
}
\new@def*\LTS@csnalloc#1{\usename{new#1\aftercsname}}
\providerobust@def*\csnnewif{\LTS@csnalloc{if}}
\robust@def*\csnnewtoks{\LTS@csnalloc{toks}}
\robust@def*\csnnewcount{\LTS@csnalloc{count}}
\robust@def*\csnnewdimen{\LTS@csnalloc{dimen}}
\robust@def*\csnnewskip{\LTS@csnalloc{skip}}
\robust@def*\csnnewmuskip{\LTS@csnalloc{muskip}}
\robust@def*\csnnewbox{\LTS@csnalloc{box}}
\robust@def*\csnnewwrite{\LTS@csnalloc{write}}
\robust@def*\csnnewread{\LTS@csnalloc{read}}
\robust@def*\LTS@createtwincmds#1{%
  \begingroup\escapechar92\relax\expandafter\endgroup
  \if\expandafter\LTS@car\string#1x\car@nil\@backslashchar\else
    \LTS@err{Non-escaped command name '\detokenize{#1}'}\@ehc
  \fi
  \ifcsdefinable#1\relax
  \ifcsndefinable{No\cptremovescape{#1}}\relax
}
\robust@def*\CreateTwinBooleanCommands#1#2{%
  \LTS@createtwincmds{#1}%
  \ifcsndefinable{if\cptremovescape{#2}}{%
    \csnnewif{\cptremovescape{#2}}%
  }%
  \def#1{\gletcsntocs{if\cptremovescape{#2}}\iftrue}%
  \csn@def{No\cptremovescape{#1}}{%
    \gletcsntocs{if\cptremovescape{#2}}\iffalse
  }%
  \usename{No\cptremovescape{#1}}%
}
\robust@def*\CreateTwinSwitchCommands#1#2{%
  \LTS@createtwincmds{#1}%
  \def#1{\global\let#2\cptswtrue}%
  \csn@def{No\cptremovescape{#1}}{\global\let#2\cptswfalse}%
  \usename{No\cptremovescape{#1}}%
}
% Eg, \CreateTwinNumberCommands\StrictCheck\strict.
% This gives two commands:
%   \StrictCheck -> \strict=1
%   \NoStrictCheck -> \strict=0
\robust@def*\CreateTwinNumberCommands#1#2{%
  \LTS@createtwincmds{#1}%
  \def#1{\global\chardef#2\@ne}%
  \csn@def{No\cptremovescape{#1}}{\global\chardef#2\z@pt}%
  \usename{No\cptremovescape{#1}}%
}
\CreateTwinSwitchCommands\ExpandPrimitives\LTS@expprim
\CreateTwinSwitchCommands\WrapQuotes\LTS@wq
\CreateTwinSwitchCommands\ConvertInputToLowercase\LTS@lwc
\CreateTwinSwitchCommands\StrictHashCheck\stricthashcheck
\robust@def*\LTS@detok@zap#1{%
  \ltsensuremacro{#1}%
  \edef#1{\s@expandarg\cptzapspaces{\detokenize\expandafter{#1}}}%
}
\new@def*\LTS@global@or@relax{%
  \ifLTS@cl\let\glob@lrel@x\global\else\let\glob@lrel@x\relax\fi
}
\newletcs\glob@lrel@x\relax
\new@def*\LTS@long@or@relax{%
  \ifLTS@st\let\l@ngrel@x\relax\else\let\l@ngrel@x\long\fi
}
\robust@def*\ltssetupsafeactivesedef{%
  \let\ltssetupsafeactivesedef\relax
  \begingroup\begingroup
  \lccode`\Z=`\# %
  \lowercase{\endgroup
    \cpttfor Z!"$&'()*+,-./:;<=>?[]^_`|~\dofor{%
      \catcode`##1\string=\active
    }%
  }%
  \everyeof{\noexpand}%
  \begingroup
  \lccode`\Z=`\# %
  \lowercase{\endgroup
    \xdef\ltssafeactives
      {\scantokens{\unexpanded{Z!"$&'()*+,-./:;<=>?[]^_`|~}}}%
  }%
  \gdef\ltssafeactivesedef##1##2{%
    \begingroup
    \expandafter\cpttfor\ltssafeactives\dofor{%
      \ifnum\catcode`####1\string=\active\edef####1{\string####1}\fi
    }%
    \edef##1{##2}%
    \postgroupdef##1\endgroup
  }%
  \endgroup
}
\robust@def*\ltsreversetokens{\LTS@testst\LTS@reverse}
\new@def*\LTS@reverse#1#2{%
  \begingroup
  \def\LTS@tempa##1\reverse@nil{%
    \def\LTS@tempa####1####2{%
      \expandafter\ifxTF\cpt@car####2\car@nil
      \endreverse{####1}{\LTS@tempa{####2####1}}%
    }%
    \toks@\expandafter{\romannumeral0\LTS@tempa{}##1\@space\endreverse}%
  }%
  \ifLTS@st\expandafter\expandafter\fi
  \LTS@tempa#2\reverse@nil
  \cptexpandsecond\endgroup
    {\edef\noexpand#1{\noexpand\unexpanded{\the\toks@}}}%
}
\newletcs\endreverse\end
\new@def\directreverse#1{\LTS@directreverse{}#1\endreverse}
\new@def\LTS@directreverse#1#2{%
  \expandafter\ifxTF\cpt@car#2\car@nil\endreverse{%
    \if@test\expandafter\@iden\else\expandafter\unexpanded\fi{#1}%
  }{%
    \LTS@directreverse{#2#1}%
  }%
}
\new@def\robustreverse#1{\LTS@robustreverse{}.#1\endreverse}
\new@def\LTS@robustreverse#1#2\endreverse{%
  \LTS@r@bustreverse{#1}%
    {\expandafter\ifleftbracedTF\expandafter
    {\cpt@removetodot#2}}#2\endreverse
}
\new@def\LTS@r@bustreverse#1#2.#3{%
  \expandafter\ifxTF\cpt@car#3\car@nil\endreverse{%
    \if@test\expandafter\@iden\else\expandafter\unexpanded\fi{#1}%
  }{%
    #2{\LTS@robustreverse{{#3}#1}}{\LTS@robustreverse{#3#1}}.%
  }%
}
% Create a delimiter for command 'Rabfe' (which means 'remove all but
% first undelimited element'):
\robust@def*\DeclareRabfeDelimiter{\LTS@testst\LTS@DeclareRabfeDelimiter}
\robust@def*\LTS@DeclareRabfeDelimiter#1{%
  \ifLTS@st
    \long\def\ltsgetfirstelement##1##2#1{{##1}}%
  \else
    \long\def\ltsgetfirstelement##1##2#1{##1}%
  \fi
}
\DeclareRabfeDelimiter{\LTS@nil}
% One advantage of \removeallbutfirstelement is that delimiters
% (ie, sentinels) can be replicated in its argument.
% Eg, #1 with two delimiters:
%     \LTS@DeclareRabfeDelimiter\LTS@nil
%     \edef\x{\removeallbutfirstelement{xyz\LTS@nil\LTS@nil}}
\new@def\removeallbutfirstelement#1{%
  \romannumeral-`\q
  \expandafter\expandafter\expandafter\ifnullTF
  \expandafter\expandafter\expandafter{%
  \expandafter\@gobble\ltsgetfirstelement#1}{%
    \expandafter\@firstofone\expandafter{%
    \ltsgetfirstelement#1}%
  }{%
    \expandafter\expandafter\expandafter\@gobblefour
    \expandafter\removeallbutfirstelement
    \expandafter{\ltsgetfirstelement#1}%
  }%
}
\robust@def*\ltsremoveleadparser{\LTS@testopt\LTS@remleadparser{,}}
\new@def\LTS@remleadparser[#1]#2{%
  \ltsensuremacro{#2}%
  \begingroup
  \def\reserved@a#1{\futurelet\next\reserved@d}%
  \@namedef{reserved@b} {\reserved@a#1}%
  \def\reserved@d{%
    \ifx\next\@sptoken
      \expandafter\reserved@b
    \else
      \ifx#1\next
        \cptthreexp\reserved@a
      \else
        \cptthreexp\reserved@c
      \fi
    \fi
  }%
  \def\reserved@c##1\LTS@nil{\endgroup\edef#2{\unexpanded{##1}}}%
  \expandafter\reserved@a\expandafter#1#2\LTS@nil
}
\robust@def*\ltsremtrailparser{\LTS@testopt\LTS@remtrailparser{,}}
\robust@def*\LTS@remtrailparser[#1]#2{%
  \begingroup
  \ltsensuremacro{#2}%
  \defpass\LTS@rsvda{%
    \despacecontent#2%
    \xifinsetFT{#1&}{\expandcsonce#2&}{}{%
      \def\LTS@rsvdb####1#1&{%
        \edef#2{\unexpanded{####1}}%
        \LTS@rsvda
      }%
      \expandafter\LTS@rsvdb#2&%
    }%
  }%
  \postgroupdef#2\endgroup
}
\robust@def*\ltsremoveparser{\LTS@testopt\LTS@remparser{,}}
\robust@def*\LTS@remparser[#1]#2{%
  \LTS@remleadparser[#1]#2%
  \LTS@remtrailparser[#1]#2%
}
% We re-implement xkeyval's \@selective@sanitize to admit
% even \bgroup in the token list, and to remove some trivial
% steps:
\robust@def*\selectivesanitize{\LTS@testopt\LTS@selectivesanitize\@M}
\robust@def*\LTS@selectivesanitize[#1]#2#3{%
  \ltsensuremacro{#3}%
  \begingroup
  \cpt@cnta#1\advance\cpt@cnta\@ne
  \let\temp@bgroup\bgroup
  \let\bgroup\cpt@undefined
  \cptexpandsecond
    {\LTS@s@lectivesanitize#3}{{\detokenize{#2}}{\expandcsonce#3}}%
  \postgroupdef#3\endgroup
}
\robust@def*\LTS@s@lectivesanitize#1#2#3{%
  \def\LTS@i{\futurelet\next\LTS@ii}%
  \def\LTS@ii{%
    \expandafter\LTS@iii\meaning\next\LTS@nil
    \ifx\next\end
      \let\cmd\@gobbleone
    \else
      \ifx\next\@sptoken
        \edef#1{\expandcsonce#1\@space}%
        \lowercase{\def\cmd} {\LTS@i}%
      \else
        \let\cmd\LTS@iv
      \fi
    \fi
    \cmd
  }%
  \def\LTS@iii##1##2\LTS@nil{%
    \if##1\@backslashchar\let\next\relax\fi
  }%
  \def\LTS@iv##1{%
    \toks@\expandafter{#1}\toks1{##1}%
    \ifx\next\temp@bgroup
      \advance\cpt@cnta\m@one
      \ifnum\cpt@cnta>\z@pt
        \begingroup
        \cptexpandsecond\LTS@s@lectivesanitize
          {\noexpandcsn{\string#1}{#2}{\the\toks1}}%
        \edefpass#1{\endgroup\toks1{\expandcsnonce{\string#1}}}%
      \fi
      \edef#1{\the\toks@{\the\toks1}}%
      \advance\cpt@cnta\@ne
    \else
      \edef#1{\expandafter\string\the\toks1}%
      \expandafter\cpt@in\expandafter{#1}{#2}%
      \edef#1{\the\toks@\ifcpt@in#1\else\the\toks1\fi}%
    \fi
    \LTS@i
  }%
  \def#1{}\LTS@i#3\end
}
\robust@def*\ltschecksanitya#1#2{\ltschecksanity{,}{#1}#2}
\robust@def*\ltschecksanityb#1#2{\ltschecksanity{,.=}{#1}#2}
\robust@def*\ltschecksanityc#1#2{\ltschecksanity{,;}{#1}#2}
\robust@def*\ltschecksanityd#1#2{\ltschecksanity{,;:|-=}{#1}#2}
\robust@def*\ltschecksanity#1#2#3{%
  \cpt@checkfalse
  \def\tsv@do##1{%
    \ifboolTF{cpt@check}{}{%
      \LTS@ch@cksanity{##1}{#2}%
    }%
  }%
  \tsv@@parse{#1}%
  \ifboolTF{cpt@check}{%
    \edef#3{\unexpanded{#2}}%
    \selectivesanitize[1]{#1}#3%
  }{}%
}
\robust@def*\LTS@ch@cksanity#1#2{%
  \ifbelongFT{#1}{#2}{}{%
    \defpass\reserved@a##1#1##2\LTS@nil{%
      \ifblankTF{##2}{\cpt@checktrue\loopbreak}{}%
    }%
    #2#1\LTS@nil
  }%
}
\robust@def*\ltsensureothersanity#1#2{%
  \begingroup
  \edef#2{\unexpanded{#1}}%
  \LTS@scantoksb#2%
  \postgroupdef#2\endgroup
}
\robust@def*\ltsfiltermergecsv{%
  \begingroup
  \let\LTS@parse\csv@@parse
  \cpt@checkoptprefix
    {\LTS@teststplcl{\LTS@testopt\LTS@filtermergelists,}}%
}
\robust@def*\ltsfiltermergekv{%
  \begingroup
  \let\LTS@parse\kv@@parse
  \cpt@checkoptprefix
    {\LTS@teststplcl{\LTS@testopt\LTS@filtermergelists,}}%
}
\robust@def*\LTS@filtermergelists[#1]#2#3#4{%
  \edef\temp@do{\noexpandcsn{%
    \ifxTF\LTS@parse\csv@@parse{csv}{kv}@do}%
  }%
  \ifLTS@pl
    \ifcsndefTF{#2}{%
      \letcstocsn\LTS@tempa{#2}%
    }{%
      \def\LTS@tempa{}%
    }%
  \else
    \ifdefTF{#2}{%
      \let\LTS@tempa#2%
    }{%
      \def\LTS@tempa{}%
    }%
  \fi
  \cpt@stchoose{LTS@st}{#3}\LTS@tempb\LTS@filtermergelists
  \cptdeclarefilter{#4}%
  \cpt@useemptyfalse
  \def\LTS@tempf##1{\csliststack#1\LTS@tempa\unexpanded{##1}}%
  \expandafter\def\temp@do##1{%
    \edef\LTS@tempb{\unexpanded{##1}}%
    \cpt@swatrue
    \cpt@usefilter\LTS@tempb\LTS@tempc
    \let\LTS@tempd\LTS@tempa
    \def\LTS@tempa{}%
    \expandafter\def\temp@do####1{%
      \edef\LTS@tempd{\unexpanded{####1}}%
      \cpt@usefilter\LTS@tempd\LTS@tempe
      \ifx\LTS@tempc\LTS@tempe
        \cpt@swafalse
        \edef\LTS@tempa{\LTS@tempf{##1}}%
      \else
        \edef\LTS@tempa{\LTS@tempf{####1}}%
      \fi
    }%
    \ifcsnullTF\LTS@tempd{}{\LTS@parse*[#1]\LTS@tempd}%
    \ifdefboolFT{cpt@swa}{}{\edef\LTS@tempa{\LTS@tempf{##1}}}%
  }%
  \ifcsnullTF\LTS@tempb{}{%
    \ifcsnullTF\LTS@tempa{%
      \let\LTS@tempa\LTS@tempb
    }{%
      \LTS@parse*[#1]\LTS@tempb
    }%
  }%
  \cptpassexpanded{%
    \ifLTS@cl\global\fi
    \let\ifLTS@pl\cptmakecs{#2}\else\noexpand#2\fi
    \noexpand\LTS@tempa
  }%
  \ifboolTF{LTS@cl}\endgroup{%
    \ifboolTF{LTS@pl}{%
      \expandafter\postgroupdef\csname#2\endcsname\endgroup
    }{%
      \postgroupdef#2\endgroup
    }%
  }%
}
\robust@def*\ltsfiltermergecsva#1{%
  \begingroup
  \let\LTS@parse\csv@@parse
  \LTS@sttrue
  \LTS@ifstringcase{#1}%
    {fff}{\LTS@stfalse\LTS@plfalse\LTS@clfalse}%
    {tff}{\LTS@sttrue\LTS@plfalse\LTS@clfalse}%
    {ttf}{\LTS@sttrue\LTS@pltrue\LTS@clfalse}%
    {ttt}{\LTS@sttrue\LTS@pltrue\LTS@cltrue}%
    {ftt}{\LTS@stfalse\LTS@pltrue\LTS@cltrue}%
    {fft}{\LTS@stfalse\LTS@plfalse\LTS@cltrue}%
    {tft}{\LTS@sttrue\LTS@plfalse\LTS@cltrue}:%
    [\LTS@err{No match for \string\ltsfiltermergecsva}\@ehc]%
    \LTS@filtermergelists
}
\robust@def*\oneelementfiltermerge{%
  \LTS@teststcl{\LTS@testopt\LTS@oneelemfiltermerge,}%
}
\robust@def*\LTS@oneelemfiltermerge[#1]#2#3#4{%
  \begingroup
  \cpt@stchoose{LTS@st}{#3}\LTS@tempa\oneelementfiltermerge
  \cptdeclarefilter{#4}%
  \despacecontent\LTS@tempa
  \cpt@usefilter\LTS@tempa\LTS@tempb
  \ifdefTF#2{}{\def#2{}}%
  \oifinset@sp@TF#1\LTS@tempb#2{}{%
    \ifLTS@cl\global\fi
    \edef#2{\csliststack#1#2\expandcsonce\LTS@tempb}%
  }%
  \postgroupdef#2\endgroup
}
\robust@def*\ltsfiltermergetsv{\LTS@testcl\LTS@filtermergetokens}
\robust@def*\LTS@filtermergetokens#1#2#3{%
  \ifblankTF{#1}{%
    \LTS@err{Invalid blank first argument of
      \string\ltsfiltermergetsv}\@ehc
  }{%
    \if\detokenize{#1[}%
      \LTS@err{Command \noexpand\ltsfiltermergetsv expects
        no parser}\@ehc
    \fi
  }%
  \begingroup
  \let\ifLTS@mergecl\ifLTS@cl
  \cptdeclarefilter{#3}%
  \ifdefTF{#1}{}{\def#1{}}%
  \def\tsv@do##1{%
    \def\LTS@tempa{##1}%
    \cpt@swatrue
    \cpt@usefilter\LTS@tempa\LTS@tempb
    \def\tsv@do####1{%
      \def\LTS@tempc{####1}%
      \cpt@usefilter\LTS@tempc\LTS@tempd
      \ifx\LTS@tempb\LTS@tempd
        \cpt@swafalse
        \edef#1{\expandcsonce#1\expandcsonce\LTS@tempa}%
      \else
        \edef#1{\expandcsonce#1\expandcsonce\LTS@tempc}%
      \fi
    }%
    \cptexpandargonce{\def#1{}\tsv@@parse}{#1}%
    \ifcpt@swa
      \edef#1{\expandcsonce#1\expandcsonce\LTS@tempa}%
    \fi
  }%
  \ifblankTF{#2}{}{%
    \ifcsnullTF#1{%
      \edef#1{\unexpanded{#2}}%
    }{%
      \tsv@@parse{#2}%
    }%
  }%
  \ifLTS@mergecl
    \globalize#1\endgroup
  \else
    \cptpassacross#1\endgroup
  \fi
}
\robust@def*\ltsfilterremovecsv{%
  \begingroup
  \let\LTS@parse\csv@@parse
  \cpt@checkoptprefix
    {\LTS@teststplcl{\LTS@testopt\LTS@filterremoveelements{,}}}%
}
\robust@def*\ltsfilterremovekv{%
  \begingroup
  \let\LTS@parse\kv@@parse
  \cpt@checkoptprefix
    {\LTS@teststplcl{\LTS@testopt\LTS@filterremoveelements{,}}}%
}
\robust@def*\LTS@filterremoveelements[#1]#2#3#4{%
  \cpt@checklistparser{#1}\relax
  \begingroup
  \edef\temp@do
    {\noexpandcsn{\ifxTF\LTS@parse\csv@@parse{csv}{kv}@do}}%
  \letcstocsn\LTS@normalize
    {cpt@\ifxTF\LTS@parse\csv@@parse{csv}{kv}normalize}%
  \ifLTS@pl
    \ifcsndefTF{#2}{}{\cptemptifycsn{#2}}%
    \letcstocsn\LTS@tempa{#2}%
  \else
    \ifdefTF{#2}{}{\def#2{}}%
    \let\LTS@tempa#2%
  \fi
  \cpt@stchoose{LTS@st}{#3}\LTS@tempb\LTS@filterremoveelements
  \ifcsnullTF\LTS@tempb{}
    {\cpt@sttrue\LTS@normalize[#1]\LTS@tempb}%
  \cptdeclarefilter{#4}%
  \def\LTS@tempd{}%
  \expandafter\def\temp@do##1{%
    \edef\LTS@tempa{\unexpanded{##1}}%
    \cpt@usefilter\LTS@tempa\LTS@tempc
    \oifinset@sp@TF#1\LTS@tempc\LTS@tempb{}{%
      \edef\LTS@tempd{\csliststack#1\LTS@tempd\unexpanded{##1}}%
    }%
  }%
  \ifcsnullTF\LTS@tempa{}{\LTS@parse*[#1]\LTS@tempa}%
  \cptpassexpanded{%
    \ifLTS@cl\global\fi
    \let\ifLTS@pl\cptmakecs{#2}\else\noexpand#2\fi
    \noexpand\LTS@tempd
  }%
  \ifboolTF{LTS@cl}\endgroup{\postgroupdef#2\endgroup}%
}
\robust@def*\ltspurgeelements{%
  \LTS@testst{%
    \let\ifLTS@purgest\ifLTS@st
    \begingroup
    \@makeother{\#}%
    \LTS@testopt{\expandafter\endgroup\LTS@p@rgeelements}{,}%
  }%
}
\robust@def*\LTS@purgeelements{%
  \LTS@err{Use \noexpand\ltspurgeelements instead}\@ehc
}
\robust@def*\LTS@p@rgeelements[#1]#2#3{%
  \cpt@checklistparser{#1}\relax
  \begingroup
  \def\csv@do##1{%
    \ifblankTF{##1}{}{%
      \def\LTS@tempb####1#1##1#1####2\LTS@nil{####1#1####2\purge@nil}%
      \def\LTS@tempc####1#1\purge@nil####2\purge@nil{%
        \ifx#1####1\@empty\else####1\fi
      }%
      \def\LTS@tempa{%
        \cptthreexp\LTS@tempc\expandafter\LTS@tempb\expandafter
        #1\detokenize\expandafter{#3}#1\purge@nil#1##1#1\LTS@nil
      }%
      \expandafter\edef\expandafter#3\expandafter{\LTS@tempa}%
    }%
  }%
  \ifblankTF{#2}{}{\cptexpandarg{\csv@@loop[#1]}{\detokenize{#2}}}%
  \postgroupdef#3\endgroup
  \LTS@remparser[#1]#3%
  \ifboolTF{LTS@purgest}{}{\LTS@scantoks@hash#3}%
  \undefcs\ifLTS@purgest
}
\robust@def*\ltsfilterdeletetokens{\LTS@teststcl\LTS@deletetokens}
\robust@def*\LTS@deletetokens#1#2#3{%
  \let\ifLTS@fdelcl\ifLTS@cl
  \begingroup
  \cptdeclarefilter{#3}%
  \def\siso@do##1{%
    \edef\LTS@tempa{\unexpanded{##1}}%
    \cpt@usefilter\LTS@tempa\LTS@tempc
    \edef\LTS@tempa{\expandcsonce\LTS@tempc}%
    \cptexpandsecond{%
    \def\LTS@tempb####1}{\expandcsonce\LTS@tempa}####2####3\LTS@nil{%
      \edef\LTS@tempb{\unexpanded{####2}}%
      \ifxTF\LTS@nnil\LTS@tempb{}{%
        \cptexpandsecond{\def\LTS@tempb########1}{%
        \expandcsonce\LTS@tempa}########2\LTS@nil{%
          \edef#1{\unexpanded{########1########2}}%
        }%
        \expandafter\LTS@tempb#1\LTS@nil
      }%
    }%
    \cptexpandsecond\LTS@tempb
      {\expandcsonce#1\expandcsonce\LTS@tempa}{\LTS@nil}\LTS@nil
  }%
  \ifboolTF{LTS@st}{%
    \expandafter\siso@@loop\expandafter{#2}%
  }{%
    \siso@@loop{#2}%
  }%
  \postgroupdef#1\endgroup
  \ifLTS@fdelcl\globalize#1\fi
  \undefcs\ifLTS@fdelcl
}
\robust@def*\simpledeletetokens#1#2{%
  \def\siso@do##1{%
    \def\LTS@tempa####1##1####2####3\LTS@nil{%
      \edef\LTS@tempa{\unexpanded{####2}}%
      \ifx\LTS@nnil\LTS@tempa\else
        \def\LTS@tempa########1##1########2\LTS@nil{%
          \edef#1{\unexpanded{########1########2}}%
        }%
        \expandafter\LTS@tempa#1\LTS@nil
      \fi
    }%
    \expandafter\LTS@tempa#1##1{\LTS@nil}\LTS@nil
  }%
  \expandafter\siso@@loop\expandafter{#2}%
}
\robust@def*\DeclareVerbatimDelimiter#1{%
	\ifsingletokenFT{#1}{%
		\LTS@err{Verbatim delimiter isn't a single token}\@ehc
	}{%
    \def\LTS@v@rbatimstore##1#1##2#1{%
      \endgroup
      \LTS@v@rb@timstore{##2}%
    }%
  }%
}
\robust@def*\LTS@v@rb@timst@re{%
	\begingroup
	\@sanitize\obeyspaces
	\LTS@v@rbatimstore
}
\robust@def*\verbatimstore#1{%
	\long\def\LTS@v@rb@timstore##1{\def#1{##1}}%
	\LTS@v@rb@timst@re
}
\robust@def*\ltsretokenize{\LTS@testst\LTS@retokenize}
\robust@def\LTS@retokenize#1#2{%
	\begingroup
	\edef\LTS@tempa{\unexpanded{#2}}%
  \ifLTS@st
    \def\LTS@ret@kenize##1\LTS@nil{\protected@edef#1{##1}}%
  \else
    \def\LTS@ret@kenize##1\LTS@nil{\edef#1{\unexpanded{##1}}}%
  \fi
	\cpteveryscan
  \everyeof{\LTS@nil}%
	\expandafter\LTS@ret@kenize\scantokens\expandafter{\LTS@tempa}%
  \relax\postgroupdef#1\endgroup
}
\robust@def*\LTS@scantoksa#1{%
  \begingroup
  \edef#1{\long\def\string#1{\detokenize\expandafter{#1}}}%
  \cpteveryscan
  \scantokens\expandafter{#1}\relax
  \postgroupdef#1\endgroup
}
\robust@def*\LTS@scantoks@hash#1{%
  \begingroup
  \edef#1{\long\def\string#1{\detokenize\expandafter{#1}}}%
  \catcode`\#=6\relax\cpteveryscan
  \scantokens\expandafter{#1}\relax
  \postgroupdef#1\endgroup
}
\robust@def*\LTS@scantoksb#1{%
  \begingroup
  \def\siso@do##1{\catcode`##1\string=12\relax}%
  \siso@@loop{=,;|-+?><}%
  \LTS@scantoksa#1%
  \postgroupdef#1\endgroup
}
\robust@def*\LTS@scantoksc{\LTS@testplcl\LTS@sc@ntoksc}
\robust@def\LTS@sc@ntoksc#1{%
  \cptdocommalist{#1}{%
    \ifboolTF{LTS@pl}{%
      \expandafter\ltsensuremacro\csname ##1\endcsname
      \letcstocsn\reserved@e{##1}%
    }{%
      \ltsensuremacro{##1}%
      \let\reserved@e##1%
    }%
    \LTS@scantoksa\reserved@e
    \cptpassexpanded{%
      \ifLTS@cl\global\fi\let\ifLTS@pl
      \cptmakecs{##1}\else\unexpanded{##1}\fi
      \noexpand\reserved@e
    }%
  }%
}
\robust@def*\LTS@scantoksd#1#2{%
  \cptexpandsecond{#1\cpteveryscan\scantokens}{%
    {#2}%
    \everyeof{\the\everyeof}%
    \noexpand\endlinechar\the\endlinechar\relax
    \catcode`\noexpand\@=\the\catcode`\@\relax
    \catcode`\noexpand\ =\the\catcode`\ \relax
    \catcode`\noexpand\\=\the\catcode`\\\relax
    \catcode`\noexpand\{=\the\catcode`\{\relax
    \catcode`\noexpand\}=\the\catcode`\}\relax
  }%
}
\providecommand*\newbool{\ltsnewbool}
\providecommand*\setbool{\ltssetbool}
\providecommand*\booltrue{\ltsbooltrue}
\providecommand*\boolfalse{\ltsboolfalse}
\providecommand*\setbooltrue{\ltssetbooltrue}
\providecommand*\setboolfalse{\ltssetboolfalse}
\robust@def*\ltsnewbool#1{\cpt@swatrue\LTS@testopt{\LTS@newbool{#1}}{false}}
\robust@def*\defbool#1{\cpt@swafalse\LTS@testopt{\LTS@newbool{#1}}{false}}
\new@def*\LTS@newbool#1[#2]{%
  \ifinsetFT{,}{#1}{}{%
    \begingroup
    \edef\LTS@tempa{\ifcpt@swa'\string\ltsnewbool'
      \else'\string\ltsdefbool'\fi}%
    \edef\LTS@tempb{\ifcpt@swa'\string\NewBooleans'
      \else'\string\DefBooleans'\fi}%
    \LTS@err{Command \LTS@tempa\@space doesn't accept list}%
      {Please submit only one boolean to \LTS@tempa\MsgBrk
      at a time. You may consider using\LTS@tempb\MsgBrk
      if you really want to define a set of booleans.}%
    \endgroup
  }%
  \ltsensurenoscape{#1}%
  \LTS@badboolname{#1}%
  \ifboolTF{cpt@swa}{%
    \ifcsndefinable{if#1}\relax
    \LTS@getboolstate\ltsnewbool{#2}%
  }{%
    \ifcsndefFT{if#1}{}{%
      \LTS@verbosewarn{Boolean '\@backslashchar if#1' redefined}%
    }%
    \LTS@getboolstate\ltsdefbool{#2}%
  }%
  \csnnewif{#1}%
  \usename{#1\LTS@boolval}%
}
\robust@def*\NewBooleans{\cpt@swatrue\LTS@testopt\LTS@NewBooleans{}}
\robust@def*\DefBooleans{\cpt@swafalse\LTS@testopt\LTS@NewBooleans{}}
\robust@def*\LTS@NewBooleans[#1]#2{%
  \LTS@testopt{\LTS@B@oleans{#1}{#2}}{false}%
}
\new@def*\LTS@B@oleans#1#2[#3]{%
  \cptexpandsecond\LTS@getboolstate
    {\ifboolTF{cpt@swa}\NewBooleans\DefBooleans}{#3}%
  \cptdocommalist{#2}{%
    \ltsensurenoscape{##1}%
    \LTS@badboolname{#1##1}%
    \ifboolTF{cpt@swa}{%
      \ifcsndefinable{if#1##1}\relax
    }{%
      \ifcsndefFT{if#1##1}{}{%
        \LTS@verbosewarn{Boolean '\@backslashchar if#1##1'
          redefined}%
      }%
    }%
    \csnnewif{#1##1}%
    \usename{#1##1\LTS@boolval}%
  }%
}
\robust@def*\ltssetbool#1#2{%
  \ifcsndefFT{if#1}{%
    \LTS@noboolerr{#1}%
  }{%
    \LTS@getboolstate\ltssetbool{#2}%
    \csname#1\LTS@boolval\endcsname
  }%
}
\robust@def*\ltssetbooltrue#1{%
  \ifcsndefFT{if#1}{\LTS@noboolerr{#1}}{\usename{#1true}}%
}
\newletcs\ltsbooltrue\ltssetbooltrue
\robust@def*\ltssetboolfalse#1{%
  \ifcsndefFT{if#1}{\LTS@noboolerr{#1}}{\usename{#1false}}%
}
\newletcs\ltsboolfalse\ltssetboolfalse
\robust@def*\LTS@noboolerr#1{%
  \LTS@err{Boolean/switch '\string#1' is undefined}%
  {You need to first define the boolean/switch '\string#1'.}%
}
\robust@def*\LTS@boolnameerr#1{%
  \LTS@err{'\string\if#1' not valid as a boolean/switch}%
  {Invalid boolean/switch name '\string#1'.}%
}
\new@def*\LTS@boolvalerr#1#2{%
  \LTS@err{Invalid boolean/switch value '#2' in \string#1}%
    {Valid boolean/switch values are \LTS@validboolvalues.}%
}
\new@def*\LTS@validboolvalues{true,false}
\robust@def*\AddValidBooleanValues#1{%
  \ltsfiltermergecsv![,]\LTS@validboolvalues{#1}\nofilter
}
\robust@def*\RemoveValidBooleanValues#1{%
  \ltsfilterremovecsv!\LTS@validboolvalues{#1}\nofilter
}
\robust@def*\LTS@getboolstate#1#2{%
  \lowercase{%
    \edef\LTS@boolval{\cpttrimspaces{#2}}%
  }%
  \xifinsetTF{,\LTS@boolval,}{,\LTS@validboolvalues,}{}{%
    \LTS@boolvalerr{#1}{#2}%
  }%
}
\robust@def*\LTS@badboolname#1{%
  \begingroup
  \xifstrcmpTF{\expandafter\LTS@cartwo\string#1xx\car@nil}{if}{%
    \LTS@boolnameerr{if}%
  }{%
    \edef\LTS@tempa{\s@expandarg\cpttrimspaces{\cptrm-`\q#1}}%
    \cptexpandsecondonce{\def\reserved@a##1,}\LTS@tempa,##2\LTS@nil{%
      \ifblankTF{##2}{}{\s@expandarg\LTS@boolnameerr\LTS@tempa}%
    }%
    \reserved@a ,x,on,off,tog,bool,switch,#1,\LTS@nil
  }%
  \endgroup
}
\providecommand*\newswitch[1]{\cpt@swatrue\LTS@testopt{\LTS@newswitch#1}{false}}
\robust@def*\defswitch#1{\cpt@swafalse\LTS@testopt{\LTS@newswitch#1}{false}}
\robust@def*\LTS@newswitch#1[#2]{%
  \ifinsetFT{,}{#1}{}{%
    \begingroup
    \edef\LTS@tempa{\ifcpt@swa'\string\newswitch'
      \else'\string\defswitch'\fi}%
    \edef\LTS@tempb{\ifcpt@swa'\string\NewSwitches'
      \else'\string\DefSwitches'\fi}%
    \LTS@err{Command \LTS@tempa\@space doesn't accept list}%
      {Please submit only one switch to \LTS@tempa\MsgBrk
      at a time. You may consider using\LTS@tempb\MsgBrk
      if you really want to define a set of switches.}%
    \endgroup
  }%
  \ltsensurenoscape{#1}%
  \LTS@badboolname{#1}%
  \ifboolTF{cpt@swa}{%
    \ifcsndefinable{#1}\relax
    \LTS@getboolstate\newswitch{#2}%
  }{%
    \ifcsndefFT{#1}{}{%
      \LTS@verbosewarn{Switch '\@backslashchar#1' redefined}%
    }%
    \LTS@getboolstate\defswitch{#2}%
  }%
  \letcsntocsn{#1}{cpt\LTS@boolval}%
}
\robust@def*\makenewswitches{\LTS@testopt\LTS@makenewswitch{}}
\newletcs\makenewswitch\makenewswitches
\robust@def*\LTS@makenewswitch[#1]#2{%
  \LTS@testopt{\LTS@m@kenewswitch{#1}{#2}}{false}%
}
\def\LTS@m@kenewswitch#1#2[#3]{%
  \LTS@getboolstate\makenewswitches{#3}%
  \cptdocommalist{#2}{%
    \ifcsndefTF{ifsw#1##1}{%
      \LTS@err{Switch '#1##1' already exists}\@ehc
    }{%
      \csn@edef{ifsw#1##1}{%
        \noexpand\if\s@expandarg\ifstrcmpTF\LTS@boolval{true}{00}{01}%
      }%
      \csn@def{sw#1##1true}{\csn@def{ifsw#1##1}{\if00}}%
      \csn@def{sw#1##1false}{\csn@def{ifsw#1##1}{\if01}}%
    }%
  }%
}
\robust@def*\NewSwitches{\cpt@swatrue\LTS@testopt\LTS@NewSwitches{}}
\robust@def*\DefSwitches{\cpt@swafalse\LTS@testopt\LTS@NewSwitches{}}
\robust@def*\LTS@NewSwitches[#1]#2{%
  \LTS@testopt{\LTS@Sw@tches{#1}{#2}}{false}%
}
\new@def*\LTS@Sw@tches#1#2[#3]{%
  \cptexpandsecond\LTS@getboolstate
    {\ifboolTF{cpt@swa}\NewSwitches\DefSwitches}{#3}%
  \cptdocommalist{#2}{%
    \ltsensurenoscape{##1}%
    \LTS@badboolname{#1##1}%
    \ifboolTF{cpt@swa}{%
      \ifcsndefinable{#1##1}\relax
    }{%
      \ifcsndefFT{#1##1}{}{%
        \LTS@verbosewarn{Switch '\@backslashchar#1##1' redefined}%
      }%
    }%
    \letcsntocsn{#1##1}{cptsw\LTS@boolval}%
  }%
}
\robust@def*\NewTogs{\cpt@swatrue\LTS@testopt\LTS@NewTogs{}}
\robust@def*\DefTogs{\cpt@swafalse\LTS@testopt\LTS@NewTogs{}}
\new@def*\LTS@NewTogs[#1]#2{\LTS@testopt{\LTS@NewT@gs[#1]{#2}}{false}}
\new@def*\LTS@NewT@gs[#1]#2[#3]{%
  \cptexpandsecond\LTS@getboolstate
    {\ifcpt@swa\NewTogs\else\DefTogs\fi}{#3}%
  \cptdocommalist{#2}{%
    \ltsensurenoscape{##1}%
    \cptpassexpanded{\ifcpt@swa\newtog\else\deftog\fi}{#1##1}%
    \usename{settog\LTS@boolval}{#1##1}%
  }%
}
\robust@def*\NewToks{\cpt@swatrue\LTS@testopt\LTS@NewToks{}}
\robust@def*\DefToks{\cpt@swafalse\LTS@testopt\LTS@NewToks{}}
\new@def*\LTS@NewToks[#1]#2{%
  \cptdocommalist{#2}{%
    \ltsensurenoscape{##1}%
    \ifboolTF{cpt@swa}{%
      \ifcsndefinable{#1##1}\relax
    }{%
      \ifcsndefFT{#1##1}{}{%
        \LTS@verbosewarn{Token register '\@backslashchar
          #1##1' redefined}%
      }%
    }%
    \csnnewtoks{#1##1}%
  }%
}
\robust@def*\NewCounts{\cpt@swatrue\LTS@testopt\LTS@NewCounts{}}
\robust@def*\DefCounts{\cpt@swafalse\LTS@testopt\LTS@NewCounts{}}
\new@def*\LTS@NewCounts[#1]#2{\LTS@testopt{\LTS@N@wCounts[#1]#2}{}}
\new@def*\LTS@N@wCounts[#1]#2[#3]{%
  \cptdocommalist{#2}{%
    \ltsensurenoscape{##1}%
    \ifboolTF{cpt@swa}{%
      \ifcsndefinable{#1##1#3}\relax
    }{%
      \ifcsndefFT{#1##1#3}{}{%
        \LTS@verbosewarn{Counter register '\@backslashchar
          #1##1#3' redefined}%
      }%
    }%
    \csnnewcount{#1##1#3}%
  }%
}
\robust@def*\NewCounters{\cpt@swatrue\LTS@testopt\LTS@NewCounters{}}
\robust@def*\DefCounters{\cpt@swafalse\LTS@testopt\LTS@NewCounters{}}
\new@def*\LTS@NewCounters[#1]#2{\LTS@testopt{\LTS@N@wCounters[#1]#2}{}}
\new@def*\LTS@N@wCounters[#1]#2[#3]{%
  \cptdocommalist{#2}{%
    \ltsensurenoscape{##1}%
    \ifboolTF{cpt@swa}{%
      \ifcsndefinable{#1##1#3}\relax
    }{%
      \ifcsndefFT{#1##1#3}{}{%
        \LTS@verbosewarn{Counter register '\@backslashchar
          #1##1#3' redefined}%
      }%
    }%
    \@definecounter{#1##1#3}%
  }%
}
\newletcs\NewNumbers\NewCounters
\robust@def*\NewDimens{\cpt@swatrue\LTS@testopt\LTS@NewDimens{}}
\robust@def*\DefDimens{\cpt@swafalse\LTS@testopt\LTS@NewDimens{}}
\new@def*\LTS@NewDimens[#1]#2{%
  \cptdocommalist{#2}{%
    \ltsensurenoscape{##1}%
    \ifboolTF{cpt@swa}{%
      \ifcsndefinable{#1##1}\relax
    }{%
      \ifcsndefFT{#1##1}{}{%
        \LTS@verbosewarn{Dimension register '\@backslashchar
          #1##1' redefined}%
      }%
    }%
    \csnnewdimen{#1##1}%
  }%
}
\robust@def*\NewBoxes{\cpt@swatrue\LTS@testopt\LTS@NewBoxes{}}
\robust@def*\DefBoxes{\cpt@swafalse\LTS@testopt\LTS@NewBoxes{}}
\new@def*\LTS@NewBoxes[#1]#2{%
  \cptdocommalist{#2}{%
    \ltsensurenoscape{##1}%
    \ifboolTF{cpt@swa}{%
      \ifcsndefinable{#1##1}\relax
    }{%
      \ifcsndefFT{#1##1}{}{%
        \LTS@verbosewarn{Box register '\@backslashchar
          #1##1' redefined}%
      }%
    }%
    \csnnewbox{#1##1}%
  }%
}
\robust@def*\NewSkips{\cpt@swatrue\LTS@testopt\LTS@NewSkips{}}
\robust@def*\DefSkips{\cpt@swafalse\LTS@testopt\LTS@NewSkips{}}
\new@def*\LTS@NewSkips[#1]#2{%
  \cptdocommalist{#2}{%
    \ltsensurenoscape{##1}%
    \ifboolTF{cpt@swa}{%
      \ifcsndefinable{#1##1}\relax
    }{%
      \ifcsndefFT{#1##1}{}{%
        \LTS@verbosewarn{Skip register '\@backslashchar
          #1##1' redefined}%
      }%
    }%
    \csnnewskip{#1##1}%
  }%
}
\newletcs\NewLengths\NewSkips
\newletcs\DefLengths\DefSkips
\robust@def*\NewMuskips{\cpt@swatrue\LTS@testopt\LTS@NewMuskips{}}
\robust@def*\DefMuskips{\cpt@swafalse\LTS@testopt\LTS@NewMuskips{}}
\new@def*\LTS@NewMuskips[#1]#2{%
  \cptdocommalist{#2}{%
    \ltsensurenoscape{##1}%
    \ifboolTF{cpt@swa}{%
      \ifcsndefinable{#1##1}\relax
    }{%
      \ifcsndefFT{#1##1}{}{%
        \LTS@verbosewarn{\noexpand\muskip register '\@backslashchar
          #1##1' redefined}%
      }%
    }%
    \csnnewmuskip{#1##1}%
  }%
}
\robust@def*\NewWrites{\cpt@swatrue\LTS@testopt\LTS@NewWrites{}}
\robust@def*\DefWrites{\cpt@swafalse\LTS@testopt\LTS@NewWrites{}}
\new@def*\LTS@NewWrites[#1]#2{%
  \cptdocommalist{#2}{%
    \ltsensurenoscape{##1}%
    \ifboolTF{cpt@swa}{%
      \ifcsndefinable{#1##1}\relax
    }{%
      \ifcsndefFT{#1##1}{}{%
        \LTS@verbosewarn{Write stream '\@backslashchar
          #1##1' redefined}%
      }%
    }%
    \csnnewwrite{#1##1}%
  }%
}
\robust@def*\NewReads{\cpt@swatrue\LTS@testopt\LTS@NewReads{}}
\robust@def*\DefReads{\cpt@swafalse\LTS@testopt\LTS@NewReads{}}
\new@def*\LTS@NewReads[#1]#2{%
  \cptdocommalist{#2}{%
    \ltsensurenoscape{##1}%
    \ifboolTF{cpt@swa}{%
      \ifcsndefinable{#1##1}\relax
    }{%
      \ifcsndefFT{#1##1}{}{%
        \LTS@verbosewarn{Read stream '\@backslashchar
          #1##1' redefined}%
      }%
    }%
    \csnnewread{#1##1}%
  }%
}
\robust@def*\checknewcommands{%
  \cpt@checkoptprefix{\LTS@teststpl\LTS@checknewcmds}%
}
\new@def*\LTS@checknewcmds#1{%
  \begingroup
  \edef\LTS@tempa{\ifLTS@st*\fi}%
  \def\csv@do##1{%
    \usename{ifcs\ifLTS@pl n\fi definable}{##1}\relax
  }%
  \expandafter\csv@@parse\LTS@tempa[,]{#1}%
  \endgroup
}
\new@def*\LTS@post@prefixerr#1{%
  \LTS@err{Bad prefixes for command '\string#1'}
    {You have wrongly prefixed command '\string#1'\MsgBrk
    with both star sign and exclamation mark.\MsgBrk
    You have to choose one of them. The star expands\MsgBrk
    the arguments once, while the exclamation mark\MsgBrk
    expands the arguments fully.}%
}
\robust@def*\postgroup{\LTS@teststcl\LTS@postgroup}
\new@def\LTS@postgroup#1{%
  \ifLTS@st
    \ifLTS@cl
      \LTS@post@prefixerr\postgroup
    \else
      \edef\LTS@tempa{\unexpanded{#1}}%
      \expandallonce\LTS@tempa
    \fi
  \else
    \ifLTS@cl
      \if\detokenize{#1*}%
        \LTS@post@prefixerr\postgroup
      \fi
      \let\next\@firstofone
    \else
      \let\next\unexpanded
    \fi
  \fi
  \advance\@tempcnta\@ne
  \csn@xdef{LTS@aft@rgroup@\romannumeral\@tempcnta}{%
    \gundefcsn{LTS@aft@rgroup@\romannumeral\@tempcnta}%
    \ifboolTF{LTS@st}{\@firstofone\LTS@tempa\@gobble}\next{#1}%
  }%
  \csnaftergroup{LTS@aft@rgroup@\romannumeral\@tempcnta}%
}
\robust@def*\minorpostgroup{\LTS@testst\LTS@minorpostgroup}
\new@def\LTS@minorpostgroup#1{%
  \advance\@tempcnta\@ne
  \csn@xdef{LTS@aft@rgroup@\romannumeral\@tempcnta}{%
    \gundefcsn{LTS@aft@rgroup@\romannumeral\@tempcnta}%
    \ifboolTF{LTS@st}\@firstofone\unexpanded{#1}%
  }%
  \csnaftergroup{LTS@aft@rgroup@\romannumeral\@tempcnta}%
}
\robust@def*\postassignment{\LTS@teststcl\LTS@postassignment}
\robust@def\LTS@postassignment#1{%
  \begingroup
  \ifboolTF{LTS@st}{%
    \ifboolTF{LTS@cl}{%
      \LTS@post@prefixerr\postassignment
    }{%
      \edef\LTS@tempa{\unexpanded{#1}}%
      \expandallonce\LTS@tempa
    }%
  }{%
    \ifboolTF{LTS@cl}{%
      \if\detokenize{#1*}%
        \LTS@post@prefixerr\postassignment
      \fi
      \let\next\@firstofone
    }{%
      \let\next\unexpanded
    }%
  }%
  \advance\@tempcnta\@ne
  \csn@xdef{LTS@p@stassignment@\romannumeral\@tempcnta}{%
    \gundefcsn{LTS@p@stassignment@\romannumeral\@tempcnta}%
    \ifboolTF{LTS@st}{\@firstofone\LTS@tempa\@gobble}\next{#1}%
  }%
  \aftercsname{\endgroup\afterassignment}
    {LTS@p@stassignment@\romannumeral\@tempcnta}%
}
\robust@def*\minorpostassignment{\LTS@testst\LTS@minorpostassignment}
\robust@def\LTS@minorpostassignment#1{%
  \begingroup
  \advance\@tempcnta\@ne
  \csn@xdef{LTS@p@stassignment@\romannumeral\@tempcnta}{%
    \gundefcsn{LTS@p@stassignment@\romannumeral\@tempcnta}%
    \ifdefboolTF{LTS@st}\@iden\unexpanded{#1}%
  }%
  \aftercsname{\endgroup\afterassignment}
    {LTS@p@stassignment@\romannumeral\@tempcnta}%
}
\robust@def*\LTS@undef{\LTS@testcl\LTS@und@f}
\new@def*\LTS@und@f#1{%
  \LTS@global@or@relax
  \cptfor#1\dofor{%
    \ifsingletoken@sp@TF{##1}{%
      \ltsensurescape{##1}%
      \glob@lrel@x\undefcs##1%
    }{%
      \cpt@notonetokenerr{##1}%
    }%
  }%
}
\newletcs\undefcslist\undefcsset
\robust@def*\ltsundefcslist{%
  \cpt@checkoptprefix{\LTS@teststplcl{\cpt@testopt\LTS@undefcslist{,}}}%
}
\new@def*\LTS@undefcslist[#1]#2{%
  \LTS@global@or@relax
  \edef\reserved@a{\ifLTS@st*\fi}%
  \def\csv@do##1{%
    \ifLTS@pl
      \glob@lrel@x\undefcsn{##1}%
    \else
      \glob@lrel@x\undefcs##1%
    \fi
  }%
  \expandafter\csv@@parse\reserved@a[#1]{#2}%
}
\robust@def*\declarepackagecmd{\LTS@testopt\LTS@declarepkgcmd{}}
\new@def\LTS@declarepkgcmd[#1]#2{%
  \ltsensurescape{#2}%
  \ifdefTF#2{%
    \letcsntocs{Saved\cptremovescape#2}#2%
    \cptpassexpanded{%
      \AtTagEndPackage{%
        \let\noexpand#2\noexpandcsn{Saved\cptremovescape#2}%
        \gundefcs\noexpandcsn{Saved\cptremovescape#2}%
      }%
    }%
  }{%
    \AtTagEndPackage{\gundefcs#2}%
  }%
  #1\def#2%
}
\robust@def*\declaredocumentcmd{\LTS@testopt\LTS@declaredoccmd{}}
\new@def\LTS@declaredoccmd[#1]#2{%
  \ltsensurescape{#2}%
  \ifcsdefinable#2\relax
  \ifinstylefileTF{%
    \cptpassexpanded{%
      \ltsAtBeginDocument{%
        \let\noexpand#2\noexpandcsn{Saved\cptremovescape#2}%
        \gundefcs\noexpandcsn{Saved\cptremovescape#2}%
      }%
    }%
    \postassignment{%
      \letcsntocs{Saved\cptremovescape#2}#2%
      \gundefcs#2%
    }%
  }{}%
  #1\def#2%
}
\robust@def*\LTS@providedef{\LTS@teststcl{\LTS@pr@videdef\relax}}
\robust@def*\LTS@providerobustdef{\LTS@teststcl{\LTS@pr@videdef\protected}}
\new@def\LTS@pr@videdef#1#2{%
  \LTS@long@or@relax\LTS@global@or@relax
  \ltsensurescape{#2}%
  \ifdefTF#2{%
    \LTS@verboseinfo{Command '\string#2' already defined:
      \MsgBrk Not redefined}%
    \minorpostassignment{\gundefcs\pr@v@de}%
  }{%
    \minorpostassignment{%
      \gletcs#2\pr@v@de
      \gletcsntocs{LTS@test@\cptremovescape#2}#2%
      \gundefcs\pr@v@de
    }%
  }%
  \glob@lrel@x\l@ngrel@x#1\def\pr@v@de
}
\new@def\testprovidedcommand#1{%
  \ltsensurescape{#1}%
  \begingroup
  \ifmacroFT#1{%
    \aftergroup\@secondoftwo
  }{%
    \csnaftergroup{LTS@\cptthreexp
      \ifxTF\usename{LTS@test@\cptremovescape#1}#112of2}%
  }%
  \endgroup
}
\robust@def*\LTS@reviewcommandhandler#1{%
  \LTS@verboseinfo{%
    Previously 'provided' definition of '\string#1'\MsgBrk
    is retained. Your new definition was ignored\MsgBrk
  }%
}
\robust@def*\reviewcommand{\LTS@testopt\LTS@revcommand{}}
\new@def\LTS@revcommand[#1]#2#3{%
  \testprovidedcommand#2{%
    \LTS@reviewcommandhandler{#2}%
  }{%
    #1\def#2{#3}%
  }%
}
% #1: list of comma-separated command pairs:
\robust@def*\newprovidedcommands#1{%
  \def\reserved@e##1##2\LTS@nil{%
    \ifdefTF{##2}{%
      \LTS@providerobustdef*##1{##2}%
    }{%
      \cpt@notdeferr{##2}%
    }%
  }%
  \def\csv@do##1{\reserved@e##1\LTS@nil}%
  \csv@@parse[,]{#1}%
}
\new@def*\ifrelaxTF#1{%
  \ifdefinedTF{#1}%
    {\usename{LTS@\expandafter\ifxTF\cpt@car#1\car@nil
    \relax12of2}}\@secondoftwo
}
\new@def*\ifcsnrelaxTF#1{%
  \ifcsnameFT{#1}\@secondoftwo
    {\usename{LTS@\aftercsname\expandafter\ifxTF\cpt@car#1\car@nil
    \relax12of2}}%
}
\def\ifcsnrelaxFT#1{\usename{LTS@\ifcsnrelaxTF{#1}21of2}}
\new@def*\ifdefaxTFN#1{%
  \ifdefinedTF{#1}%
    {\usename{LTS@\expandafter\ifxTF\cpt@car#1\car@nil
    \relax21of3}}\@thirdofthree
}
\new@def*\ifcsndefaxTFN#1{%
  \ifcsnameTF{#1}%
    {\usename{LTS@\expandafter\ifxTF\csname#1\endcsname
    \relax21of3}}\@thirdofthree
}
\robust@def*\ifargifTF#1{%
  \usename{LTS@\ifnum\pdfstrcmp
  {\expandafter\LTS@carcube\string#1xxx\car@nil}%
  {\string\if}=\z@pt1\else2\fi of2}%
}
\robust@def*\LTS@detokenize{\LTS@testst\LTS@det@kenize}
\robust@def*\LTS@det@kenize#1#2{%
  \edef#2{\detokenize{#1}}%
  \ifLTS@st
    \simpleexpandarg\ifargifTF#2{%
      \LTS@err{'\@backslashchar if' not valid}\@ehc
    }{%
      \LTS@scantoksa#2%
      \edef#2{\cpttxdetok#2}%
    }%
  \fi
}
\new@def*\LTS@detokdespace{\LTS@testpl\LTS@det@kdespace}
\new@def\LTS@det@kdespace#1{%
  \ifboolTF{LTS@pl}{%
    \edef\LTS@resa{\detokenize{#1}}%
    \despacecontent\LTS@resa
  }{%
    \ifdefTF{#1}{}{%
      \LTS@err{Command '\string#1' is undefined}{Command
      '\string\LTS@detokdespace' doesn't accept undefined
        \MsgBrk commands when submitted without the '+' prefix.}%
    }%
    \ifargifTF{#1}{%
      \LTS@err{Invalid argument '\string#1' for command\MsgBrk
        '\string\LTS@detokdespace'}{Command '\string\LTS@detokdespace'
        doesn't accept '\@backslashchar if'\MsgBrk when submitted
        without the '+' prefix.}%
    }{%
      \edef#1{\cptoxdetok{#1}}%
      \despacecontent#1%
    }%
  }%
}
\robust@def*\ifltxprotectTF#1{%
  \begingroup
  \ifmacroFT#1{%
    \aftergroup\@secondoftwo
  }{%
    \edef\LTS@tempa##1{\def##1####1\string\protect####2&}%
    \LTS@tempa\LTS@tempa{%
      \csnaftergroup{LTS@\ifblankTF{##2}21of2}%
    }%
    \edef\LTS@tempb##1{##1\realmeaning#1\string\protect&}%
    \LTS@tempb\LTS@tempa
  }%
  \endgroup
}
\robust@def*\ifltxprotectFT#1{%
  \ifltxprotectTF{#1}\iiofii\iofii
}
\robust@def*\ifcsnltxprotectTF{\aftercsname\ifltxprotectTF}
\robust@def*\ifetexprotectedTF#1{%
  \begingroup
  \edef\LTS@tempa##1{\def##1####1\string\protected####2&}%
  \LTS@tempa\LTS@tempa{%
    \csnaftergroup{LTS@\ifblankTF{##2}21of2}%
  }%
  \edef\LTS@tempb##1{##1\meaning#1\string\protected&}%
  \LTS@tempb\LTS@tempa
  \endgroup
}
\robust@def*\ifetexprotectedFT#1{%
  \ifetexprotectedTF{#1}\iiofii\iofii
}
\robust@def*\ifcsnprotectedTF{\aftercsname\ifetexprotectedTF}
\robust@def*\apptocs{%
  \cpt@checkoptprefix{\LTS@teststplcl{\LTS@hooktomac{>}}}%
}
\robust@def*\preptocs{%
  \cpt@checkoptprefix{\LTS@teststplcl{\LTS@hooktomac{<}}}%
}
\robust@def\LTS@hooktomac#1#2#3{%
  \ifLTS@st\let\@expandb\expandcsonce\else\let\@expandb\unexpanded\fi
  \cpt@getmacroprefix{#2}%
  \ifLTS@pl
    \let\@ifdef\ifcsndefFT\let\@expanda\expandcsnonce
    \def\LTS@i##1{\def\@def####1{\aftercsname##1{####1}}}%
  \else
    \let\@ifdef\ifdefFT\let\@expanda\expandcsonce
    \def\LTS@i##1{\def\@def####1{##1####1}}%
  \fi
  \ifLTS@cl\LTS@i\xdef\else\LTS@i\edef\fi
  \@ifdef{#2}{%
    \macroprefix\@def{#2}{\@expandb{#3}}%
  }{%
    \ifx#1>%
      \macroprefix\@def{#2}{\@expanda{#2}\@expandb{#3}}%
    \else
      \macroprefix\@def{#2}{\@expandb{#3}\@expanda{#2}}%
    \fi
  }%
  \LTS@undef!{\@ifdef,\@def,\@expanda,\@expandb,\LTS@i}%
}
\robust@def*\ltsuaddtolist{\chardef\LTS@addnr\z@pt\LTS@addtolist}
\robust@def*\ltsaddtolist{\chardef\LTS@addnr\@ne\LTS@addtolist}
\robust@def*\ltsxaddtolist{\chardef\LTS@addnr\tw@\LTS@addtolist}
\robust@def*\LTS@addtolist#1{%
  \ifx#1*%
    \LTS@err{Star (*) isn't valid as suffix to
      \noexpand\ltsaddtolist or \string\ltslistadd}%
  \fi
  \LTS@testplcl{\LTS@testlt{\LTS@testopt\LTS@addt@list{,}}}%
  #1%
}
\new@def*\LTS@addt@list[#1]{%
  \edef\parser{\detokenize{#1}}%
  \ifLTS@cl\let\@def\xdef\else\let\@def\edef\fi
  \ifLTS@pl\expandafter\aftercsname\fi\LTS@addt@l@st
}
\robust@def\LTS@addt@l@st#1#2{%
  \ifcase\LTS@addnr
    \let\@expand\unexpanded
  \or
    \let\@expand\expandcsonce
  \else
    \let\@expand\@iden
  \fi
  \begingroup
  \toks@{\endgroup
    \ifdefFT{#1}{%
      \@def#1{\@expand{#2}}%
    }{%
      \ifcsnullTF#1{%
        \@def#1{\@expand{#2}}%
      }{%
        \ifboolTF{LTS@lt}{%
          \@def#1{\@expand{#2}\parser\expandcsonce{#1}}%
        }{%
          \@def#1{\expandcsonce{#1}\parser\@expand{#2}}%
        }%
      }%
    }%
  }%
  \usename{%
    \ifnum\LTS@addnr=\z@pt\else\ifnum\LTS@addnr=\@ne o\else x\fi\fi
    ifblankTF%
  }{#2}{\ifcpt@useempty\the\toks@\else\endgroup\fi}{\the\toks@}%
  \undefcs\@expand\undefcs\@def
  \chardef\LTS@addnr\@ne
}
\robust@def*\ltslistadd#1{%
  \LTS@plfalse\LTS@clfalse\LTS@ltfalse\chardef\LTS@addnr\z@pt
  \LTS@addt@list[#1]%
}
\robust@def*\ltsolistadd#1{%
  \LTS@plfalse\LTS@clfalse\LTS@ltfalse\chardef\LTS@addnr\@ne
  \LTS@addt@list[#1]%
}
\robust@def*\ltsxlistadd#1{%
  \LTS@plfalse\LTS@clfalse\LTS@ltfalse\chardef\LTS@addnr\tw@
  \LTS@addt@list[#1]%
}
\robust@def*\ltsaddtolistexpanded{%
  \LTS@testcl{\LTS@testopt\LTS@addtolistexpanded{,}}%
}
\robust@def*\LTS@addtolistexpanded[#1]#2#3{%
  \ifsingletokenTF{#2}{}{\cpt@notonetokenerr{#2}}%
  \begingroup
  \toks@{\endgroup
    \ifdefTF#2{%
      \usename{protected@\ifLTS@cl x\else e\fi def}%
        #2{#2\ifcsnullTF{#2}{}{#1}#3}%
    }{%
      \usename{protected@\ifLTS@cl x\else e\fi def}#2{#3}%
    }%
  }%
  \oifblankTF{#3}{\ifcpt@useempty\the\toks@\else\endgroup\fi}
    {\the\toks@}%
}
\ifpkgcurrTF{atveryend}{2010/03/24}{}{%
  \RequirePackage{atveryend}[2010/03/24]%
}
\robust@def*\LTS@notprerr{%
  \LTS@err{You have issued a preamble command here}%
    {Move shown command to document preamble.}%
}
\robust@def*\LTS@notenderr{%
  \LTS@err{You've called an \noexpand\enddocument
    command\MsgBrk at the wrong place}{%
    Move command to before \string\enddocument.
  }%
}
\robust@def*\ltsAtBeginDocument{\AtBeginDocument}
\robust@def*\ltsBeforeBeginDocument{%
  \grightaddtocs\LTS@beforedocstart
}
\new@def*\LTS@beforedocstart{}
\leftaddtocs\document{%
  \endgroup
  \let\ltsBeforeBeginDocument\@firstofone
  \LTS@beforedocstart
  \let\ltsBeforeBeginDocument\LTS@notprerr
  \gundefcs\LTS@beforedocstart
  \begingroup
}
\robust@def*\ltsAfterBeginDocument{%
  \grightaddtocs\LTS@afterdocstart
}
\new@def*\LTS@afterdocstart{}
\robust@def*\ltsAfterAfterBeginDocument{%
  \grightaddtocs\LTS@afterafterdocstart
}
\new@def*\LTS@afterafterdocstart{}
\rightaddtocs\document{%
  \let\ltsAfterBeginDocument\@firstofone
  \LTS@afterdocstart
  \let\ltsAfterBeginDocument\LTS@notprerr
  \gundefcs\LTS@afterdocstart
  \let\ltsAfterAfterBeginDocument\@firstofone
  \LTS@afterafterdocstart
  \let\ltsAfterAfterBeginDocument\LTS@notprerr
  \gundefcs\LTS@afterafterdocstart
  \ignorespaces
}
\ltsBeforeBeginDocument{\let\ltsAtBeginDocument\@firstofone}
\robust@def*\ltsAtEndDocument{\AtEndDocument}
\robust@def*\ltsBeforeLastPage{\grightaddtocs\LTS@beforelastpage}
\new@def*\LTS@beforelastpage{}
\ltsAtEndDocument{%
  \let\LTS@bef@relastpage\AtVeryEnd@BeforeClearDocumentHook
  \def\AtVeryEnd@BeforeClearDocumentHook{%
    \let\ltsBeforeLastPage\@firstofone
    \LTS@beforelastpage\LTS@bef@relastpage
    \let\ltsBeforeLastPage\LTS@notenderr
    \LTS@undef!{\LTS@beforelastpage,\LTS@bef@relastpage}%
  }%
}
\robust@def*\ltsAfterLastPage{\grightaddtocs\LTS@afterlastpage}
\new@def*\LTS@afterlastpage{}
\ltsAtEndDocument{%
  \let\LTS@afterl@stpage\AtVeryEnd@AfterLastShipoutHook
  \def\AtVeryEnd@AfterLastShipoutHook{%
    \let\ltsAfterLastPage\@firstofone
    \LTS@afterlastpage\LTS@afterl@stpage
    \let\ltsAfterLastPage\LTS@notenderr
    \LTS@undef!{\LTS@afterlastpage,\LTS@afterl@stpage}%
  }%
}
\robust@def*\ltsAfterEndDocument{\grightaddtocs\LTS@afterenddoc}
\new@def*\LTS@afterenddoc{}
\AtEndOfPackage{\newletcs\AtTagEndOfDocument\ltsAfterEndDocument}
\ltsAtEndDocument{%
  \let\LTS@aft@renddoc\AtVeryEnd@AtVeryEndDocumentHook
  \def\AtVeryEnd@AtVeryEndDocumentHook{%
    \let\ltsAfterEndDocument\@firstofone
    \LTS@afterenddoc\LTS@aft@renddoc
    \let\ltsAfterEndDocument\LTS@notenderr
    \LTS@undef!{\LTS@afterenddoc,\LTS@aft@renddoc}%
  }%
}
\robust@def*\ltsAtEndPackage{\AtEndOfPackage}
\robust@def*\ltsBeforeEndPackage{%
  \gleftaddtocsn{\@currname.\@currext-h@@k}%
}
\robust@def*\ltsAfterEndPackage{%
  \grightaddtocsn{\@currname.\@currext-LTS@hook}%
}
\let\ltsAtEndClass\ltsAtEndPackage
\let\ltsBeforeEndClass\ltsBeforeEndPackage
\let\ltsAfterEndClass\ltsAfterEndPackage
\leftaddtocs\@popfilename{%
  \usename{\@currname.\@currext-LTS@hook}%
  \gundefcsn{\@currname.\@currext-LTS@hook}%
}
\robust@def\AtTagEndPackage#1{\AtEndOfPackage{\ltsAfterEndPackage{#1}}}
\newletcs\ltsAtTagEndPackage\AtTagEndPackage
\robust@def\afterpackageloaded#1{%
  \LTS@after@cls@pkg@loaded{#1}\@pkgextension
}
\robust@def\afterclassloaded#1{%
  \LTS@after@cls@pkg@loaded{#1}\@clsextension
}
\robust@def\LTS@after@cls@pkg@loaded#1#2#3{%
  \edef\LTS@tempa{\expandafter\ifxTF\cpt@car#2\car@nil
    \@pkgextension{sty}{cls}}%
  \cptexpanded{%
    \ltsAfterAfterBeginDocument{%
      \noexpand\ifcsndefTF{ver@#1.\LTS@tempa}{}{%
        \LTS@warn{Package '#1' was never loaded}%
      }%
    }%
  }%
  \ifcsndefTF{ver@#1.\LTS@tempa}{%
    #3\relax
  }{%
    \grightaddtocsn{#1.\LTS@tempa-LTS@hook}{#3}%
  }%
}
\robust@def*\LTS@preamblecmdhook{}
\robust@def*\preamblecommands{\LTS@testpl\LTS@preamblecmds}
\new@def*\LTS@preamblecmds#1{%
  \begingroup
  \def\@cmd{\preamblecommands}%
  \let\@ifnopattern\ifnopattern
  \LTS@pkgpreamplecmd{#1}\LTS@preamblecmdhook{%
    \cptpassexpanded{%
      \grightaddtocs\LTS@preamblecmdhook
        {\LTS@dopreamble\@expand\LTS@tempa}%
    }%
  }%
  \endgroup
}
\robust@def*\AddPreambleCommands#1{%
  \def\csv@do##1{%
    \ltsfiltermergetsv!\LTS@preamblecmdhook
      {\LTS@dopreamble{##1}}\nofilter
  }%
  \csv@@parse[,]{#1}%
}
\robust@def*\RemovePreambleCommands#1{%
  \def\csv@do##1{%
    \ltsfilterdeletetokens!\LTS@preamblecmdhook
      {\LTS@dopreamble{##1}}\nofilter
  }%
  \csv@@parse[,]{#1}%
}
\robust@def*\packagecommands{\LTS@testpl\LTS@packagecmds}
\robust@def*\LTS@packagecmds#1{%
  \begingroup
  \toks@{}%
  \def\@cmd{\packagecommands}%
  \def\@ifnopattern##1\in##2{\ifnopattern##2\in{##1}}%
  \LTS@pkgpreamplecmd{#1}\LTS@packagecmderr{%
    \@after\ifparamacroTF\LTS@tempa{%
      \def\@prepto{\preptoparamcs}%
    }{%
      \def\@prepto{\leftaddtocs}%
    }%
    \cptexpandarg{\toks@}{\the\toks@\@prepto\@expand\LTS@tempa
      {\LTS@packagecmderr{\@expand\LTS@tempa}}\relax\relax}%
  }%
  \expandafter\endgroup\the\toks@
}
\robust@def*\LTS@pkgpreamplecmd#1#2#3{%
  \ifLTS@pl
    \def\@scape{\simpleexpandarg\ltsensurenoscape}%
    \let\@after\aftercsname
    \let\@expand\noexpandcsn
  \else
    \def\@scape{\simpleexpandarg\ltsensurescape}%
    \let\@after\expandafter
    \let\@expand\expandcsonce
  \fi
  \def\csv@do##1{%
    \def\LTS@tempa{##1}%
    \@after\ifonetoken\LTS@tempa\do{%
      \@scape\LTS@tempa
      \@after\ifdefTF\LTS@tempa{%
        \@after\@ifnopattern\LTS@tempa\in{#2}{#3}{}%
      }{%
        \LTS@warn{Command '\@after\string\LTS@tempa' undefined:
        \MsgBrk ignored by \expandcsonce\@cmd}%
      }%
    }%
  }%
  \csv@@parse{#1}%
}
\robust@def*\LTS@dopreamble#1{%
  \gdef#1{\LTS@err{'\string#1' is a preamble command}%
    {Move command '\string#1' to document preamble.}}%
}
\ltsAfterBeginDocument{%
  \LTS@preamblecmdhook
  \gletcs\LTS@dopreamble\@gobbleone
}
\robust@def*\LTS@packagecmderr#1{%
  \ifinstylefileTF{}{%
    \LTS@err{Command '\detokenize{#1}' issued outside style file}%
      {The command '\detokenize{#1}' is available only
        in style files.}%
  }%
}
\robust@def*\ltsparsemacro{\LTS@testst\LTS@parsemacro}
\robust@def*\LTS@parsemacro#1#2#3{%
  \let\ifLTS@noxpst\ifLTS@st
  \begingroup
  \def\LTS@tempd##1{%
    \cptemptify\LTS@resa
    \edef\LTS@tempb{\cptoxdetok{#3}##1&}%
    \edef\LTS@tempc####1{\def####1########1##1########2&}%
    \LTS@tempc\LTS@tempc{%
      \ifblankTF{####2}{%
        \edef\LTS@resa{\expandcsonce\LTS@resa####1}%
      }{%
        \edef\LTS@resa{\expandcsonce\LTS@resa####1\detokenize{#2}##1}%
        \LTS@tempc####2&%
      }%
    }%
    \expandafter\LTS@tempc\LTS@tempb
    \edef#3{\expandcsonce\LTS@resa}%
  }%
  \edef\LTS@tempa{\cptoxdetok{#1}}%
  \def\tsv@do##1{\LTS@tempd{##1}}%
  \tsv@@parse*\LTS@tempa
  \postgroupdef#3\endgroup
  \ifLTS@noxpst\LTS@scantoksa#3\fi
  \undefcs\ifLTS@noxpst
}
\robust@def*\ltsnoexpandparse#1{\ltsparsemacro*\@backslashchar\noexpand#1}
\robust@def*\ltsNoexpandParse#1{%
  \let\ifLTS@noxpst\ifLTS@st
  \begingroup
  \cptemptify\LTS@resa
  \def\LTS@tempd##1{\edef\LTS@resa{\expandcsonce\LTS@resa
    \noexpand\noexpand\unexpanded{##1}}}%
  \def\tsv@do##1{%
    \ifmacroTF{##1}{%
      \LTS@tempd{##1}%
    }{%
      \edef\LTS@tempb{\detokenize{##1}}%
      \edef\LTS@tempc{\expandafter\LTS@car\LTS@tempb x\car@nil}%
      \ifxTF\LTS@tempc\@backslashchar{%
        \LTS@tempd{##1}%
      }{%
        \edef\LTS@resa{\expandcsonce\LTS@resa\unexpanded{##1}}%
      }%
    }%
  }%
  \tsv@@parse*{#1}%
  \edef#1{\expandcsonce\LTS@resa}%
  \postgroupdef#1\endgroup
  \ifLTS@noxpst\LTS@scantoksa#1\fi
  \undefcs\ifLTS@noxpst
}
\robust@def*\ltsdespacecommalist#1#2{%
  \LTS@stfalse\LTS@despacecsvlist[,]{#1}%
  \let#2=\despaced@list
}
\robust@def*\ltsdespacecsvlist{%
  \LTS@testst{\LTS@testopt\LTS@despacecsvlist{,}}%
}
\robust@def*\LTS@despacecsvlist[#1]#2{%
  \cpt@stchoose{LTS@st}{#2}\despaced@list\LTS@despacecsvlist
  \ifcsnullTF\despaced@list{}{%
    \xifinsetTF{\detokenize{#1}}{\cptoxdetok\despaced@list}{%
      \cpt@sttrue\cpt@csvnormalize[#1]\despaced@list
    }{%
      \edef\despaced@list
        {\simpleexpandarg\cpttrimspaces\despaced@list}%
    }%
  }%
  \ifboolTF{LTS@st}{\let#2=\despaced@list}{}%
}
\robust@def*\ltsdespacexcsvlist{%
  \LTS@teststpm{\LTS@testopt\LTS@despacexcsvlist,}%
}
\robust@def*\LTS@despacexcsvlist[#1]{%
  \LTS@testopt{\LTS@d@spacexcsvlist#1}{#1}%
}
\robust@def*\LTS@d@spacexcsvlist#1[#2]#3{%
  \let\ifxdespm\ifLTS@pm
  \cpt@stchoose{LTS@st}{#3}\reserved@e\LTS@d@spacexcsvlist
  \def\despaced@list{}%
  \ifcsnullTF\reserved@e{}{%
    \def\csv@do##1{%
      \ifboolTF{xdespm}{%
        \cpt@sttrue\cpt@csvnormalize[#2]{##1}%
        \ltslistadd#1\despaced@list{##1}%
      }{%
        \edef\reserved@e{\cpttrimspaces{##1}}%
        \ltsolistadd{#1}\despaced@list\reserved@e
      }%
    }%
    \csv@@parse*[#1]\reserved@e
  }%
  \ifboolTF{LTS@st}{\let#3=\despaced@list}{}%
  \undefcs\ifxdespm
}
\robust@def*\ltsdespacetsvlist#1#2{%
  \ltsensuremacro{#2}%
  \def#2{}%
  \def\tsv@do##1{\rightaddtocs#2{##1}}%
  \tsv@@parse{#1}%
}
\robust@def*\ltsdespacextsvlist#1#2{%
  \ltsensuremacro{#2}%
  \def#2{}%
  \def\tsv@do##1{%
    \ltsdespacetsvlist{##1}\reserved@e
    \cptexpandargonce{\rightaddtocs#2}\reserved@e
  }%
  \tsv@@parse{#1}%
}
\robust@def*\ltssetmanytolength#1#2{%
  \cptfor#1\dofor{##1=\dimexpr#2\relax\relax}%
}
\newletcs\ltssetmanytodim\ltssetmanytolength
\robust@def*\ltsdefmanyascs#1#2{%
  \cptfor#1\dofor{\def##1{#2}}%
}
\robust@def*\ltsletmanytocs#1#2{%
  \cptfor#1\dofor{\let##1=#2}%
}
\robust@def*\ltsnewletmanytocs#1#2{%
  \cptfor#1\dofor{\newletcs##1=#2}%
}
\robust@def*\ltsnewletcs{\LTS@testst\LTS@newletcs}
\new@def*\LTS@newletcs#1{%
  \cpt@ifeql{\LTS@n@wletcs{#1}}{\LTS@n@wletcs{#1}}%
}
\new@def*\LTS@n@wletcs#1#2{%
  \ifdefTF#1{%
    \ifLTS@st
      \ifdefTF#2{%
        \let#1=#2%
        \LTS@verboseinfo{Command '\string#1' redefined}%
      }{%
        \LTS@err{Command '\string#2' undefined}%
          {I can't let '\string#1' to undefined '\string#2'.}%
      }%
    \else
      \LTS@err{Command '\string#1' already defined}%
        {I can't assign defined '\string#1' to '\string#2'.}%
    \fi
  }{%
    \ifdefTF#2{\let#1=#2}{%
      \LTS@err{Command '\string#2' undefined}%
        {I can't let '\string#1' to undefined '\string#2'.}%
    }%
  }%
}
\new@def*\LTS@newletcsnerr#1#2{%
  \begingroup
  \def\LTS@tempa{\ifcpt@swa\string#2\else\noexpandcsn{#2}\fi}%
  \LTS@err{%
    Command '\LTS@tempa' is already defined
  }{%
    Command '\LTS@tempa' is defined: You may use the starred
    \MsgBrk version of \noexpand#1 for this type of assignment.
  }%
  \endgroup
}
\new@def*\newletcstocs{%
  \LTS@err{%
    Command '\string\newletcstocs' is undefined
  }{%
    Command '\string\newletcstocs' is undefined. You can use
    \string\newletcs,\MsgBrk but this can't assign control
    sequence names.\MsgBrk Perhaps you meant to use
    \string\newletcsntocs, or\MsgBrk\noexpand\newletcstocsn
    or \string\newletcsntocsn.
  }%
}
\robust@def*\newletcsntocs{\LTS@teststcl\LTS@newletcsntocs}
\new@def*\LTS@newletcsntocs#1#2{%
  \LTS@global@or@relax
  \ifLTS@st
    \glob@lrel@x\letcsntocs{#1}#2%
  \else
    \ifcsndefFT{#1}%
      {\glob@lrel@x\letcsntocs{#1}#2}%
      {\cpt@swafalse\LTS@newletcsnerr\newletcsntocs{#1}}%
  \fi
}
\robust@def*\newletcstocsn{\LTS@teststcl\LTS@newletcstocsn}
\new@def*\LTS@newletcstocsn#1#2{%
  \ltsensurescape{#1}%
  \LTS@global@or@relax
  \def\reserved@e{\begingroup\expandafter\endgroup\expandafter
    \glob@lrel@x\expandafter\let\expandafter#1\csname#2\endcsname}%
  \ifLTS@st
    \reserved@e
  \else
    \ifdefFT{#1}\reserved@e{%
      \cpt@swatrue\LTS@newletcsnerr\newletcstocsn{#1}%
    }%
  \fi
}
\robust@def*\newletcsntocsn{\LTS@teststcl\LTS@newletcsntocsn}
\new@def*\LTS@newletcsntocsn#1#2{%
  \LTS@global@or@relax
  \def\reserved@e{\begingroup\expandafter\endgroup\expandafter
    \glob@lrel@x\expandafter\let\csname#1\aftercsname\endcsname{#2}}%
  \ifLTS@st
    \reserved@e
  \else
    \ifcsndefFT{#1}\reserved@e{%
      \cpt@swafalse\LTS@newletcsnerr\newletcsntocsn{#1}%
    }%
  \fi
}
\robust@def*\provideletcsntocs{\LTS@testcl\LTS@provideletcsntocs}
\new@def*\LTS@provideletcsntocs#1#2{%
  \LTS@global@or@relax
  \ifcsndefTF{#1}{}{\glob@lrel@x\letcsntocs{#1}#2}%
}
\robust@def*\provideletcstocsn{\LTS@testcl\LTS@provideletcstocsn}
\new@def*\LTS@provideletcstocsn#1#2{%
  \LTS@global@or@relax
  \ifdefTF#1{}{%
    \begingroup\expandafter\endgroup\expandafter\glob@lrel@x
      \expandafter\let\expandafter#1\csname#2\endcsname
  }%
}
\robust@def*\provideletcsntocsn{\LTS@testcl\LTS@provideletcsntocsn}
\def\LTS@provideletcsntocsn#1#2{%
  \LTS@global@or@relax
  \ifcsndefTF{#1}{}{%
    \begingroup\expandafter\endgroup\expandafter\glob@lrel@x
      \expandafter\let\csname#1\aftercsname\endcsname{#2}%
  }%
}
\new@def*\provideletcstocs{%
  \LTS@err{'\string\provideletcstocs' is undefined}%
    {Command '\string\provideletcstocs' is undefined.
     Perhaps you meant \MsgBrk to use \string\provideletcsntocs,
     or \noexpand\provideletcstocsn or \string\provideletcsntocsn.}%
}
\robust@def*\ltsnumexpr{%
  \cpt@checkoptprefix{\LTS@testplcl{\LTS@numexpr{num}}}%
}
\robust@def*\ltsdimexpr{%
  \cpt@checkoptprefix{\LTS@testplcl{\LTS@numexpr{dim}}}%
}
\robust@def*\ltsglueexpr{%
  \cpt@checkoptprefix{\LTS@testplcl{\LTS@numexpr{glue}}}%
}
\robust@def*\ltsmuexpr{%
  \cpt@checkoptprefix{\LTS@testplcl{\LTS@numexpr{mu}}}%
}
\new@def*\LTS@numexpr#1#2{%
  \if\detokenize{#2*}%
    \LTS@err{Invalid suffix to '\string\ltsdimexpr' or
      '\string\ltsnumexpr'}{Star (*) not valid as suffix to
      '\string\ltsdimexpr' and '\string\ltsnumexpr'.}%
  \fi
  \LTS@global@or@relax
  \ifboolTF{LTS@pl}{%
    \cptexpandsecond{\LTS@n@mexpr{#1}}{\noexpandcsn{#2}}%
  }{%
    \LTS@n@mexpr{#1}{#2}%
  }%
}
\new@def*\LTS@n@mexpr#1#2#3{%
  \ltsensurescape@notempty{#2}{#3}%
  \ifdefTF{#2}{%
    \glob@lrel@x#2=\usename{#1expr}#3\relax
  }{%
    \begingroup
    \LTS@getorderincsvlist[,](\nr){#1}{num,dim,glue,mu}%
    \edef\LTS@tempa{\ifcase\nr\relax
      count\or dimen\or skip\or muskip\fi}%
    \usename{new\LTS@tempa}#2\relax
    \endgroup
    \glob@lrel@x#2=\usename{#1expr}#3\relax
  }%
}
\robust@def*\ltsnumdef{%
  \cpt@checkoptprefix{\LTS@testplcl{\LTS@numdef{num}}}%
}
\robust@def*\ltsdimdef{%
  \cpt@checkoptprefix{\LTS@testplcl{\LTS@numdef{dim}}}%
}
\robust@def*\ltsgluedef{%
  \cpt@checkoptprefix{\LTS@testplcl{\LTS@numdef{glue}}}%
}
\robust@def*\ltsmudef{%
  \cpt@checkoptprefix{\LTS@testplcl{\LTS@numdef{mu}}}%
}
\new@def*\LTS@numdef#1#2{%
  \if\detokenize{*#2}%
    \LTS@err{Invalid suffix to '\string\ltsdimdef' or
      '\string\ltsnumdef'}{Star (*) not valid as suffix to
      '\string\ltsdimdef' and '\string\ltsnumdef'.}%
  \fi
  \LTS@global@or@relax
  \ifboolTF{LTS@pl}{%
    \cptexpandsecond{\LTS@num@def{#1}}{\noexpandcsn{#2}}%
  }{%
    \LTS@num@def{#1}{#2}%
  }%
}
\new@def*\LTS@num@def#1#2#3{%
  \ltsensurescape@notempty{#2}{#3}%
  \glob@lrel@x\edef#2{\the\usename{#1expr}#3\relax}%
}
\robust@def*\ltsensurescape@notempty#1#2{%
  \ltsensurescape{#1}%
  \ifblankFT{#2}{}{%
    \LTS@err{Argument '\string#2' is empty}%
      {Empty argument '\string#2' is invalid.\MsgBrk
      I expected a nonempty argument here.}%
  }%
}
\robust@def*\ifexistinTF{\LTS@testst{\LTS@testopt\LTS@ifexistinTF,}}
\robust@def*\LTS@ifexistinTF[#1]#2\in#3{%
  \begingroup
  \edef\reserved@e{\ifboolTF{LTS@st}\cptoxdetok\detokenize{#2}}%
  \despacecontent\reserved@e
  \edef\reserved@f{\ifboolTF{LTS@st}\cptoxdetok\detokenize{#3}}%
  \cpt@sttrue\cpt@csvnormalize[#1]\reserved@f
  \edef\x{\detokenize{#1}}%
  \cptexpandtwoargs{\endgroup\ifinsetTF}
    {\x\reserved@e\x}{\x\reserved@f\x}%
}
\robust@def\ifpresentTF#1\in#2#{\ifinsetTF{#1}{#2}}
\robust@def*\ifpresentinTF{\LTS@testst{\LTS@testopt\LTS@ifpresentinTF,}}
\robust@def*\LTS@ifpresentinTF[#1]#2\in#3{%
  \begingroup
  \edef\reserved@e{\ifboolTF{LTS@st}\cptoxdetok\detokenize{#2}}%
  \despacecontent\reserved@e
  \edef\reserved@f{\ifboolTF{LTS@st}\cptoxdetok\detokenize{#3}}%
  \cpt@choicefdfalse
  \def\csv@do##1{%
    \def\reserved@a{##1}%
    \ifx\reserved@a\reserved@e\cpt@choicefdtrue\loopbreak\fi
  }%
  \csv@@parse*[;]\reserved@f
  \ifboolTF{cpt@choicefd}
    {\endgroup\@firstoftwo}{\endgroup\@secondoftwo}%
}
\robust@def*\ifendwithTF#1#2{%
  \ifblankTF{#2}\@secondoftwo{%
    \begingroup
    \edef\LTS@tempa{\s@expandarg\cpttrimspace{\detokenize{#1}}}%
    \edef\LTS@tempb{\s@expandarg\cpttrimspace{\detokenize{#2}}}%
    \let\endwith\relax
    \cptexpandtwoargs\cpt@in{\LTS@tempb\endwith}{\LTS@tempa\endwith}%
    \csnendgroup{@\ifcpt@in first\else second\fi oftwo}%
  }%
}
\robust@def*\ifbeginwithTF#1#2{%
  \ifblankTF{#2}\@secondoftwo{%
    \begingroup
    \edef\LTS@tempa{\s@expandarg\cpttrimspace{\detokenize{#1}}}%
    \edef\LTS@tempb{\s@expandarg\cpttrimspace{\detokenize{#2}}}%
    \let\begwith\relax
    \cptexpandtwoargs\cpt@in{\begwith\LTS@tempb}{\begwith\LTS@tempa}%
    \csnendgroup{@\ifcpt@in first\else second\fi oftwo}%
  }%
}
\robust@def*\in@detok#1#2{%
  \cptexpandtwoargs\cpt@in{\detokenize{#1}}{\detokenize{#2}}%
}
\newletcs\ifmemberTF\ifinsetTF
\newletcs\ifmemberFT\ifinsetFT
\robust@def*\ifbelongTF#1#2{%
  \cptexpandtwoargs\ifinsetTF{\detokenize{#1}}{\detokenize{#2}}%
}
\robust@def*\ifbelongFT#1#2{\ifbelongTF{#1}{#2}\iiofii\iofii}
\robust@def*\oifbelongTF#1#2{\cptexpandtwoargsonce\ifbelongTF{#1}{#2}}
\robust@def*\oifbelongFT#1#2{\cptexpandtwoargsonce\ifbelongFT{#1}{#2}}
\robust@def*\xifbelongTF#1#2{\cptexpandtwoargs\ifbelongTF{#1}{#2}}
\robust@def*\xifbelongFT#1#2{\cptexpandtwoargs\ifbelongFT{#1}{#2}}
\new@def*\ifdraftTF{\usename{LTS@\ifboolTF{LTS@draft}12of2}}
\new@def*\ifdraftFT{\usename{LTS@\ifdraftTF21of2}}
\new@def*\iffinalTF{\usename{LTS@\ifboolTF{LTS@final}12of2}}
\new@def*\iffinalFT{\usename{LTS@\iffinalTF21of2}}
\robust@def*\LTS@starorlong#1{%
  \LTS@ifstar
    {\def\l@ngrel@x{\relax}#1}{\def\l@ngrel@x{\long}#1}%
}
\robust@def*\LTS@starornone#1{%
  \LTS@ifstar
    {\let\l@ngrel@x\relax\def\star@none{*}#1}%
    {\let\l@ngrel@x\long\def\star@none{}#1}%
}
\new@def*\ValidCommandPrefixes{\relax\long\global\protected}
\robust@def*\newfunction{%
  \begingroup
  \def\inrenew{01}%
  \LTS@starorlong\LTS@newfunction@a
}
\robust@def*\renewfunction{%
  \begingroup
  \def\inrenew{00}%
  \LTS@starorlong\LTS@newfunction@a
}
\robust@def*\LTS@newfunction@a#1#{%
  \def\LTS@tempa##1##2[##3][##4]##5\LTS@nil{%
    \begingroup
    \@tempcnta\z@pt
    \def\comma{,}%
    \cpttfor##2\dofor{%
      \def\reserved@a{####1}%
      \ifx\reserved@a\comma\advance\@tempcnta\@ne\fi
      \ifnum\@tempcnta>\@ne\forbreaktrue\fi
    }%
    \expandafter\endgroup\ifnum\@tempcnta>\@ne
      \LTS@err{Double comma in sentinel while defining
        \detokenize{##1}}\@ehc
    \else
      \def\cmd{##1}\def\prefix@sentinel{##2}%
    \fi
    \edef\param@default{%
      \ifstrcmpTF{##3}\LTS@nil{}{[##3]}%
      \ifstrcmpTF{##4}\LTS@nil{}{[\unexpanded{##4}]}%
    }%
  }%
  \LTS@tempa#1[{\LTS@nil}][{\LTS@nil}]\LTS@nil
  \if\inrenew
    \oifdefTF\cmd{%
      \LTS@verboseinfo{Command '\expandafter\string\cmd' redefined
        \MsgBrk\on@line}%
    }{%
      \LTS@warn{Command '\expandafter\string\cmd' was previously
        undefined\MsgBrk but now defined with \string\renewfunction}%
    }%
    \let\ifcsdefinable\rc@ifcsdefinable
  \fi
  \def\reserved@a##1,##2##3\LTS@nil{%
    \def\prefix{##1}%
    \if##2,\def\currsentinel{}\else\def\currsentinel{##2}\fi
  }%
  \expandafter\reserved@a\prefix@sentinel,,\LTS@nil
  \let\LTS@rsvda\prefix
  \simpledeletetokens\LTS@rsvda\ValidCommandPrefixes
  \ifx\LTS@rsvda\@empty\else
    \LTS@err{Illegal prefixes '\expandcsonce\LTS@rsvda'
      for command '\expandcsonce\cmd'}\@ehc
  \fi
  \expandafter\expandafter\expandafter\LTS@testopt\expandafter
  \expandafter\expandafter{\expandafter\expandafter\expandafter
  \LTS@newfunction@c\expandafter\cmd\expandafter}\expandafter
  0\param@default
}
\robust@def*\LTS@newfunction@c#1[#2]{%
  \ifnextisbrack{\LTS@newfunction@e#1[#2]}{\LTS@newfunction@d#1[#2]}%
}
\robust@def\LTS@newfunction@d#1[#2]#3{%
  \toks@{}%
  \ifcsdefinable#1{\LTS@newfunction@f#1\@ne{#2}{#3}}%
}
\robust@def\LTS@newfunction@e#1[#2][#3]#4{%
  \ifcsdefinable#1{%
    \expandafter\cpt@in\expandafter\protected\expandafter{\prefix}%
    \edef\LTS@tempa{%
      \ifcpt@in\LTS@testopt\else\unexpanded{\@protected@testopt#1}\fi
      \noexpandcsn{\string#1}\unexpanded{{#3}}%
    }%
    \cptexpandarg\toks@{%
      \l@ngrel@x\prefix\def\noexpand#1{\expandcsonce\LTS@tempa}%
    }%
    \aftercsname\LTS@newfunction@f{\string#1}\tw@{#2}{#4}%
  }%
}
\robust@def\LTS@newfunction@f#1#2#3{%
  \ifx#2\tw@
    \gdef\@gtempa##11{[####1]}%
  \else
    \gletcs\@gtempa\@gobble
  \fi
  \expandafter\LTS@newfunction@g\expandafter{\number#3}#1%
}
\robust@def\LTS@newfunction@g#1#2{%
  \defpass\reserved@a##1#1##2##{%
    \edef\reserved@a{%
      \endgroup\the\toks@\l@ngrel@x\prefix
      \unexpanded{\expandafter\def\expandafter#2\@gtempa}%
    }%
    \s@expandarg\cptswap\currsentinel{\reserved@a##1#1}%
  }%
  0##1##2##3##4##5##6##7##8##9###1%
}
\cptnewvariables{if}[LTS@]{global,protected}
\robust@def*\ltsglobal{\LTS@globaltrue}
\robust@def*\ltsprotected{\LTS@protectedtrue}
\robust@def*\LTS@global@protected{%
  \ifLTS@global
    \LTS@globalfalse
    \let\LTS@tempa\global
  \else
    \let\LTS@tempa\@empty
  \fi
  \ifLTS@protected
    \LTS@protectedfalse\protected
  \fi
  \LTS@tempa
}
\robust@def*\ltsnewcommand{\cpt@starorlong\LTS@newcommand}
\robust@def*\LTS@newcommand#1{\LTS@testopt{\LTS@n@wcommand#1}0}
\robust@def*\LTS@n@wcommand#1[#2]{%
  \ifnextisbrack{\LTS@xargdef@a#1{#2}}{\LTS@argdef@a#1{#2}}%
}
\robust@def\LTS@argdef@a#1#2{%
  \LTS@testpnopt{\LTS@argdef@b{#1}{#2}}{}%
}
\robust@def\LTS@argdef@b#1#2(#3)#4{%
  \def\LTS@tempd{#3}%
  \ifcsdefinable#1{\LTS@yargdef#1\@ne{#2}{#4}}%
}
\robust@def\LTS@xargdef@a#1#2[#3]{%
  \LTS@testpnopt{\LTS@xargdef@b{#1}{#2}{#3}}{}%
}
\robust@def\LTS@xargdef@b#1#2#3(#4)#5{%
  \def\LTS@tempd{#4}%
  \ifcsdefinable#1{%
    \ifLTS@global\global\fi
    \ifLTS@protected\protected\fi
    \expandafter\def\expandafter#1\expandafter{%
      \expandafter\@protected@testopt\expandafter#1%
      \csname\string#1\endcsname{#3}%
    }%
    \aftercsname\LTS@yargdef{\string#1}\tw@{#2}{#5}%
  }%
}
\robust@def\LTS@yargdef#1#2#3{%
  \ifnum#2=\tw@
    \def\LTS@tempb##11{[####1]}%
  \else
    \let\LTS@tempb\@gobble
  \fi
  \expandafter\LTS@zargdef\expandafter{\number#3}#1%
}
\robust@def\LTS@zargdef#1#2{%
  \begingroup
  \def\LTS@tempa##1#1##2##{%
    \def\LTS@tempc{\LTS@global@protected\l@ngrel@x}%
    \cptexpandsecond{\expandafter\endgroup\LTS@tempc
      \expandafter\def\expandafter#2\LTS@tempb##1#1}{\elt{#1}}%
  }%
  \@tempcnta\z@pt
  \loop
    \advance\@tempcnta\@ne
    \csn@def{d\number\@tempcnta}{}%
    \ifnum\@tempcnta<9\relax
  \repeat
  \ifx\LTS@tempd\@empty\else
    \@tempcnta\z@pt
    \def\do##1##2{%
      \ifstrcmpTF{##1}\zargdef@nil{}{%
        \advance\@tempcnta\@ne
        \ifnum\@tempcnta>#1\relax
          \LTS@err{Number of delimiters exceeds
            number of parameters}\@ehc
        \fi
        \ifinsetTF{,##1,}{,1,2,3,4,5,6,7,8,9,}{}{%
          \LTS@err{Invalid delimiter syntax:
            \MsgBrk no digit [1-9] found before delimiter}\@ehc
        }%
        \csn@def{d##1}{##2}\do
      }%
    }%
    \expandafter\do\LTS@tempd\zargdef@nil\zargdef@nil
  \fi
  \ifx\LTS@tempb\@gobble\else
    \expandafter\ifx\csname d1\endcsname\@empty\else
      \LTS@err{Argument one of command \string#2 is
        \MsgBrk already delimited by '[]'}\@ehc
    \fi
  \fi
  \def\elt##1{\expandcsnonce{d##1}}%
  \edef\LTS@tempc{0####1\ifx\LTS@tempb\@gobble\elt1\fi
    ####2\elt2####3\elt3####4\elt4####5\elt5####6\elt6%
    ####7\elt7####8\elt8####9\elt9%
  }%
  \expandafter\LTS@tempa\LTS@tempc###1%
}
\robust@def*\ltsrenewcommand{\cpt@starorlong\LTS@renewcommand}
\robust@def*\LTS@renewcommand#1{%
  \ifdefTF{#1}{}{%
    \LTS@warn{Command '\string#1' was previously undefined
      \MsgBrk but now defined with \string\ltsrenewcommand}%
  }%
  \let\ifcsdefinable\rc@ifcsdefinable
  \LTS@newcommand#1%
}
\robust@def*\ltsneedcommand{\LTS@starornone\LTS@needcommand}
\new@def*\LTS@needcommand#1{%
  \ltsensurescape{#1}%
  \ifdefTF{#1}
    {\expandafter\ltscheckcommand\star@none}
    {\expandafter\newcommand\star@none}%
  {#1}%
}
\new@def*\ltscheckcommand{\cpt@starorlong\LTS@checkcommand}
\new@def*\LTS@checkcommand#1#2#{\LTS@ch@ckcommand#1{#2}}
\new@def\LTS@ch@ckcommand#1#2#3{%
  \letcsntocs{\string\reserved@a}\relax
  \renew@command\reserved@a#2{#3}%
  \@ifundefined{\string\reserved@a}{%
    \LTS@ch@ckc@mmand#1\reserved@a
  }{%
    \expandafter\LTS@ch@ckc@mmand
    \csname\string#1\expandafter\endcsname
    \csname\string\reserved@a\endcsname
  }%
}
\new@def*\LTS@ch@ckc@mmand#1#2{%
  \ifx#1#2\else
    \LTS@verbosewarn{%
      Previous definition of '\string#1'\MsgBrk
      doesn't match your new definition.\MsgBrk
      I haven't redefined '\string#1'}%
  \fi
}
\AtEndOfPackage{%
  \preamblecommands{%
    \ltscheckcommand,\LTS@checkcommand,
    \LTS@ch@ckc@mmand,\LTS@ch@ckcommand
  }%
}
\robust@def*\ltsfindcommand{\LTS@testst\LTS@findcommand}
\robust@def*\LTS@findcommand#1#2{%
  \let\ifLTS@findcmdst\ifLTS@st
  \ifsingletokenTF{#1}{}{%
    \cpt@notonetokenerr{#1}%
  }%
  \undefcs\LTS@savcmd
  \ifdefFT{#1}{}{%
    \let\LTS@savcmd#1%
    \LTS@info{Command '\string#1' is defined in one of
      \MsgBrk the previously loaded packages;
      \MsgBrk I will still try to find it among the
      \MsgBrk suggested packages}%
  }%
  \def\LTS@pkgs@a{}%
  \def\LTS@pkgs@b{}%
  \cptdocommalist{#2}{%
    \undefcs#1%
    \xifinsetTF{,##1,}{,\LTS@pkgs@b,}{}{%
      \edef\LTS@pkgs@b{\csliststack,\LTS@pkgs@b##1}%
      \RequirePackage{##1}%
      \ifdefFT{#1}{}{%
        \edef\LTS@pkgs@a{\csliststack,\LTS@pkgs@a##1}%
        \ifLTS@findcmdst\loopbreak\fi
      }%
    }%
  }%
  \ifcsemptyTF\LTS@pkgs@a{%
    \typeout{** Command '\string#1' is not defined in
      ^^Jone of the suggested packages}%
  }{%
    \typeout{** Command '\string#1' is defined in package(s):
      ^^J\LTS@pkgs@a^^J}%
  }%
  \ifdefFT\LTS@savcmd{}{%
    \let#1\LTS@savcmd
  }%
  \undefcsset{\ifLTS@findcmdst,\LTS@pkgs@a,\LTS@pkgs@b,\LTS@savcmd}%
}
\robust@def*\ifinlistTF{%
  \@tempswatrue
  \LTS@testst{\LTS@testopt\LTS@ifinlista{,}}%
}
\robust@def*\ifinlistFT{%
  \@tempswafalse
  \LTS@testst{\LTS@testopt\LTS@ifinlista{,}}%
}
\robust@def\LTS@ifinlista[#1]#2#3{%
  \begingroup
  \def\reserved@e##1#1#2#1##2\LTS@nil{\endgroup
    \ifboolTF{@tempswa}{%
      \ifblankTF{##2}\iofii\iiofii
    }{%
      \ifblankTF{##2}\iiofii\iofii
    }%
  }%
  \ifboolTF{LTS@st}{%
    \ltsensurescape{#3}%
    \expandafter\reserved@e\expandafter
  }{%
    \reserved@e
  }%
  #1#3#1#2#1\LTS@nil
}
\robust@def\ifinlistbTF#1#2#3#4{%
  \if\LTS@lwc\LTS@sttrue\else\LTS@stfalse\fi
  \LTS@pltrue
  \LTS@checkchoice[\val\nr]{#1}{#2}{#3}{#4}%
}
\robust@def\ifinlistbFT#1#2#3#4{\ifinlistbTF{#1}{#2}{#4}{#3}}
\robust@def\oifinlistbTF#1#2#3#4{%
  \if\LTS@lwc\LTS@sttrue\else\LTS@stfalse\fi
  \LTS@pltrue
  \cptexpandsecond{\LTS@checkchoice[\val\nr]}%
    {{\expandcsonce{#1}}{\expandcsonce{#2}}}{#3}{#4}%
}
\robust@def\oifinlistbFT#1#2#3#4{\oifinlistbTF{#1}{#2}{#4}{#3}}
\robust@def\xifinlistbTF#1#2#3#4{%
  \if\LTS@lwc\LTS@sttrue\else\LTS@stfalse\fi
  \LTS@pltrue
  \cptexpandsecond
    {\LTS@checkchoice[\val\nr]}{{#1}{#2}}{#3}{#4}%
}
\robust@def\xifinlistbFT#1#2#3#4{\xifinlistbTF{#1}{#2}{#4}{#3}}
\new@def*\LTS@nochoice@handler#1#2{%
  \LTS@err{%
    Value '\expandcsonce{#1}' is not in list ^^J'\expandcsonce{#2}'
  }{%
    You have submitted an invalid value '\expandcsonce{#1}'\MsgBrk
    for your key or test parameter. Value '\expandcsonce{#1}'\MsgBrk
    is not in list:^^J'\expandcsonce{#2}'.
  }%
}
\robust@def*\ltscheckchoice{\LTS@teststpl\LTS@checkchoice}
\robust@def*\LTS@checkchoice{\LTS@testopt\LTS@ch@ckchoice{}}
\robust@def*\LTS@ch@ckchoice[#1]#2#3{%
  \cpt@choicefdfalse
  \begingroup
  \ifLTS@st\lowercase{\fi
  \ifblankTF{#1}{%
    \def\LTS@tempa{\endgroup\LTS@ch@@@choice\LTS@nil{#2}{#3}}%
  }{%
    \def\LTS@tempa{\endgroup\LTS@ch@@kchoice#1\LTS@nil{#2}{#3}}%
  }%
  \ifLTS@st}\fi\LTS@tempa
}
\robust@def*\LTS@ch@@kchoice#1#2\LTS@nil#3#4{%
  \ifblankTF{#2}%
    {\LTS@ch@@@choice#1{#3}{#4}}{\LTS@ch@@@@hoice#1#2{#3}{#4}}%
}
\robust@def*\LTS@ch@@@choice#1#2#3{%
  \begingroup
  \def\LTS@tempc{#1}%
  \ifx\LTS@tempc\LTS@nnil
    \cptemptify\LTS@tempc
  \else
    \def\LTS@tempc{\def#1{#2}}%
  \fi
  \cptexpandtwoargs\cpt@in{,\detokenize{#2},}{,\detokenize{#3},}%
  \usename{cpt@choicefd\ifcpt@in true\else false\fi}%
  \LTS@ch@@@@@oice\LTS@nochoice@handler{#2}{#3}%
}
\robust@def*\LTS@ch@@@@hoice#1#2#3#4{%
  \def#1{#3}\def#2{-1}%
  \begingroup
  \LTS@scantoksa#1%
  \cpt@cnta\z@pt
  \def\LTS@tempc{}%
  \def\csv@do##1{%
    \def\LTS@tempb{##1}%
    \LTS@scantoksa\LTS@tempb
    \ifx#1\LTS@tempb
      \edef\LTS@tempc{%
        \def\noexpand#1{\unexpanded{##1}}%
        \def\noexpand#2{\the\cpt@cnta}%
      }%
      \cpt@choicefdtrue\loopbreak
    \fi
    \advance\cpt@cnta\@ne
  }%
  \csv@@parse[,]{#4}%
  \LTS@ch@@@@@oice\LTS@nochoice@handler{#3}{#4}%
}
\robust@def\LTS@ch@@@@@oice#1#2#3{%
  \NoConvertInputToLowercase
  \ifboolTF{cpt@choicefd}{%
    \ifboolTF{LTS@pl}{%
      \rightaddtocs\LTS@tempc\@firstoftwo
    }{%
      \rightaddtocs\LTS@tempc\@firstofone
    }%
  }{%
    \ifboolTF{LTS@pl}{%
      \rightaddtocs\LTS@tempc\@secondoftwo
    }{%
      \rightaddtocs\LTS@tempc{#1{#2}{#3}\@gobbleone}%
    }%
  }%
  \expandafter\endgroup\LTS@tempc
}
\robust@def*\LTS@notpresent@handler#1#2{%
  \LTS@verboseinfo{None of the tokens '\detokenize{#1}'
    is found in '\detokenize{#2}'}%
}
\robust@def*\ltslowercasecontent#1{%
  \ltsifmacroTF{#1}{%
    \expandafter\if\expandafter\LTS@lwc\expandafter
    \lowercase\expandafter{\expandafter\fi\expandafter\def
    \expandafter#1\expandafter{#1}\if\LTS@lwc}\fi
  }{%
    \cpt@notcserr{#1}%
  }%
}
\robust@def*\ltsgetorderincsvlist{%
  \LTS@testst{\LTS@testopt\LTS@getorderincsvlist{,}}%
}
\robust@def*\LTS@getorderincsvlist[#1]{%
  \LTS@testpnopt{\LTS@g@torderincsvlist#1}\LTS@order
}
\robust@def*\LTS@g@torderincsvlist#1(#2)#3#4{%
  \def#2{-1}%
  \begingroup
  \ifboolTF{LTS@st}{%
    \edef\LTS@tempa{\simpleexpandarg\cpttrimspaces{#3}}%
    \let\LTS@tempb=#4%
  }{%
    \edef\LTS@tempa{\cpttrimspaces{#3}}
    \edef\LTS@tempb{\unexpanded{#4}}%
  }%
  \ltslowercasecontent\LTS@tempa
  \ltslowercasecontent\LTS@tempb
  \edef\LTS@tempa{\cptoxdetok\LTS@tempa}%
  \edef\LTS@tempb{\cptoxdetok\LTS@tempb}%
  \cpt@cnta\z@pt\def\LTS@tempc{}%
  \def\csv@do##1{%
    \def\LTS@tempb{##1}%
    \ifx\LTS@tempb\LTS@tempa
      \edef\LTS@tempc{\def\noexpand#2{\the\cpt@cnta}}%
      \loopbreak
    \fi
    \advance\cpt@cnta\@ne
  }%
  \csv@@parse*[,]\LTS@tempb
  \NoConvertInputToLowercase
  \expandafter\endgroup\LTS@tempc
}
\robust@def*\ifoneincommalistTF#1#2{%
  \if\LTS@lwc\LTS@sttrue\else\LTS@stfalse\fi
  \LTS@pltrue
  \LTS@ch@ckpresence[\val\nr]{#1}{#2}%
}
\robust@def*\ltscheckpresence{\LTS@teststpl\LTS@checkpresence}
\robust@def*\LTS@checkpresence{\LTS@testopt\LTS@ch@ckpresence{}}
\new@def*\LTS@ch@ckpresence[#1]#2#3{%
  \cpt@choicefdfalse
  \begingroup
  \ifLTS@st\lowercase{\fi
    \ifblankTF{#1}{%
      \def\LTS@tempa{\endgroup\LTS@ch@@@presence\LTS@nil{#2}{#3}}%
    }{%
      \def\LTS@tempa{\endgroup\LTS@ch@@kpresence#1\LTS@nil{#2}{#3}}%
    }%
  \ifLTS@st}\fi\LTS@tempa
}
\new@def*\LTS@ch@@kpresence#1#2\LTS@nil#3#4{%
  \ifblankTF{#2}%
    {\LTS@ch@@@presence#1{#3}{#4}}%
    {\LTS@ch@@@@resence#1#2{#3}{#4}}%
}
\new@def*\LTS@ch@@@presence#1#2#3{%
  \begingroup
  \def\LTS@tempc{#1}%
  \ifxTF\LTS@nnil\LTS@tempc{%
    \def\LTS@tempc{}%
  }{%
    \def\LTS@tempc{\def#1{#3}}%
  }%
  \edef\LTS@tempa{\detokenize{#3}}%
  \cpt@sttrue\cpt@csvnormalize[,]\LTS@tempa
  \def\csv@do##1{%
    \xifinsetFT{,\detokenize{##1},}{,\LTS@tempa,}{}{%
      \edef\LTS@tempc{\def\noexpand#1{\unexpanded{##1}}}%
      \cpt@choicefdtrue\loopbreak
    }%
  }%
  \csv@@parse[,]{#2}%
  \LTS@ch@@@@@oice\LTS@notpresent@handler{#2}{#3}%
}
\new@def*\LTS@ch@@@@resence#1#2#3#4{%
  \def#1{}\def#2{-1}%
  \begingroup
  \cpt@cnta\z@pt\def\LTS@tempc{}%
  \def\csv@do##1{%
    \xifinsetFT{,\detokenize{##1},}{,\detokenize{#4},}{}{%
      \edef\LTS@tempc{%
        \def\noexpand#1{\unexpanded{##1}}%
        \def\noexpand#2{\the\cpt@cnta}%
      }%
      \cpt@choicefdtrue\loopbreak
    }%
    \advance\cpt@cnta\@ne
  }%
  \csv@@parse[,]{#3}%
  \LTS@ch@@@@@oice\LTS@notpresent@handler{#3}{#4}%
}
% \ifmanyincsvlistTF[parser](no.){sublist}{mainlist}
% Check if the no. of elements of parser-separated list
% '#3' found in #4 is equal or greater than '#2'. #4
% is the main list. If the test is true, \itemspresent returns
% all the elements found and \noofitems returns the number
% of elements found:
\ifcsdefinable\itemspresent\relax
\ifcsdefinable\noofitems\relax
\robust@def*\ifmanyincsvlistTF{%
  \LTS@testopt\LTS@ifmanyincsvlistTF{,}%
}
\robust@def*\LTS@ifmanyincsvlistTF[#1]{%
   \LTS@testpnopt{\LTS@ifm@nyincsvlistTF#1}{1}%
}
\robust@def*\LTS@ifm@nyincsvlistTF#1(#2)#3#4{%
  \begingroup
  \if\LTS@lwc\lowercase{\fi
    \edef\LTS@tempa{\unexpanded{#3}}%
    \edef\LTS@tempb{\unexpanded{#4}}%
  \if\LTS@lwc}\fi
  \cpt@sttrue\cpt@csvnormalize[#1]\LTS@tempb
  \def\LTS@tempc{}\cpt@cnta\z@pt
  \def\csv@do##1{%
    \edef\x{\detokenize{#1}}%
    \xifinsetFT{\detokenize{#1##1#1}}{\x\cptoxdetok\LTS@tempb\x}{%
      \edef\LTS@tempc{\csliststack,\LTS@tempc\unexpanded{##1}}%
      \advance\cpt@cnta\@ne
      \ifnum\cpt@cnta>\numexpr#2-1\relax\loopbreak\fi
    }%
  }%
  \csv@@parse*[#1]\LTS@tempa
  \ifnum\cpt@cnta>\numexpr#2-1\relax
    \gletcs\itemspresent\LTS@tempc
    \xdef\noofitems{\the\cpt@cnta}%
  \else
    \gdef\itemspresent{}\gdef\noofitems{-1}%
  \fi
  \NoConvertInputToLowercase
  \csnendgroup{LTS@\ifnumcmpTF\cpt@cnta>\numexpr#2-1{1}2of2}%
}
% \ifmanyintsvlistTF(no){sublist}{mainlist}
% Check if the no. of elements of tsv list #2
% found in #3 is equal or greater than '#1'. #3
% is the main list. If the test is true, \itemspresent returns
% all the elements found and \noofitems returns the number
% of elements found:
\robust@def*\ifmanyintsvlistTF{%
  \LTS@testpnopt\LTS@ifmanyintsvlistTF{1}%
}
\robust@def*\LTS@ifmanyintsvlistTF(#1)#2#3{%
  \begingroup
  \if\LTS@lwc\lowercase{\fi
    \edef\LTS@tempa{\unexpanded{#2}}%
    \edef\LTS@tempb{\unexpanded{#3}}%
  \if\LTS@lwc}\fi
  \def\LTS@tempc{}\cpt@cnta\z@pt
  \def\tsv@do##1{%
    \xifinsetFT{\detokenize{##1}}{\cptoxdetok\LTS@tempb}{}{%
      \edef\LTS@tempc{\csliststack,\LTS@tempc\unexpanded{##1}}%
      \advance\cpt@cnta\@ne
      \ifnum\cpt@cnta>\numexpr#1-1\relax\loopbreak\fi
    }%
  }%
  \tsv@@parse*\LTS@tempa
  \ifnum\cpt@cnta>\numexpr#1-1\relax
    \gletcs\itemspresent\LTS@tempc
    \xdef\noofitems{\the\cpt@cnta}%
  \else
    \gdef\itemspresent{}\gdef\noofitems{-1}%
  \fi
  \NoConvertInputToLowercase
  \csnendgroup{LTS@\ifnumcmpTF\cpt@cnta>\numexpr#1-1{1}2of2}%
}
\robust@def*\LTS@undeftogerr#1{%
  \LTS@err{Toggle '#1' undefined}%
    {You need to first define toggle '#1' before use.}%
}
\providecommand*\newtog[1]{\cpt@swatrue\LTS@testopt{\LTS@newtog{#1}}{false}}
\robust@def*\deftog#1{\cpt@swafalse\LTS@testopt{\LTS@newtog{#1}}{false}}
\new@def*\LTS@newtog#1[#2]{%
  \begingroup
  \ifinsetFT{,}{#1}{}{%
    \edef\x{\ifcpt@swa'\string\newtog'\else'\string\deftog'\fi}%
    \edef\y{\ifcpt@swa'\string\NewTogs'\else'\string\DefTogs'\fi}%
    \LTS@err{Command \x doesn't accept list}{%
      Please submit only one toggle to \x at a time.
      \MsgBrk You can use \y to define a set of togs.
    }%
  }%
  \endgroup
  \ltsensurenoscape{#1}%
  \ifboolTF{cpt@swa}{%
    \ifcsndefFT{cpt@tog@#1}{}{%
      \LTS@err{Toggle '#1' already defined}%
        {Please provide a new toggle or use '\string\deftog'.}%
    }%
    \LTS@getboolstate\newtog{#2}%
  }{%
    \ifcsndefFT{cpt@tog@#1}{}{%
      \LTS@verbosewarn{Toggle '#1' redefined}%
    }%
    \LTS@getboolstate\deftog{#2}%
  }%
  \letcsntocsn{cpt@tog@#1}{@\cptstrcmp
    {\LTS@boolval}{true}{first}{second}oftwo}%
}
\providecommand*\providetog[1]{%
  \ifcsndefTF{cpt@tog@#1}{%
    \LTS@verboseinfo{Toggle '#1' already defined.\MsgBrk
      Not redefined}%
  }{%
    \letcsntocs{cpt@tog@#1}\@secondoftwo
  }%
}
\providecommand*\requiretog[1]{%
  \aftercsname\ltsneedcommand{cpt@tog@#1}[2]{##2}%
}
\newtog{pdf}[false]
\newletcs\ifpdfTF\@secondoftwo
\newletcs\ifpdfFT\@firstoftwo
\ifdefTF\pdfoutput{%
  \ifnumcmpTF\pdfoutput<\@ne{}{%
    \settogtrue{pdf}%
    \let\ifpdfTF\@firstoftwo
    \let\ifpdfFT\@secondoftwo
  }%
}{}
\new@def*\ltssavecs#1{%
  \ltsensurescape{#1}%
  \ifcsndefTF{saved\cptgobblescape#1}{%
    \LTS@err{\noexpand#1 already saved. You've to restore
      \MsgBrk it or undefine '\noexpandcsn{saved\cptgobblescape#1}'
      before\MsgBrk you can save \noexpand#1 again}\@ehc
  }{%
    \ifdefTF#1{%
      \letcsntocs{saved\cptgobblescape#1}#1%
      \ifcsndefFT{\string#1}{}{%
        \letcsntocsn{@saved\cptgobblescape#1}{\string#1}%
      }%
      \ifcsndefFT{\cptgobblescape#1\@space}{}{%
        \letcsntocsn{@@saved\cptgobblescape#1}%
          {\cptgobblescape#1\@space}%
      }%
      \ifcsndefFT{\string#1\@space}{}{%
        \letcsntocsn{@@@saved\cptgobblescape#1}{\string#1\@space}%
      }%
    }{%
      \LTS@err{Undefined '\string#1' couldn't be saved\on@line}%
        {You can't restore undefined commands. So why save\MsgBrk
        undefined '\string#1' here?}%
    }%
  }%
}
\new@def*\ltsrestorecs#1{%
  \ltsensurescape{#1}%
  \ifcsndefTF{saved\cptgobblescape#1}{%
    \letcstocsn#1{saved\cptgobblescape#1}%
    \gundefcsn{saved\cptgobblescape#1}%
    \ifcsndefFT{@saved\cptgobblescape#1}{}{%
      \letcsntocsn{\string#1}{@saved\cptgobblescape#1}%
      \gundefcsn{@saved\cptgobblescape#1}%
    }%
    \ifcsndefFT{@@saved\cptgobblescape#1}{}{%
      \letcsntocsn{\cptgobblescape#1\@space}%
        {@@saved\cptgobblescape#1}%
      \gundefcsn{@@saved\cptgobblescape#1}%
    }%
    \ifcsndefFT{@@@saved\cptgobblescape#1}{}{%
      \letcsntocsn{\string#1\@space}{@@@saved\cptgobblescape#1}%
      \gundefcsn{@@@saved\cptgobblescape#1}%
    }%
  }{%
    \LTS@err{No saved version of '\string#1' is available:\MsgBrk
      '\string#1' couldn't be restored\on@line
    }{%
      Unsaved '\string#1' can't be restored.\MsgBrk
      Note that each call to \noexpand\ltsrestorecs
      undefines the saved command.
    }%
  }%
}
\providecommand*\input@path{}
\robust@def*\InputFileOnce{%
  \ltssavecs\input@path
  \LTS@testst{\LTS@testpl{\LTS@testopt\LTS@inputfileonce{.}}}%
}
\new@def*\LTS@inputfileonce[#1]#2{%
  \ifblankTF{#1}{}{\grightaddtocs\input@path{{#1/}}}%
  \ifboolTF{LTS@st}{%
    \LTS@inp@tfileonce{#2}%
  }{%
    \ifcsndefTF{#2@LTS@read}{%
      \ifLTS@verbose
        \LTS@info{File '#2' already read:\MsgBrk
          File '#2' wasn't read again}%
      \fi
    }{%
      \LTS@inp@tfileonce{#2}%
    }%
  }%
}
\def\LTS@inp@tfileonce#1{%
  \def\reserved@a##1##2{%
    \IfFileExists{#1}{##1\@filef@und##2}%
  }%
  \ifboolTF{LTS@pl}{%
    \reserved@a\include
  }{%
    \reserved@a\@@input
  }{%
    \letcsntocs{#1@LTS@read}\relax
    \ltsrestorecs\input@path
  }{%
    \typein[\@gtempa]{^^J! File '\string#1' does not exist.
      ^^JEnter filename or 'x' and <return> to continue.}%
    \def\reserved@a{x}%
    \ifxTF\@gtempa\reserved@a{%
      \ltsrestorecs\input@path
    }{%
      \cptexpandarg{\LTS@inputfileonce[]}\@gtempa
    }%
  }%
}
\new@def*\ltsxcounttokens#1{%
  \long\def\ltsxcounttokens##1{%
    \the\numexpr\expandafter
    \LTS@xcounttokens##1#1\cpt@nnil\cpt@nnil\relax
  }%
}
\ltsxcounttokens{ }
\new@def\LTS@xcounttokens#1{%
	\expandafter\ifxTF\cpt@car#1\car@nil
  \cpt@nnil{0\cpt@removetonnil}{1+\LTS@xcounttokens}%
}
\robust@def*\ltscountalltokens#1{%
  \def\ltscountalltokens##1{%
    \def\nr{\m@one}%
	  \def\@counttokens{\futurelet\@let@token\LTS@countalltokens}%
	  \expandafter\@counttokens##1#1\cpt@nnil
  }%
}
\ltscountalltokens{ }
\robust@def*\LTS@countalltokens{%
  \ifxTF\@let@token\cpt@nnil\cpt@removetonnil{%
		\edef\nr{\the\numexpr\nr+1}%
    \afterassignment\@counttokens
	  \let\@let@token= %
	}%
}
\robust@def*\ltscounttokens{\LTS@testst\LTS@counttokens}
\robust@def\LTS@counttokens#1{%
  \begingroup
  \def\nr{0}\def\emp{0}\def\spo{0}%
  \def\siso@do##1{%
    \ifx\@empty##1\@empty
      \edef\emp{\the\numexpr\emp+1}%
      \edef\nr{\the\numexpr\nr+1}%
    \else
      \ifx##1\@sptoken
        \edef\spo{\the\numexpr\spo+1}%
        \edef\nr{\the\numexpr\nr+1}%
      \else
        \edef\nr{\the\numexpr\nr+1}%
      \fi
    \fi
  }%
  \ifboolTF{LTS@st}{%
    \expandafter\siso@@loop\expandafter{#1}%
  }{%
    \siso@@loop{#1}%
  }%
  \cptpassexpanded{%
    \endgroup
    \def\noexpand\nonempty{\nr}%
    \def\noexpand\nr{{\nr}{\emp}{\spo}}%
  }%
}
\newcommand*\ltscountargs[1]{%
  \protected\def\ltscountargs##1{%
    \begingroup
    \@tempcnta\z@pt\@tempcntb\z@pt\cpt@cnta\z@pt
    \def\end@countargs{\end@countargs}%
    \def\LTS@countargs@a{\futurelet\next\LTS@countargs@c}%
    \def\LTS@countargs@b####1{\LTS@countargs@a}%
    \expandafter\LTS@countargs@a##1#1\end@countargs
  }%
}
\ltscountargs{ }
\def\LTS@countargs@c{%
	\ifxTF\next\end@countargs{%
    \edef\next{%
      \endgroup
      \edef\noexpand\argcount{\the\numexpr\the\@tempcnta-1}%
      \edef\noexpand\spacecount{\the\numexpr\the\@tempcntb-1}%
      \edef\noexpand\nonspacecount{\the\cpt@cnta}%
    }%
    \expandafter\next\@gobble
  }{%
    \advance\@tempcnta\@ne
    \ifxTF\next\@sptoken{%
      \advance\@tempcntb\@ne
      \afterassignment\LTS@countargs@a\let\next= %
    }{%
      \advance\cpt@cnta\@ne
      \LTS@countargs@b
    }%
  }%
}
\robust@def*\macronizetokens{%
  \begingroup
  \@makeother{\#}%
  \endlinechar\m@one
  \LTS@testopt\LTS@macronize{}%
}
\robust@def*\LTS@macronize[#1]#2#3{%
  \toks0{#3}%
  \scantokens{\toks1{#3}}%
  \xifstrcmpTF{\the\toks0}{\the\toks1}{}{%
    \LTS@err{I can't macronize unscannable tokens:
      ^^J^^J||\detokenize{#3}||}\@ehc
  }%
  \endgroup
  \begingroup
  \LTS@twohashcheck{#3}{}{%
    \LTS@err{Illegal nested parameters in:
      ^^J^^J\detokenize{#3}}\@ehc
  }%
  \edef\reserved@e{\detokenize{#3}}%
  \chardef\nr@b\z@pt
  \xifinsetFT\LTS@hashchar\reserved@e{}{%
    \def\nr@a{1}%
    \cptwhilenum\nr@a<10\do{%
      \cptexpandtwoargs\cpt@in{\LTS@hashchar\nr@a}{\reserved@e}%
      \ifcpt@in\let\nr@b\nr@a\fi
      \pushnumber\nr@a
    }%
    \ifnum\nr@b>\z@pt
      \cptemptify#2\def\nr@a{1}%
      \cptwhilenum\nr@a<\numexpr\nr@b+1\do{%
        \edef#2{\expandcsonce#2\LTS@hashchar\nr@a}%
        \pushnumber\nr@a
      }%
    \fi
  }%
  \edef#2{#1\def\string#2#2{\reserved@e}}%
  \LTS@scantoksd\endgroup#2%
}
\robust@def*\ifmeaningTF#1#2{%
  \begingroup
  \ifdefFT{#1}{%
    \endgroup\@secondoftwo
  }{%
    \edef\LTS@tempa{\realmeaning{#1}}%
    \edef\LTS@tempb{\detokenize{#2}}%
    \csnendgroup{LTS@\ifxTF\LTS@tempa\LTS@tempb12of2}%
  }%
}
\robust@def*\ifactivecharTF#1{%
  \begingroup
  \ltsifmacroTF{#1}{%
    \edef\LTS@tempa{\string#1}%
    \def\LTS@tempb{#1}%
    \edef\LTS@tempb{\realmeaning\LTS@tempb}%
    \csnaftergroup{LTS@\ifxTF\LTS@tempa\LTS@tempb12of2}%
  }{%
    \aftergroup\@secondoftwo
  }%
  \endgroup
}
\robust@def*\ltsifmacroTF#1{%
  \begingroup
  \edef\LTS@tempa##1{\def##1####1\detokenize{macro}:####2&}%
  \LTS@tempa\LTS@tempa{%
    \csnaftergroup{LTS@\ifblankTF{##2}21of2}%
  }%
  \edef\LTS@tempb##1{##1\detokenize{macro}:&}%
  \LTS@tempb{\expandafter\LTS@tempa\meaning#1}%
  \endgroup
}
\robust@def*\ltsifmacroFT#1{\ltsifmacroTF{#1}\iiofii\iofii}
\robust@def*\ifparamacroTF#1{%
  \begingroup
  \edef\LTS@tempa##1{\def##1####1\detokenize{macro}:####2->####3&}%
  \LTS@tempa\LTS@tempa{%
    \csnaftergroup{LTS@\ifblankTF{##2}21of2}%
  }%
  \edef\LTS@tempb##1{##1\detokenize{macro}:->&}%
  \LTS@tempb{\expandafter\LTS@tempa\meaning#1}%
  \endgroup
}
\robust@def*\ifparamacroFT#1{\ifparamacroTF{#1}\iiofii\iofii}
\robust@def*\ifcsnparamacroTF{\aftercsname\ifparamacroTF}
\robust@def*\ifprefmacroTF#1{%
  \begingroup
  \ifmacroFT{#1}{%
    \aftergroup\@secondoftwo
  }{%
    \edef\LTS@tempa##1{\def##1####1\detokenize{macro}:####2&}%
    \LTS@tempa\LTS@tempa{%
      \csnaftergroup{LTS@\ifblankTF{##1}21of2}%
    }%
    \edef\LTS@tempb##1{##1\detokenize{macro}:&}%
    \LTS@tempb{\expandafter\LTS@tempa\meaning#1}%
  }%
  \endgroup
}
\robust@def*\ifprefmacroFT#1{\ifprefmacroTF{#1}\iiofii\iofii}
\robust@def*\ifprimitiveTF#1{%
  \begingroup
  \ltsifmacroTF{#1}{%
    \endgroup\@secondoftwo
  }{%
    \def\LTS@tempa##1##2&{%
      \csnendgroup{LTS@\if##1\@backslashchar1\else2\fi of2}%
    }%
    \expandafter\LTS@tempa\meaning#1&%
  }%
}
\robust@def*\ifprimitiveFT#1{\ifprimitiveTF{#1}\iiofii\iofii}
\robust@def\ifpatternTF#1#2{%
  \begingroup
  \edef\LTS@tempa##1{\def##1####1\detokenize{#1}####2&}%
  \LTS@tempa\LTS@tempa{%
    \csnaftergroup{LTS@\ifblankTF{##2}21of2}%
  }%
  \edef\LTS@tempb##1{##1\detokenize{#1}&}%
  \LTS@tempb{\expandafter\LTS@tempa\meaning#2}%
  \endgroup
}
\robust@def*\ifpatternFT#1#2{\ifpatternTF{#1}{#2}\iiofii\iofii}
\robust@def*\ifnopattern#1\in#2{\ifpatternFT{#1}{#2}}
\robust@def*\ifscannableTF#1{%
  \begingroup
  \edef\LTS@rsvda##1{%
    \def##1####1\detokenize{macro}:####2->####3&{%
      ####1\def\string\LTS@rsvda####2{####3}%
    }%
    \edef##1{##1\meaning#1&}%
  }%
  \LTS@rsvda\LTS@rsvda
  \makeatletter\everyeof{\noexpand}\endlinechar\m@one
  \scantokens\expandafter{\LTS@rsvda}\relax
  \csnendgroup{LTS@\expandafter\ifxTF\cpt@car#1\car@nil
  \LTS@rsvda12of2}%
}
\robust@def*\ifscannableFT#1{\ifscannableTF{#1}\iiofii\iofii}
\robust@def*\delimitmacro#1#2{%
  \ifsingletokenTF{#2}{}{%
    \LTS@err{Delimiter '\detokenize{#2}' is more than
      one token}\@ehc
  }%
  \ifscannableTF#1{%
    \begingroup
    \edef\LTS@tempa##1{%
      \def##1####1\detokenize{macro:}####2->####3&{%
        ####1\def\string#1####2\string#2{####3}%
      }%
      \edef##1{##1\meaning#1&}%
    }%
    \LTS@tempa\LTS@tempa
    \LTS@scantoksd\endgroup\LTS@tempa
  }{%
    \LTS@err{Your \noexpand#1 isn't scannable}{%
      Sorry, I can't delimit the last parameter of your\MsgBrk
      command \noexpand#1: it isn't scannable.
    }%
  }%
}
\robust@def*\LTS@stepdownhash{%
  \begingroup
  \@makeother{\#}%
  \endlinechar\m@one
  \LTS@st@pdownhash
}
\robust@def*\LTS@st@pdownhash#1#2{%
  \xifinsetTF{\detokenize{##}}{\detokenize{#1}}{%
    \edef\LTS@rsvda##1{##1\detokenize{#1##}&}%
    \edef\LTS@rsvdb##1{\def##1####1\detokenize{##}####2&}%
    \LTS@rsvdb\LTS@rsvdb{%
      \ifblankTF{##2}{%
        \toks@\expandafter{\the\toks@##1}%
      }{%
        \cptpassexpanded{\toks@{\the\toks@##1\LTS@hashchar}}%
        \LTS@rsvdb##2&%
      }%
    }%
    \LTS@rsvda{\toks@{}\LTS@rsvdb}%
    \edef#2{\the\toks@}%
  }{%
    \edef#2{\detokenize{#1}}%
  }%
  \postgroupdef#2\endgroup
}
\robust@def*\LTS@stepuphash{%
  \begingroup
  \@makeother{\#}%
  \endlinechar\m@one
  \LTS@st@puphash
}
\robust@def*\LTS@st@puphash#1#2{%
  \xifinsetTF{\LTS@hashchar}{\detokenize{#1}}{%
    \edef\LTS@rsvda##1{##1\detokenize{#1}\LTS@hashchar&}%
    \edef\LTS@rsvdb##1{\def##1####1\LTS@hashchar####2&}%
    \LTS@rsvdb\LTS@rsvdb{%
      \ifblankTF{##2}{%
        \toks@\expandafter{\the\toks@##1}%
      }{%
        \cptpassexpanded{\toks@{\the\toks@##1\LTS@hashchar\LTS@hashchar}}%
        \LTS@rsvdb##2&%
      }%
    }%
    \LTS@rsvda{\toks@{}\LTS@rsvdb}%
    \edef#2{\the\toks@}%
  }{%
    \edef#2{\detokenize{#1}}%
  }%
  \postgroupdef#2\endgroup
}
\robust@def*\LTS@onehashcheck#1{%
  \begingroup
  \edef\LTS@rsvda##1{\def##1####1\LTS@hashchar####2&}%
  \LTS@rsvda\LTS@rsvda{%
    \csnaftergroup{LTS@\ifblankTF{##2}12of2}%
  }%
  \edef\LTS@rsvdb##1{##1\detokenize{#1}\LTS@hashchar&}%
  \LTS@rsvdb\LTS@rsvda
  \endgroup
}
\robust@def*\LTS@twohashcheck#1{%
  \begingroup
  \edef\LTS@rsvda##1{\def##1####1\detokenize{##}####2&}%
  \LTS@rsvda\LTS@rsvda{%
    \csnendgroup{LTS@\ifblankTF{##2}12of2}%
  }%
  \edef\LTS@rsvdb##1{##1\detokenize{#1}\detokenize{##}&}%
  \LTS@rsvdb\LTS@rsvda
}
\robust@def*\robustifycs{\LTS@testopt\LTS@robustifycs{}}
\robust@def*\LTS@robustifycs[#1]#2{%
  \ifdefFT{#2}{%
    \cpt@notdeferr{#2}%
  }{%
    \ltsifmacroTF{#2}{%
      \ifetexprotectedTF{#2}{%
        \LTS@verboseinfo
          {Protected command '\string#2' not re-protected}%
      }{%
        \ifltxprotectTF{#2}{%
          \letcstocsn\LTS@rsvda{\cptgobblescape#2\@space}%
          \cpt@swatrue
        }{%
          \let\LTS@rsvda#2\cpt@swafalse
        }%
        \ifparamacroTF\LTS@rsvda{%
          \ifscannableTF\LTS@rsvda{%
            \begingroup
            \edef\LTS@rsvdb##1{%
              \def##1####1\detokenize{macro}:####2->####3&{%
                #1\protected####1\def\string\LTS@rsvda####2{####3}%
              }%
              \edef##1{##1\meaning\LTS@rsvda&}%
            }%
            \LTS@rsvdb\LTS@rsvdb
            \LTS@scantoksd\endgroup\LTS@rsvdb
            \let#2\LTS@rsvda
          }{%
            \LTS@err{Command '\string#2' can't be made robust}%
              {Command '\string#2' isn't retokenizable.}%
            \cpt@swafalse
          }%
        }{%
          \protected#1\edef#2{\expandcsonce\LTS@rsvda}%
        }%
        \ifcpt@swa
          \ifcsndefTF{\string#2\@space}{}%
            {\undefcsn{\cptgobblescape#2\@space}}%
        \fi
      }%
    }{%
      \LTS@err{Command '\string#2' isn't a macro}%
        {Command '\string#2' can't be made robust.}%
    }%
  }%
}
\robust@def*\robustifycsn{\LTS@testopt\LTS@robustifycsn{}}
\robust@def*\LTS@robustifycsn[#1]#2{%
  \cptexpandarg{\robustifycs[#1]}{\noexpandcsn{#2}}%
}
\robust@def*\robustifycsset{\LTS@testopt\LTS@robustifycsset{}}
\robust@def*\LTS@robustifycsset[#1]#2{%
  \def\csv@do##1{%
    \ltsensuremacro{##1}%
    \robustifycs[#1]{##1}%
  }%
  \csv@@parse[,]{#2}%
}
\new@def*\LTS@hookfail#1#2{%
  \LTS@warn{Hooking to command '\string#1' failed:\MsgBrk#2}%
}
% [<prefix>]{<cmd1>}{<cmd2>}{<success>}{<failure>}
\robust@def*\apptoparamcs{%
  \long\def\setarg##1##2{##1##2}%
  \begingroup\@makeother{\#}\LTS@hooktoparamcs
}
\robust@def*\preptoparamcs{%
  \let\setarg\cptswap
  \begingroup\@makeother{\#}\LTS@hooktoparamcs
}
\newcommand\LTS@hooktoparamcs[3][]{%
  \endgroup
  \ifdefFT{#2}{%
    \LTS@hookfail{#2}{Command isn't defined or is relaxed}%
    \@secondoftwo
  }{%
    \ltsifmacroTF{#2}{%
      \ifparamacroTF{#2}{%
        \ifscannableTF{#2}{%
          \LTS@twohashcheck{#3}{%
            \ifblankTF{#1}{%
              \LTS@h@oktoparamcs{#2}{#3}%
            }{%
              \LTS@h@oktoparamcs[#1]{#2}{#3}%
            }%
            \@firstoftwo
          }{%
            \LTS@hookfail{#2}{Nested commands or parameters}%
            \@secondoftwo
          }%
        }{%
          \LTS@hookfail{#2}{Macro can't be retokenized\MsgBrk
            safely after patching}%
          \@secondoftwo
        }%
      }{%
        \LTS@onehashcheck{#3}{%
          \LTS@verboseinfo{Macro '\string#2' patched successfully}%
          \ifetexprotectedTF{#2}\protected\relax
          #1\edef#2{\setarg{\expandcsonce#2}{\unexpanded{#3}}}%
          \LTS@verboseinfo{Macro '\string#2' patched successfully}%
          \@firstoftwo
        }{%
          \LTS@hookfail{#2}{Command is a parameterless macro
            \MsgBrk but you're hooking with a parametered macro}%
          \@secondoftwo
        }%
      }%
    }{%
      \LTS@hookfail{#2}{Command isn't a macro}%
      \@secondoftwo
    }%
  }%
}
\newcommand\LTS@h@oktoparamcs[3][]{%
  \begingroup
  \edef\LTS@tempa##1{%
    \def##1####1\detokenize{macro}:####2->####3&{%
      #1####1\def\string#2####2{\setarg{####3}{\detokenize{#3}}}%
    }%
    \edef##1{##1\meaning#2&}%
  }%
  \LTS@tempa\LTS@tempa
  \LTS@scantoksd\endgroup\LTS@tempa
}
\robust@def*\TracingPatchesOn{\let\LTS@tracepatches\cptswtrue}
\robust@def*\TracingPatchesOff{\let\LTS@tracepatches\cptswfalse}
% [<prefix>]{<cmd>}{<search>}{<replace>}
\robust@def*\simplecmdpatch{%
  \begingroup
  \@makeother{\#}%
  \endlinechar\m@one
  \LTS@testopt\LTS@simplecmdpatch{####1}%
}
\new@def*\LTS@simplecmdpatch[#1]#2#3#4{%
  \if\LTS@tracepatches
    \typeout{^^J** Debugging patches: command '\string#2'}%
  \fi
  \endgroup
  \begingroup
  \edef\LTS@tempa##1##2{%
    \def##1####1\detokenize{macro:}####2->####3&{%
      #1\def\string#2####2{##2####3&}%
    }%
    \def##2####1\detokenize{#3}####2&{####1\detokenize{#4}####2}%
    \edef##1{##1\meaning#2&}%
  }%
  \LTS@tempa\LTS@tempa\LTS@tempb
  \catcode`\#=6\relax\makeatletter
  \LTS@scantoksd\endgroup\LTS@tempa
}
% [<prefix>]{<cmd>}{<search>}{<replace>}{<success>}{<failure>}
\robust@def*\patchcs{%
  \LTS@ifstar\LTS@patchcs@b\LTS@patchcs@a
}
\robust@def*\LTS@patchcs@a{%
  \let\LTS@hashcheckorno\LTS@twohashcheck
  \begingroup
  \@makeother{\#}\endlinechar\m@one
  % If \LTS@testopt uses a different definition of
  % \@ifnextchar, the number of hash characters here
  % would have to change; it will most likely become 8:
  \LTS@testopt\LTS@patchcs{####1}%
}
\robust@def*\LTS@patchcs@b{%
  \if\stricthashcheck
    \LTS@err{Patching failed: you can't use the star (*)
      \MsgBrk variant while strict hash check is in force.
      \MsgBrk Relax strict hash check with
      '\string\NoStrictHashCheck'}\@ehc
  \fi
  \let\LTS@hashcheckorno\ifblankFT
  \begingroup
  \@makeother{\#}\endlinechar\m@one
  \LTS@testopt\LTS@patchcs{####1}%
}
\new@def*\LTS@patchcs[#1]#2#3#4{%
  \if\LTS@tracepatches
    \typeout{^^J** Debugging patches: command '\string#2'}%
  \fi
  \LTS@hashcheckorno{#4}{%
    \LTS@p@tchcs{#1}{#2}{#3}{#4}%
  }{%
    \endgroup
    \LTS@patchdebug{--}{Nested parameters}%
    \@secondoftwo
  }%
}
\new@def*\LTS@p@tchcs#1#2#3#4{%
  \LTS@ifpatchable{#2}{#3}{#4}{%
    \LTS@patchdebug{++}{Command is patchable}%
    \LTS@patchdebug{==}{Patching has begun}%
    \begingroup
    \edef\LTS@tempa##1##2{%
      \def##1####1\detokenize{macro:}####2->####3&{%
        #1\def\string#2####2{##2####3&}%
      }%
      \def##2####1\detokenize{#3}####2&{####1\detokenize{#4}####2}%
      \edef##1{##1\meaning#2&}%
    }%
    \LTS@tempa\LTS@tempa\LTS@tempb
    \LTS@scantoksd\endgroup\LTS@tempa
    \LTS@patchdebug{==}{Patching completed successfully}%
    \@firstoftwo
  }{%
    \LTS@patchdebug{--}{Patching couldn't be completed}%
    \@secondoftwo
  }%
}
\new@def*\LTS@patchdebug#1#2{%
  \if\LTS@tracepatches
    \typeout{[debug] #1 #2}%
  \fi
}
\robust@def*\LTS@ifpatchable#1#2#3{%
  \endgroup
  \ifdefswitchTF{stricthashcheck}{%
    \LTS@patchdebug{==}{'stricthashcheck' set true}%
    % If #3 is macronizable, then it is scannable.
    % Macronizing doesn't accept nested hash, but
    % we're already in strict mode here.
    \macronizetokens\LTS@rsvda{#3}%
    \LTS@patchdebug{++}{No illegal nested parameters in command}%
  }{}%
  \ifdefFT{#1}{%
    \LTS@patchdebug{--}{Command not defined}%
    \@secondoftwo
  }{%
    \LTS@patchdebug{++}{Command is defined}%
    \ltsifmacroTF{#1}{%
      \LTS@patchdebug{++}{Command is a macro}%
      \ifscannableTF{#1}{%
        \LTS@patchdebug{++}{Macro can be retokenized safely
          after patching}%
        \LTS@hashcheckorno{#2}{%
          \LTS@patchdebug{++}{No nested parameters in command
            or 'stricthashcheck' is false}%
          \ifpatternTF{#2}{#1}{%
            \LTS@patchdebug{++}{Requested search pattern found}%
            \@firstoftwo
          }{%
            \LTS@patchdebug{--}{Requested search pattern not found}%
            \@secondoftwo
          }%
        }{%
          \LTS@patchdebug{--}{Nested commands or parameters}%
          \@secondoftwo
        }%
      }{%
        \LTS@patchdebug{--}{Macro can't be retokenized
          safely after patching}%
        \@secondoftwo
      }%
    }{%
      \LTS@patchdebug{--}{Command isn't a macro}%
      \@secondoftwo
    }%
  }%
}
\robust@def*\ifpatchableTF{\begingroup\LTS@ifpatchable}
\robust@def*\reverseexpansion#1#2{%
  \ifnum#2=\@ne
    \LTS@err{Invalid expansion order '\string#2' for
      '\string\reverseexpansion'}{Why not just use
      '\string\expandafter' here instead\MsgBrk of
      '\string\reverseexpansion'?}%
    \expandafter\@gobbleone
  \fi
  \ifcase\numexpr#2-2\relax
    \def\LTS@rsvda{2,2}%
  \or
    \def\LTS@rsvda{3,4,4}%
  \or
    \def\LTS@rsvda{4,6,8,8}%
  \else
    \LTS@err{Invalid expansion order \string#2}
      {Number '\string#2' of '\string\reverseexpansion'
      is too large.}%
    \expandafter\@gobble
  \fi
  \def\csv@do##1{%
    \LTS@sttrue\LTS@expandoneahead#1{##1}%
  }%
  \csv@@loop*[,]\LTS@rsvda
}
\robust@def*\expandoneahead{\LTS@testst\LTS@expandoneahead}
\robust@def\LTS@expandoneahead#1#2{%
  \begingroup
  \ltsmakecsn{\{}\lb\ltsmakecsn{\}}\rb
  \toks@{}%
  \@tempcnta\m@one
  \def\LTS@i{\futurelet\next\LTS@iv}%
  \def\LTS@ii{\afterassignment\LTS@i\let\next= }%
  \def\LTS@iii##1{%
    \ifnum\@tempcnta<#2\relax
      \ifx##1\bgroup\relax
        \toks@\expandafter{\the\expandafter
          \toks@\expandafter\expandafter\lb}%
      \else
        \ifx##1\egroup\relax
          \toks@\expandafter{\the\expandafter\toks@
            \expandafter\expandafter\rb}%
        \else
          \toks@\expandafter{\the\toks@\expandafter##1}%
        \fi
      \fi
    \else
      \ifx##1\bgroup
        \toks@\expandafter{\the\expandafter\toks@\lb}%
      \else
        \ifx##1\egroup
          \toks@\expandafter{\the\expandafter\toks@\rb}%
        \else
          \toks@\expandafter{\the\toks@##1}%
        \fi
      \fi
    \fi
  }%
  \def\LTS@iv{%
    \advance\@tempcnta\@ne
    \ifx\next\end
      \let\cmd\@gobbleone
    \else
      \ifx\next\@sptoken
        \toks@\expandafter{\the\toks@ \expandafter\@space}%
        \let\cmd\LTS@ii
      \else
        \ifx\next\bgroup
          \LTS@iii\bgroup\let\cmd\LTS@ii
        \else
          \ifx\next\egroup
            \LTS@iii\egroup\let\cmd\LTS@ii
          \else
            \let\cmd\LTS@v
          \fi
        \fi
      \fi
    \fi
    \cmd
  }%
  \def\LTS@v##1{\LTS@iii##1\LTS@i}%
  \ifdefboolFT{LTS@st}{}\expandafter\LTS@i#1\end
  \edef\LTS@resa{\the\toks@}%
  \postgroupdef\LTS@resa\endgroup
  \LTS@scantoksa\LTS@resa
  \ifLTS@st\let#1\LTS@resa\fi
}
\robust@def*\expandallonce{\LTS@testopt\LTS@expandallonce\@M}
\robust@def*\LTS@expandallonce[#1]#2{%
  \begingroup
  \let\temp@bgroup\bgroup
  \let\bgroup\LTS@undefined
  \cpt@cnta#1\relax\advance\cpt@cnta\@ne
  \LTS@exp@ndallonce#2%
  \postgroupdef#2\endgroup
  \NoExpandPrimitives
}
\new@def*\LTS@exp@ndallonce#1{%
  \def\LTS@i{\futurelet\next\LTS@ii}%
  \def\LTS@ii{%
    \expandafter\LTS@iii\meaning\next\LTS@nil
    \ifx\next\end
      \let\cmd\@gobbleone
    \else
      \ifx\next\@sptoken
        \edef#1{\expandcsonce#1\@space}%
        \csn@def{cmd} {\LTS@i}%
      \else
        \let\cmd\LTS@iv
      \fi
    \fi
    \cmd
  }%
  \def\LTS@iii##1##2\LTS@nil{\if##1\@backslashchar\let\next\relax\fi}%
  \def\LTS@iv##1{%
    \toks@\expandafter{#1}\toks1{##1}%
    \ifx\next\temp@bgroup
      \advance\cpt@cnta\m@one
      \ifnum\cpt@cnta>\z@pt
        \begingroup
        \aftercsname\edef{\string#1}{\the\toks1}%
        \aftercsname\LTS@exp@ndallonce{\string#1}%
        \toks1\cptsevenxp{\usename{\string#1}}%
        \edefpass#1{\endgroup\toks1{\the\toks1}}%
      \fi
      \edef#1{\the\toks@{\the\toks1}}%
      \advance\cpt@cnta\@ne
    \else
      \edef#1{\the\toks1}%
      \LTS@exp@nd@llonce#1%
      \edef#1{\the\toks@\expandcsonce#1}%
    \fi
    \LTS@i
  }%
  \expandafter\cptemptify\expandafter#1\expandafter\LTS@i#1\end
}
\robust@def*\LTS@exp@nd@llonce#1{%
  \begingroup
  \oifmacroTF#1{%
    \edef#1{\noexpand\expandcsonce\expandcsonce#1}
  }{%
    \edef\LTS@rsvda{\cptsevenxp\LTS@car\cptoxdetok{#1}x\car@nil}%
    \ifxTF\LTS@rsvda\@backslashchar{%
      \simpleexpandarg\ifprimitiveTF{#1}{%
        \if\LTS@expprim
          \edef#1{\expandcsonce#1}%
        \else
          \edef#1{\noexpand\noexpand\expandcsonce#1}%
        \fi
      }{%
        \edef#1{\noexpand\noexpand\expandcsonce#1}%
      }%
    }{%
      \edef#1{\expandcsonce#1}%
    }%
  }%
  \postgroupdef#1\endgroup
}
\new@def*\CurrentPackageOrClass{\@cls@pkg\@space'\@currname'}
\new@def*\LTS@parsedate#1/#2/#3 v#4\LTS@nil{#1/#2/#3}
\robust@def*\LTS@notloadederr#1{%
  \ifcsndefTF{ver@#1.\@pkgextension}{}{%
    \LTS@err{Package '#1' wasn't loaded}
      {Document has begun and package '#1' wasn't loaded.
        \MsgBrk You wanted package '#1' loaded.}%
  }%
}
\new@def*\LTS@notloaded{}
\robust@def*\ensurepackageloaded#1{%
  \def\csv@do##1{%
    \grightaddtocs\LTS@notloaded{\LTS@doloaded{##1}}%
  }%
  \csv@@parse[,]{#1}%
}
\ltsAtBeginDocument{%
  \let\LTS@doloaded\LTS@notloadederr
  \LTS@notloaded
  \gletcs\LTS@doloaded\@gobbleone
}
\robust@def*\QuotationMarks#1{%
  \begingroup
  \ifinsetTF,{#1}{%
    \def\LTS@tempa##1,##2\LTS@nil{%
      \ifblankTF{##2}{%
        \LTS@err{Unbalanced quotation marks '#1'}\@ehc
      }{%
        \protected@xdef\LTS@lquote{%
          {\ltsprotectedtokens{\normalcolor\normalfont}##1}}%
        \protected@xdef\LTS@rquote{%
          {\ltsprotectedtokens{\normalcolor\normalfont}##2}}%
      }%
    }%
    \LTS@tempa#1\LTS@nil
  }{%
    \LTS@err{I can't find comma in quotation marks '#1'}\@ehc
  }%
  \endgroup
}
\cptchardef\LTS@quotednr@a\z@pt
\cptchardef\LTS@quotednr@b\z@pt
\QuotationMarks{`,'}
\new@def*\ApplyToQuotes#1{%
  \ifnumcmpTF\LTS@quotednr@b>\z@pt{%
    \LTS@err{You haven't called '\string\ApplyNilToQuotes'\MsgBrk
      since you last called '\string\ApplyToQuotes'}\@ehc
    \@gobbleone
  }{%
    \gdef\LTS@quotefmt{#1}%
  }%
  \let\LTS@quotednr@b\@ne
}
\new@def*\ApplyNilToQuotes{%
  \gletcs\LTS@quotefmt\@firstofone
  \chardef\LTS@quotednr@b\z@pt
}
\ApplyNilToQuotes
\new@def*\LTS@quotewhile{\cpt@choicefdfalse\LTS@quoteloop}
\new@def*\LTS@quoteloop#1{%
  \ifboolTF{cpt@choicefd}{%
    \LTS@quoteend
  }{%
    \ifx#1\LTS@quoterepeat\LTS@quoterepeat\fi
    \ifx#1\LTS@quotenext\cpt@choicefdtrue\fi
  }%
  \LTS@quoteloop
}
\new@def*\LTS@quoterepeat#1\LTS@quoteloop{\fi}
\new@def*\LTS@quoteend#1\LTS@quoterepeat{}
\robust@def*\quoted{%
  \pushnumber\LTS@quotednr@a
  \ifnumcmpTF\LTS@quotednr@a>\tw@{%
    \cpt@toodeep\quoted\tw@
  }{%
    \begingroup
    \@makeother{\#}%
    \LTS@testst\LTS@quoted
  }%
}
\new@def*\LTS@quoted#1{%
  \def\LTS@quotearg{{\LTS@quotefmt{#1}}}%
  \gletcsntocs{ifLTS@st@\romannumeral\LTS@quotednr@a}\ifLTS@st
  \def\LTS@tempa{%
    \ifLTS@st@i
      \protected@edef\lquote{\LTS@lquote}%
      \protected@edef\rquote{\LTS@rquote}%
    \else
      \protected@edef\lquote{\LTS@lquote\LTS@lquote}%
      \protected@edef\rquote{\LTS@rquote\LTS@rquote}%
    \fi
  }%
  \def\LTS@tempb##1##2{%
    \ifnum\LTS@quotednr@a>\@ne
      \LTS@tempa
    \else
      \protected@edef\lquote{##1\LTS@lquote}%
      \protected@edef\rquote{##2\LTS@rquote}%
    \fi
  }%
  \ifLTS@st
    \LTS@tempb\LTS@lquote\LTS@rquote
  \else
    \LTS@tempb{}{}%
  \fi
  \def\popnumber{\noexpand\popnumber\noexpand}%
  \protected@edef\rquote{\rquote\popnumber\LTS@quotednr@a}%
  \futurelet\LTS@quotenext\LTS@qu@ted
}
\new@def*\LTS@qu@ted{%
  \def\LTS@quotefnt{\footnote\footnotetext\footnotemark\mpfootnotemark}%
  \def\LTS@quote@a{%
    \if\LTS@wq
      \expandafter\LTS@quotewhile\LTS@quotefnt\LTS@quoterepeat
      \ifcpt@choicefd
        \protected@xdef\LTS@qu@t@d####1####2{%
          \lquote\expandcsonce\LTS@quotearg\unskip####1{####2}\rquote
        }%
      \else
        \protected@xdef\LTS@qu@t@d####1{%
          \lquote\expandcsonce\LTS@quotearg\unskip####1\rquote}%
      \fi
    \else
      \protected@xdef\LTS@qu@t@d{%
        \lquote\expandcsonce\LTS@quotearg\rquote\unskip}%
    \fi
  }%
  \protected@edef\LTS@tempa{,;:.!?\expandcsonce\LTS@quotefnt}%
  \expandafter\LTS@quotewhile\LTS@tempa\LTS@quoterepeat
  \ifcpt@choicefd
    \expandafter\LTS@quote@a
  \else
    \protected@xdef\LTS@qu@t@d{\lquote\expandcsonce\LTS@quotearg\rquote}%
  \fi
  \expandafter\endgroup\LTS@qu@t@d
}
\robust@def*\MakeQuoteCommand{\LTS@testst\LTS@MakeQuoteCommand}
\robust@def*\LTS@MakeQuoteCommand#1{%
  \begingroup
  \lccode`\~=`#1%
  \lowercase{\endgroup
    \newcsnedef*{\string~@quote}{\the\catcode`~}%
    \ifLTS@st
      \ifdefFT~{}{\letcsntocs{\string~@@quote}~}%
      \let~\quoted
    \else
      \newletcs~\quoted
    \fi
    \catcode`#1=\active
  }%
}
\robust@def*\DeleteQuoteCommand#1{%
  \begingroup
  \lccode`\~=`#1%
  \lowercase{\endgroup
    \ifcsndefTF{\string~@@quote}{%
      \letcstocsn~{\string~@@quote}%
    }{%
      \gletcs~\LTS@undefined
    }%
    \catcode`#1=\usename{\string~@quote}%
  }%
}
\robust@def*\nameabbrev#1#2{%
  \begingroup
  \ltsensurescape{#1}%
  \ltsmakecsn#1\LTS@tempa
  \expandafter\LTS@testopt\expandafter
    {\expandafter\LTS@nameabbrev\expandafter{\LTS@tempa}{#2}}{}%
}
\new@def*\LTS@nameabbrev#1#2[#3]{%
  \ifblankTF{#3}{%
    \LTS@err{Empty abbreviation for name '\noexpandcsn{#1}'}\@ehc
  }{%
    \newcsnpgdef*{#1long}{#2\sspace}%
    \newcsnpgdef*{#1short}{#3\sspace}%
    \newcsnpgdef*{#1first}{#2~(#3)\sspace}%
  }%
  \newcsnpgdef*{#1}{%
    \ifnamedefTF{nameabbrev@#1}{%
      #3\sspace
    }{%
      \csn@gdef{nameabbrev@#1}{}%
      \usename{#1first}\sspace
    }%
  }%
  \endgroup
}
\newletcs\killifdocstarted\@iden
\ltsAfterAfterBeginDocument{%
  \LTS@scantoksa\LTS@sspaceexceptions
  \let\killifdocstarted\@gobble
}
\robust@def*\LTS@sspacewhile{\cpt@choicefdfalse\LTS@sspaceloop}
\robust@def*\LTS@sspaceloop#1{%
  \ifboolTF{cpt@choicefd}{%
    \LTS@sspaceend
  }{%
    \ifx#1\LTS@sspacerepeat\LTS@sspacerepeat\fi
    \ifx#1\LTS@sspacenext\cpt@choicefdtrue\fi
  }%
  \LTS@sspaceloop
}
\robust@def\LTS@sspacerepeat#1\LTS@sspaceloop{\fi}
\robust@def\LTS@sspaceend#1\LTS@sspacerepeat{}
\robust@def*\LTS@sspaceexceptions{%
  \},.'/?;:!~-)\ \/\bgroup\egroup\sspace\nobreak\penalty
  \@sptoken\@space\@xobeysp\footnote\footnotemark
}
\robust@def*\sspace{\begingroup\futurelet\LTS@sspacenext\LTS@sspace}
\robust@def*\LTS@sspace{%
  \killifdocstarted{\LTS@scantoksa\LTS@sspaceexceptions}%
  \expandafter\LTS@sspacewhile\LTS@sspaceexceptions\LTS@sspacerepeat
  \expandafter\endgroup
  \ifcpt@choicefd\else\expandafter\@space\fi
}
% Verbatim \sspace:
\robust@def*\verbsspace{%
  \ifnum\catcode`\ =\active\else\expandafter\sspace\fi
}
\robust@def*\AddSspaceExceptions#1{%
  \ltsfiltermergetsv!\LTS@sspaceexceptions{#1}\nofilter
}
\robust@def*\RemoveSspaceExceptions#1{%
  \ltsfilterdeletetokens!\LTS@sspaceexceptions{#1}\nofilter
}

\robust@def*\ltscountspacesincs{%
  \begingroup
  \catcode\endlinechar=12
  \LTS@countspacesincs
}
\def\LTS@countspacesincs#1{%
  \lccode`\ `\^^S\relax
  \catcode\endlinechar=9
  \scantokens{\LTS@c@untspacesincs{#1}{ignoring}}%
  \catcode\endlinechar=10
  \scantokens{\LTS@c@untspacesincs{#1}{counting}}%
  \endgroup
}
\def\LTS@c@untspacesincs#1#2{%
  \@tempcnta\z@pt
  \toks@{##1}%
  \lowercase{%
    \toks1\expandafter{\detokenize{ }}%
    \expandafter\def\expandafter\LTS@tempa\the
    \expandafter\toks@\the\toks1##2\@nil{%
      \ifblankTF{##2}{}{%
        \advance\@tempcnta\@ne
        \LTS@tempa##2\@nil
      }%
    }%
    \expandafter\LTS@tempa\detokenize{#1 }\@nil
  }%
  \typeout{^^J\unexpanded{#1}}%
  \typeout{Number of spaces,
    #2 end-of-line characters: \the\@tempcnta.}%
}
% Eg,
% \ifboolevalTF{%
%   not ( eval { \ifdefFT\xa } and eval { \ifcsemptyTF\xa } )
%   or ( eval { \ifdefFT\xb } or eval { \ifxTF\xa\xb } )
% }{%
%   \def\x{T}%
% }{%
%   \def\x{F}%
% }
\cptnewcounts{LTS@evalcnt}
\robust@def*\ifboolevalTF#1{%
  \begingroup
  \let\LTS@eval@neg\cptswfalse
  \LTS@evalcnt\z@pt
  \LTS@eval@beg
  \LTS@eval@bgroup#1(\eval@nil
  \LTS@eval@end
  \LTS@eval@@end
}
\robust@def*\LTS@eval@beg{%
  \begingroup
  \let\LTS@eval@neg\cptswfalse
  \LTS@evalcnt\z@pt
}
\robust@def*\LTS@eval@end{%
  \LTS@eval@@end\LTS@eval@true\LTS@eval@false
}
\robust@def*\LTS@eval@@end{%
  \csnendgroup{LTS@\ifnum\LTS@evalcnt<\z@pt2\else1\fi of2}%
}
\robust@def*\LTS@eval@true{%
  \advance\LTS@evalcnt\if\LTS@eval@neg\m@one\else\z@pt\fi
  \let\LTS@eval@neg\cptswfalse
}
\robust@def*\LTS@eval@false{%
  \advance\LTS@evalcnt\if\LTS@eval@neg\z@pt\else\m@one\fi
  \let\LTS@eval@neg\cptswfalse
}
\robust@def\LTS@eval@bgroup#1(#2\eval@nil{%
  \LTS@eval@egroup#1)\eval@nil
  \ifblankTF{#2}{}{%
    \LTS@eval@beg
    \LTS@eval@bgroup#2\eval@nil
  }%
}
\robust@def\LTS@eval@egroup#1)#2\eval@nil{%
  \LTS@eval@and#1and\eval@nil
  \ifblankTF{#2}{}{%
    \LTS@eval@end
    \LTS@eval@egroup#2\eval@nil
  }%
}
\robust@def\LTS@eval@and#1and#2\eval@nil{%
  \LTS@eval@or#1or\eval@nil
  \ifblankTF{#2}{}{%
    \LTS@evalcnt\ifnum\LTS@evalcnt<\z@pt\m@one\else\z@pt\fi
    \LTS@eval@and#2\eval@nil
  }%
}
\robust@def\LTS@eval@or#1or#2\eval@nil{%
  \LTS@eval@not#1not\eval@nil
  \ifblankTF{#2}{}{%
    \LTS@evalcnt\ifnum\LTS@evalcnt<\z@pt\z@pt\else\@ne\fi
    \LTS@eval@or#2\eval@nil
  }%
}
\robust@def\LTS@eval@not#1not#2\eval@nil{%
  \LTS@eval@do#1eval\eval@nil
  \ifblankTF{#2}{}{%
    \let\LTS@eval@neg\cptswtrue
    \LTS@eval@not#2\eval@nil
  }%
}
\robust@def\LTS@eval@do#1eval#2\eval@nil{%
  \ifblankTF{#1}{}{%
    \LTS@err{Invalid 'eval' test expression}
      {The invalid test part is: '\detokenize{#1}'}%
  }%
  \ifblankTF{#2}{}{\LTS@eval@do@a#2\eval@nil}%
}
\robust@def\LTS@eval@do@a#1#2\eval@nil{%
  \ignorespaces#1\LTS@eval@true\LTS@eval@false
  \LTS@eval@do#2\eval@nil
}
% Eg,
% \@tempcnta\z@pt\@tempswatrue
% \ltswhileexpr{\if@tempswa}{%
%   \advance\@tempcnta\@ne
%   \ifnum\@tempcnta>3\relax\@tempswafalse\fi
% }
% or
% \ltswhileexpr{eval{\ifboolTF{@tempswa}}}{%
%   \advance\@tempcnta\@ne
%   \ifnum\@tempcnta>3\relax\@tempswafalse\fi
% }
\robust@def*\ltswhileexpr#1#2{%
  \edef\reserved@a{\cpttrimspaces{#1}}%
  \xifinsetTF{\relax\detokenize{eval}}{\relax\cptoxdetok\reserved@a}{%
    \LTS@whileexpr@a{#1}{#2}%
  }{%
    \LTS@whileexpr@b{#1}{#2}%
  }%
}
\robust@def*\LTS@whileexpr@a#1#2{%
  \ifboolevalTF{#1}{#2\LTS@whileexpr@a{#1}{#2}}{}%
}
\robust@def*\LTS@whileexpr@b#1#2{%
  #1 \expandafter\iofii\else\expandafter\iiofii\fi
  {#2\LTS@whileexpr@b{#1}{#2}}{}%
}
\packagecommands{%
  \packagecommands,\AtEndOfPackage,
  \ltsAtEndPackage,\AtEndOfClass,\ltsAtEndClass,
  \ltsBeforeEndPackage,\ltsBeforeEndClass,\ltsAfterEndPackage,
  \ltsAfterEndClass,\ifclasscurrentTF,\ifclasscurrentFT
}
\preamblecommands{%
  \preamblecommands,\ltsBeforeBeginDocument,\ensurepackageloaded,
  \needpackage
}

\endinput

%%% End of file ltxtools-base.sty %%%
