%% $Id: pst-mirror.tex 894 2014-02-18 09:46:21Z herbert $
%%
%% This is file `pst-mirror.tex',
%%
%% IMPORTANT NOTICE:
%%
%% Package `pst-mirror.tex'
%%
%% Manuel Luque 
%% Herbert Voss 
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory CTAN:/macros/latex/base/lppl.txt.
%%
%% DESCRIPTION:
%%   `pst-mirror' is a PSTricks package to view objects ob a spherical sphere
%%
%%
\csname PSTMirrorLoaded\endcsname
\let\PSTMirrorLoaded\endinput
% Requires PSTricks, pst-xkey and pst-node packages
\ifx\PSTricksLoaded\endinput\else\input pstricks.tex\fi
\ifx\PSTXKeyLoaded\endinput \else\input pst-xkey \fi
\ifx\PSTnodesLoaded\endinput\else\input pst-node \fi
\ifx\MultidoLoaded\endinput \else\input multido.tex \fi
%
%\def\fileversion{1.00} CTAN
\def\fileversion{1.01} 
\def\filedate{2014/02/17}%
\message{`pst-mirror v\fileversion, \filedate\space (ml,hv)}%
%
\edef\PstAtCode{\the\catcode`\@} \catcode`\@=11\relax
\SpecialCoor

\pstheader{pst-mirror.pro}
\pst@addfams{pst-mirror}
%
\definecolor{Beige} {rgb}{0.96,0.96,0.86}
\definecolor{GrisClair} {rgb}{0.8,0.8,0.8}
\definecolor{GrisTresClair} {rgb}{0.9,0.9,0.9}
\definecolor{OrangeTresPale}{cmyk}{0,0.1,0.3,0}
\definecolor{OrangePale}{cmyk}{0,0.2,0.4,0}
\definecolor{BleuClair}{cmyk}{0.2,0,0,0}
\definecolor{LightBlue}{rgb}{.68,.85,.9}
\definecolor{DarkGreen}{rgb}{0,.85,0}
\definecolor{Copper}{cmyk}{0,0.9,0.9,0.2}
%%%%
\SpecialCoor
\define@boolkey[psset]{pst-mirror}[Pst@]{visibility}[true]{}
\define@boolkey[psset]{pst-mirror}[Pst@]{isolatin}[false]{}
\define@boolkey[psset]{pst-mirror}[Pst@Mirror]{Sphere}[true]{}
\psset[pst-mirror]{Sphere,visibility,isolatin=true}

\define@key[psset]{pst-mirror}{Xmax}[50]{\def\psk@Sphere@Xmax{#1}} % en cm
\define@key[psset]{pst-mirror}{Xmin}[-50]{\def\psk@Sphere@Xmin{#1}} % en cm
\define@key[psset]{pst-mirror}{Ymax}[50]{\def\psk@Sphere@Ymax{#1}} % en cm
\define@key[psset]{pst-mirror}{Ymin}[-50]{\def\psk@Sphere@Ymin{#1}} % en cm
\define@key[psset]{pst-mirror}{pas}[1]{\def\psk@Sphere@pas{#1}} % en cm résolution du tracé
\define@key[psset]{pst-mirror}{scale}[1]{\def\psk@Sphere@scale{#1}} % echelle
\define@key[psset]{pst-mirror}{distance}[30]{\def\psk@Sphere@Distance{#1}} % Distance du quadrillage à la Sphere en cm
\define@key[psset]{pst-mirror}{Rayon}[10]{\def\psk@Sphere@Rayon{#1}} % rayon de la Sphere en cm
\define@key[psset]{pst-mirror}{grille}[10]{\def\psk@Sphere@grille{#1}} % Pas de la grille en cm
\define@key[psset]{pst-mirror}{normale}[0 0]{\def\psk@Sphere@normale{#1}}
\psset[pst-mirror]{normale=0 0}
\define@key[psset]{pst-mirror}{Xorigine}[\psk@Sphere@Distance]{\def\psk@Sphere@Xorigine{#1}} % coordonnées de la nouvelle origine
\define@key[psset]{pst-mirror}{Yorigine}[0]{\def\psk@Sphere@Yorigine{#1}} % coordonnées de la nouvelle origine
\define@key[psset]{pst-mirror}{Zorigine}[0]{\def\psk@Sphere@Zorigine{#1}} % coordonnées de la nouvelle origine
\define@key[psset]{pst-mirror}{RotX}[0]{\def\psk@Sphere@RotX{#1}} % rotation autour de Ox en degrés
\define@key[psset]{pst-mirror}{RotY}[0]{\def\psk@Sphere@RotY{#1}} % rotation autour de Oy en degrés
\define@key[psset]{pst-mirror}{RotZ}[0]{\def\psk@Sphere@RotZ{#1}} % rotation autour de OZ en degrés
\define@key[psset]{pst-mirror}{A}[10]{\def\psk@Sphere@A{#1}} % double  d'une arête du parallèlépipède
\define@key[psset]{pst-mirror}{B}[10]{\def\psk@Sphere@B{#1}} % double  d'une arête du parallèlépipède
\define@key[psset]{pst-mirror}{C}[10]{\def\psk@Sphere@C{#1}} % double  de l'arête du parallèlépipède
\define@key[psset]{pst-mirror}{CX}[0]{\def\psk@Sphere@Xc{#1}} % abscisse du centre du paarallèlépipède
\define@key[psset]{pst-mirror}{CY}[0]{\def\psk@Sphere@Yc{#1}} % ordonnée centre du cube
\define@key[psset]{pst-mirror}{CZ}[0]{\def\psk@Sphere@Zc{#1}} % cote centre du cube
\define@key[psset]{pst-mirror}{Rtetraedre}[5]{\def\psk@Sphere@Rtetraedre{#1}} % Rayon du cercle tétraèdre
\define@key[psset]{pst-mirror}{ColorFaceA}[magenta]{\def\psk@Sphere@TetraedreColorFaceA{#1}} % couleur de la face A du tétraèdre
\define@key[psset]{pst-mirror}{ColorFaceB}[red]{\def\psk@Sphere@TetraedreColorFaceB{#1}} % couleur de la face B du tétraèdre
\define@key[psset]{pst-mirror}{ColorFaceC}[blue]{\def\psk@Sphere@TetraedreColorFaceC{#1}} % couleur de la face C du tétraèdre
\define@key[psset]{pst-mirror}{ColorFaceD}[cyan]{\def\psk@Sphere@TetraedreColorFaceD{#1}} % couleur de la face D du tétraèdre
\define@key[psset]{pst-mirror}{ColorFaceE}[yellow]{\def\psk@Sphere@TetraedreColorFaceE{#1}} % couleur de la face D du tétraèdre
\define@key[psset]{pst-mirror}{fracHcone}[1]{\def\psk@Sphere@fracHcone{#1}} % fraction de la hauteur du cone
\define@key[psset]{pst-mirror}{Hpyramide}[5]{\def\psk@Sphere@Hpyramide{#1}} % hauteur pyramide

% choix de la police et de la taille des caractères en cm !!
\define@key[psset]{pst-mirror}{PSfont}[Times-Roman]{\def\psk@PSfont{/#1 }}
\define@key[psset]{pst-mirror}{fontscale}[1]{\def\psk@fontscale{#1 }}
\define@key[psset]{pst-mirror}{xlabelsep}[-0.5]{\def\psk@xlabelsep{#1 }}
\define@key[psset]{pst-mirror}{ylabelsep}[-0.5]{\def\psk@ylabelsep{#1 }}
\define@key[psset]{pst-mirror}{xO}[0]{\def\pst@SphereMirror@xO{#1 }} % origine du texte
\define@key[psset]{pst-mirror}{yO}[0]{\def\pst@SphereMirror@yO{#1 }}
\define@key[psset]{pst-mirror}{translation}[0 0 0]{\def\psk@SphereMirror@translation{#1}} % vecteur translation
\psset[pst-mirror]{PSfont=Times-Roman,fontscale=1,xlabelsep=-0.5,ylabelsep=-0.5,xO=0,yO=0,translation=0 0 0}
%
\psset{Xmax=50,Ymax=50,Xmin=-50,Ymin=-50,pas=1,grille=10,distance=30,Rayon=10,scale=1,
    Xorigine=\psk@Sphere@Distance,Yorigine=0,Zorigine=0,RotX=0,RotY=0,RotZ=0,
    A=10,B=10,C=10,CX=0,CY=0,CZ=0,Rtetraedre=5,
    ColorFaceD=cyan,ColorFaceA=magenta,ColorFaceB=red,ColorFaceC=blue,ColorFaceE=yellow,
    fracHcone=1,Hpyramide=5}
%
\def\variables@Sphere{
  0 0 translate
  /cm   { \pst@number\psunit mul } def
  /cm_1 { \pst@number\psunit div } def
  /unit_image {\pst@number\psunit div 10 mul} bind def
 %% Caracteres accentues
  /ReEncode { exch findfont
    dup length dict begin { 1 index /FID eq {pop pop} {def} ifelse
      }forall 
    /Encoding ISOLatin1Encoding def currentdict end definefont
    pop 
  } bind def
  \ifPst@isolatin
    /Font \psk@PSfont\space /ISOfont ReEncode /ISOfont def
  \else
    /Font \psk@PSfont\space  def
  \fi
  /SizeFont { \psk@fontscale\space cm } bind def
  Font findfont SizeFont scalefont setfont
  /x0 \pst@SphereMirror@xO def % pour positionner le texte
  /y0 \pst@SphereMirror@yO def %
  /Xmax \psk@Sphere@Xmax\space def
  /Ymax \psk@Sphere@Ymax\space def
  /Xmin \psk@Sphere@Xmin\space def
  /Ymin \psk@Sphere@Ymin\space def
  /pas \psk@Sphere@pas\space def
  /Xabscisse \psk@Sphere@Distance\space def
  /Rayon \psk@Sphere@Rayon\space def
  /grille \psk@Sphere@grille\space def
  /reduction \psk@Sphere@scale\space def
  \psk@Sphere@normale\space /K_phi exch def /K_theta exch def
  /S1 K_theta sin def
  /C1 K_theta cos def
  /S2 K_phi sin def
  /C2 K_phi cos def
  /RotX \psk@Sphere@RotX\space def
  /RotY \psk@Sphere@RotY\space def
  /RotZ \psk@Sphere@RotZ\space def
%    /translation {\psk@SphereMirror@translation} def
%    translation /vz 0 def /vy 0 def /vx 0 def
  /CX \psk@Sphere@Xc\space def
  /CY \psk@Sphere@Yc\space def
  /CZ \psk@Sphere@Zc\space def
  /A \psk@Sphere@A\space def
  /B \psk@Sphere@B\space def
  /C \psk@Sphere@C\space def
  /RayonBaseTetraedre \psk@Sphere@Rtetraedre\space def
  /Hpyramide \psk@Sphere@Hpyramide\space def
  /Rpoint A 4 div def
  /M11 RotZ cos RotY cos mul def
  /M12 RotZ cos RotY sin mul RotX sin mul RotZ sin RotX cos mul sub def
  /M13 RotZ cos RotY sin mul RotX cos mul RotZ sin RotX sin mul add def
  /M21 RotZ sin RotY cos mul def
  /M22 RotZ sin RotY sin RotX sin mul mul RotZ cos RotX cos mul add def
  /M23 RotZ sin RotY sin mul RotX cos mul RotZ cos RotX sin mul sub def
  /M31 RotY sin neg def
  /M32 RotX sin RotY cos mul def
  /M33 RotX cos RotY cos mul def
  /CalculsPointsApresTransformations { 1 dict begin
    M11 Xpoint mul M12 Ypoint mul add M13 Zpoint mul add CX add
    M21 Xpoint mul M22 Ypoint mul add M23 Zpoint mul add CY add
    M31 Xpoint mul M32 Ypoint mul add M33 Zpoint mul add CZ add
  end
  } def
  /3dto2d {8 dict begin
    /Zcote exch def
    /Yordonnee exch def
    /Xabscisse exch def
    /RHO Zcote dup mul Yordonnee dup mul add sqrt def
    /incidence RHO Xabscisse Atan 2 div def
    /RHO' incidence sin Rayon mul def
    RHO 0 eq {/Xi 0 def /Yi 0 def}{/Yi RHO' RHO div Zcote mul def
      /Xi RHO' RHO div Yordonnee mul neg def } ifelse
    Xi cm %% c'est Xi cm
    Yi cm %% c'est Yi cm
  end } def
}%

\def\pstSphereText{\pst@object{pstSphereText}}
\def\pstSphereText@i{\@ifnextchar({\pstSphereText@ii}{\pstSphereText@ii(0,0,0)}}
\def\pstSphereText@ii(#1,#2,#3)#4{%
  \begin@ClosedObj
  \addto@pscode{%
    \variables@Sphere
    tx@Sphere3DDict begin
    \ifPst@visibility /Condition { gt } def \else /Condition { le } def \fi
    /warptxt (#4) def 
    /warpwidth { warptxt stringwidth pop } bind def  %% largeur horizontale du texte
    /warpheigth { SizeFont 2 div } bind def 	     %% hauteur verticale du texte
    /warpxhalf warpwidth 2 div def                   %% demi-largeur horizontale
    /warpyhalf warpheigth 2 div def                  %% demi-hauteur
    /x0 x0 warpxhalf neg  cm_1 add def 		     % centre le texte
    /y0 y0 warpyhalf neg  cm_1 add def
    /warp {
      5 dict begin
      /Ypoint exch cm_1 y0 add def
      /Xpoint exch cm_1 x0 add def
      %% coordonnees dans le repare absolu
      2dto3d
      /Zpoint exch def
      /Ypoint exch def
      /Xpoint exch def
      CalculsPointsApresTransformations
      3dto2d
      end
    } bind def
    #1 #2 #3 \tx@TransformPlan
    \tx@WARP
    0 0 moveto
    warptxt true charpath 
    10 currentpathsegmenteline
  % rotation possible ici
  % alpha 2 div rotate
    warpit
    end
  }%
  \end@ClosedObj\ignorespaces}
%
\def\pstSphereCube{\pst@object{pstSphereCube}}
\def\pstSphereCube@i{%
  \pst@killglue
  \begin@ClosedObj
  \addto@pscode{%
    \variables@Sphere
    tx@Sphere3DDict begin Cube end
  }% fin du code ps
  \end@ClosedObj\ignorespaces}
%
\def\pstSphereDie{\pst@object{pstSphereDie}}
\def\pstSphereDie@i{%
  \pst@killglue
  \begingroup%
  \use@par
  \pstSphereCube
  \begin@SpecialObj
  \addto@pscode{%
    \variables@Sphere
    tx@Sphere3DDict begin Cube PointsDie end
  }% fin du code ps
  \end@SpecialObj%
  \endgroup\ignorespaces%
}
%
\def\pstSphereTetraedre{\pst@object{pstSphereTetraedre}}
\def\pstSphereTetraedre@i{%
  \pst@killglue
  \begin@ClosedObj
  \addto@pscode{%
    \variables@Sphere tx@Sphere3DDict begin Tetraedre end
  }% fin du code ps
  \end@ClosedObj\ignorespaces}
%
% transformation d'un point
\def\pstSpherePoint{\pst@object{pstSpherePoint}}
\def\pstSpherePoint@i(#1,#2,#3)#4{%
  %(#2,#3,#4) coordonnées
  % #5 nom attribué au point
  \pst@killglue
  \begin@SpecialObj
  \pnode(!
    \variables@Sphere
    /Zcote #3 def /Xabscisse #1 def /Yordonnee #2 def
    tx@Sphere3DDict begin
     FormulesSphere
    Xi reduction mul Yi reduction mul
    end){#4}
  \end@SpecialObj\ignorespaces}
%
\def\CartesianIIID@coor#1,#2,#3,#4\@nil{\edef\pst@coor{#1 #2 #3 }}
\def\NormalIIIDCoor{%
  \def\pst@@getcoor##1{\pst@expandafter\CartesianIIID@coor{##1}, ,\@nil}%
  \def\psput@##1{\pst@@getcoor{##1}\leavevmode\psput@cartesian}%
}%
\def\pstSphereLine{\NormalIIIDCoor\pst@object{pstSphereLine}}
\def\pstSphereLine@i{%
  \pst@killglue%
  \pst@getarrows{%
    \begin@OpenObj%
      \pst@getcoors[\pstSphereLine@ii%
  }%
}
\def\pstSphereLine@ii{%
  \addto@pscode{%
   ] 
   /LesPoints exch def 
   \variables@Sphere
   tx@Sphere3DDict begin
   /n1 LesPoints length 3 div cvi def % nbre de points
   /i 0 def
   /TableauPoints [
     n1 {
       [ LesPoints i get LesPoints i 1 add get LesPoints i 2 add get ]
       /i i 3 add def
     } repeat
   ] def
% Tableau general des points
  /TAB [
    0 1 n1 2 sub {/i ED
      TableauPoints i get aload pop
      /Z1 ED /Y1 ED /X1 ED
      TableauPoints i 1 add get aload pop
      /Z2 ED /Y2 ED /X2 ED
      0 0.01 1.0 { % k
        /K exch def
        [
        /Zcote K Z2 mul 1 K sub Z1 mul add def
        /Xabscisse K X2 mul 1 K sub X1 mul add def
        /Yordonnee K Y2 mul 1 K sub Y1 mul add def
        CalcCoordinates
        ]
      } for
    } for
  ] def
  /n2 TAB length def
  TAB 0 get aload pop moveto
  0 1 n2 1 sub {
    /compteur exch def
    TAB compteur get aload pop
    lineto } for
% fin du tracé de la ligne
  end }%
  \end@OpenObj%
  \ignorespaces%
  \SpecialCoor%
}
%
\def\pstSpherePolygon{\NormalIIIDCoor\pst@object{pstSpherePolygon}}
\def\pstSpherePolygon@i{%
  \pst@killglue%
  \pst@getarrows{%
    \begin@ClosedObj%
      \pst@getcoors[\pstSpherePolygon@ii%
  }%
}
\def\pstSpherePolygon@ii{%
  \addto@pscode{%
    ] /LesPoints exch def
    \variables@Sphere
    /n1 LesPoints length 3 div cvi def % nbre de points
    /i 0 def
    /TableauPoints [
    n1 { [ LesPoints i get LesPoints i 1 add get LesPoints i 2 add get ]
      /i i 3 add def
    } repeat
    ] def
    % Tableau general des points
    /TAB [
    0 1 n1 2 sub {/i ED
      TableauPoints i get aload pop
      /Z1 ED /Y1 ED /X1 ED
      TableauPoints i 1 add get aload pop
      /Z2 ED /Y2 ED /X2 ED
      0 0.01 1.0 { % k
	/K exch def
	[ /Zcote K Z2 mul 1 K sub Z1 mul add def
	  /Xabscisse K X2 mul 1 K sub X1 mul add def
	  /Yordonnee K Y2 mul 1 K sub Y1 mul add def
          tx@Sphere3DDict begin CalcCoordinates end ]
      } for
    } for
    ] def
    /n2 TAB length def
    newpath
    TAB 0 get aload pop moveto
    0 1 n2 1 sub {
      /compteur exch def
      TAB compteur get aload pop
      lineto 
    } for
    closepath
  }%
  \end@ClosedObj%
  \ignorespaces%
  \SpecialCoor%
}
%
\def\pstSphereCircle{\pst@object{pstSphereCircle}}
\def\pstSphereCircle@i#1{% #1 rayon du cercle
  \pst@killglue
  \begin@ClosedObj
  \addto@pscode{%
    /Rcercle #1 def
    \variables@Sphere
    /XO' \psk@Sphere@Xorigine\space def
    /YO' \psk@Sphere@Yorigine\space def
    /ZO' \psk@Sphere@Zorigine\space def
    tx@Sphere3DDict begin
    reduction reduction scale
    /TableauxPoints [
      0 1 359 {% on décrit le cercle
	/Angle exch def [
	/Xcercle Rcercle Angle cos mul def
	/Ycercle Rcercle Angle sin mul def
	/Xabscisse Xcercle S1 mul Ycercle S2 C1 mul mul add XO' add def
	/Yordonnee Xcercle C1 mul neg Ycercle S2 S1 mul mul add YO' add def
	/Zcote Ycercle C2 mul neg ZO' add def
	CalcCoordinates ]
      } for
    ] def
    TableauxPoints 0 get aload pop moveto
    0 1 359 {
      /compteur exch def
      TableauxPoints compteur get aload pop
      lineto 
    } for
    end
  }% fin du code ps
  \showpointsfalse
  \end@ClosedObj\ignorespaces}
%
\def\pstSphereArc{\pst@object{pstSphereArc}}
\def\pstSphereArc@i#1#2#3{% #2 rayon du cercle #3 angle de depart #4 angle d'arrivee
  \pst@killglue
  \begin@OpenObj
  \addto@pscode{%
    /Rcercle #1 def
    /AngleStart #2 def
    /AngleStop #3 def
    \variables@Sphere
    /XO' \psk@Sphere@Xorigine\space def
    /YO' \psk@Sphere@Yorigine\space def
    /ZO' \psk@Sphere@Zorigine\space def
    tx@Sphere3DDict begin
    reduction reduction scale
    /TableauxPoints [
      AngleStart 1 AngleStop {% on decrit le cercle
        /Angle exch def [
          /Xcercle Rcercle Angle cos mul def
          /Ycercle Rcercle Angle sin mul def
	  /Xabscisse Xcercle S1 mul Ycercle S2 C1 mul mul add XO' add def
          /Yordonnee Xcercle C1 mul neg Ycercle S2 S1 mul mul add YO' add def
          /Zcote Ycercle C2 mul neg ZO' add def
          CalcCoordinates ] } for ] def
    TableauxPoints 0 get aload pop moveto
    0 1 AngleStop AngleStart sub abs {
      /compteur exch def
      TableauxPoints compteur get aload pop
      lineto 
    } for
    end
  }% fin du code ps
  \showpointsfalse
  \end@OpenObj\ignorespaces}
%
\def\pstSphereFrame{\pst@object{pstSphereFrame}}
\def\pstSphereFrame@i(#1,#2)(#3,#4){% (#1,#2) d'un sommet (#3,#4) du sommet oppose
  \pst@killglue
  \begin@ClosedObj
  \addto@pscode{%
    /XA #1 def /YA #2 def /XC #3 def /YC #4 def
    % on en deduit les autres sommets
    /XB XC def /YB YA def /XD XA def /YD YC def
    \variables@Sphere
    /XO' \psk@Sphere@Xorigine\space def
    /YO' \psk@Sphere@Yorigine\space def
    /ZO' \psk@Sphere@Zorigine\space def
    tx@Sphere3DDict begin
    reduction reduction scale
    /Xframe XA def
    /Yframe YA def
    /Xabscisse Xframe S1 mul Yframe S2 C1 mul mul add XO' add def
    /Yordonnee Xframe C1 mul neg Yframe S2 S1 mul mul add YO' add def
    /Zcote Yframe C2 mul neg ZO' add def
    CalcCoordinates
     moveto
    0 0.01 1 { % k
      /K exch def
      /Xframe K XB mul 1 K sub XA mul add def
      /Yframe K YB mul 1 K sub YA mul add def
      /Xabscisse Xframe S1 mul Yframe S2 C1 mul mul add XO' add def
      /Yordonnee Xframe C1 mul neg Yframe S2 S1 mul mul add YO' add def
      /Zcote Yframe C2 mul neg ZO' add def
      CalcCoordinates
      lineto
    } for
    0 0.01 1 { % k
      /K exch def
      /Xframe K XC mul 1 K sub XB mul add def
      /Yframe K YC mul 1 K sub YB mul add def
      /Xabscisse Xframe S1 mul Yframe S2 C1 mul mul add XO' add def
      /Yordonnee Xframe C1 mul neg Yframe S2 S1 mul mul add YO' add def
      /Zcote Yframe C2 mul neg ZO' add def
      CalcCoordinates
      lineto
    } for
    0 0.01 1 { % k
      /K exch def
      /Xframe K XD mul 1 K sub XC mul add def
      /Yframe K YD mul 1 K sub YC mul add def
      /Xabscisse Xframe S1 mul Yframe S2 C1 mul mul add XO' add def
      /Yordonnee Xframe C1 mul neg Yframe S2 S1 mul mul add YO' add def
      /Zcote Yframe C2 mul neg ZO' add def
      CalcCoordinates
      lineto
    } for
    0 0.01 1 { % k
      /K exch def
      /Xframe K XA mul 1 K sub XD mul add def
      /Yframe K YA mul 1 K sub YD mul add def
      /Xabscisse Xframe S1 mul Yframe S2 C1 mul mul add XO' add def
      /Yordonnee Xframe C1 mul neg Yframe S2 S1 mul mul add YO' add def
      /Zcote Yframe C2 mul neg ZO' add def
      CalcCoordinates
      lineto
    } for
    end
  }% fin du code ps
  \showpointsfalse
  \end@ClosedObj\ignorespaces}
%
\def\pstSphereGrid{\pst@object{pstSphereGrid}}
\def\pstSphereGrid@i(#1,#2,#3){%
  \pst@killglue
  \begin@OpenObj
  \addto@pscode{%
    \variables@Sphere
    /XO' #1 def %\psk@Sphere@Xorigine\space def
    /YO' #2 def %\psk@Sphere@Yorigine\space def
    /ZO' #3 def %\psk@Sphere@Zorigine\space def
    tx@Sphere3DDict begin
    reduction reduction scale
    Ymin grille Ymax {% balayage suivant Oy
      /Ygrille exch def
      /TableauxPoints [
        Xmin pas Xmax { % balayage suivant Ox
          /Xgrille exch def
          /Xabscisse Xgrille S1 mul Ygrille S2 C1 mul mul add XO' add def
          /Yordonnee Xgrille C1 mul neg Ygrille S2 S1 mul mul add YO' add def
          /Zcote Ygrille C2 mul neg ZO' add def
          FormulesSphere [ Xi 28.45 mul Yi 28.45 mul ]
        } for
      ] def
      TableauxPoints 0 get aload pop moveto
      0 1 Xmax Xmin sub pas div {
        /compteur exch def
        TableauxPoints compteur get aload pop
        lineto 
      } for
      % stroke
    } for
%
  Xmin grille Xmax {% balayage suivant Ox
    /Xgrille exch def
    /TableauxPoints [
      Ymin pas Ymax { % balayage suivant Ox
	/Ygrille exch def
	/Xabscisse Xgrille S1 mul Ygrille S2 C1 mul mul add XO' add def
	/Yordonnee Xgrille C1 mul neg Ygrille S2 S1 mul mul add YO' add def
	/Zcote Ygrille C2 mul neg ZO' add def
	FormulesSphere [ Xi 28.45 mul Yi 28.45 mul ]
      } for
    ] def
    TableauxPoints 0 get aload pop moveto
    0 1 Ymax Ymin sub pas div {
      /compteur exch def
      TableauxPoints compteur get aload pop
      lineto 
    } for
    \pst@number\pslinewidth SLW
    \pst@usecolor\pslinecolor
    \@nameuse{psls@\pslinestyle}
    % stroke
  } for
  \ifPst@MirrorSphere
  newpath
  0 0 Rayon 0.707 mul 28.45 mul 0 360 arc
  [3] 0 setdash
  stroke
  \fi
% fin du tracé
  end
  }% fin du code ps
  \end@OpenObj\ignorespaces}%
%
\def\pstMirrorSphere{\pst@object{pstMirrorSphere}}
\def\pstMirrorSphere@i#1{%
% (#2,#3,#4) coordonnées du centre
% #5 rayon
  \pst@killglue
  \begin@ClosedObj
  \addto@pscode{%
    \variables@Sphere
    reduction reduction scale
    /Rsphere #1 def
    /increment 10 def
    tx@Sphere3DDict begin
    0 increment 360 increment sub {%
    /theta exch def
    -90 increment 90 increment sub {%
      /phi exch def
      % newpath
      /Xpoint Rsphere theta cos mul phi cos mul def
      /Ypoint Rsphere theta sin mul phi cos mul def
      /Zpoint Rsphere phi sin mul def
      CalculsPointsAfterTransformations
      CalcCoordinates
      moveto
% Centre de la facette
      /Xpoint Rsphere theta increment 2 div add cos mul phi increment 2 div add cos mul def
      /Ypoint Rsphere theta increment 2 div add sin mul phi increment 2 div add cos mul def
      /Zpoint Rsphere phi increment 2 div add sin mul def
      CalculsPointsAfterTransformations
      /xCentreFacette Xabscisse def
      /yCentreFacette Yordonnee def
      /zCentreFacette Zcote def
      /xCentreFacette Xabscisse def
      /yCentreFacette Yordonnee def
      /zCentreFacette Zcote def
% normale `a la facette
      /nXfacette xCentreFacette CX sub def
      /nYfacette yCentreFacette CY sub def
      /nZfacette zCentreFacette CZ sub def
% test de visibilité
      /PSfacette xCentreFacette nXfacette mul
        yCentreFacette nYfacette mul add
        zCentreFacette nZfacette mul add def
      PSfacette 0 le {
        theta 1 theta increment add {%
	  /theta1 exch def
	  /Xpoint Rsphere theta1 cos mul phi cos mul def
	  /Ypoint Rsphere theta1 sin mul phi cos mul def
	  /Zpoint Rsphere phi sin mul def
	  CalculsPointsAfterTransformations
	  CalcCoordinates
	  lineto
	} for
	phi 1 phi increment add {
	  /phi1 exch def
	  /Xpoint Rsphere theta increment add cos mul phi1 cos mul def
    /Ypoint Rsphere theta increment add sin mul phi1 cos mul def
    /Zpoint Rsphere phi1 sin mul def
CalculsPointsAfterTransformations
    CalcCoordinates
    lineto
    } for
theta increment add -1 theta {%
    /theta1 exch def
    /Xpoint Rsphere theta1 cos mul phi increment add cos mul def
    /Ypoint Rsphere theta1 sin mul phi increment add cos mul def
    /Zpoint Rsphere phi increment add sin mul def
CalculsPointsAfterTransformations
    CalcCoordinates
    lineto
    } for
phi increment add -1 phi {
    /phi1 exch def
    /Xpoint Rsphere theta cos mul phi1 cos mul def
    /Ypoint Rsphere theta sin mul phi1 cos mul def
    /Zpoint Rsphere phi1 sin mul def
CalculsPointsAfterTransformations
    CalcCoordinates
    lineto
        } for
} if
%closepath
%fill
} for
} for
end
   }% fin du code ps
  \showpointsfalse
  \end@ClosedObj\ignorespaces}
%
%
\def\pstSphereCylinder{\pst@object{pstSphereCylinder}}
\def\pstSphereCylinder@i#1#2{{%
% Le centre de la base sera placé avec
% les paramètres CX,CY et CZ
% #2 rayon
% #3 hauteur
% on peut ensuite faire tourner le cylindre
% avec RotX, RotY et RotZ
\pst@killglue
\begin@ClosedObj
\addto@pscode{%
\variables@Sphere
reduction reduction scale
    /Rcylindre #1 def
    /Hcylindre #2 def
    /incrementANGLE 10 def
    /incrementHAUTEUR Hcylindre 5 div def
tx@Sphere3DDict begin
0 incrementANGLE 360 {%
    /theta exch def
 0 incrementHAUTEUR Hcylindre incrementHAUTEUR sub {%
    /H exch def
% newpath
    /X1 Rcylindre theta cos mul def
    /Y1 Rcylindre theta sin mul def
    /Z1 H def
    /Xpoint X1 def
    /Ypoint Y1 def
    /Zpoint Z1 def
CalculsPointsAfterTransformations
    /Xfacette Xabscisse  def
    /Yfacette Yordonnee  def
    /Zfacette Zcote def
    CalcCoordinates
     moveto
% coordonnées du centre de la facette
    /Xpoint Rcylindre theta incrementANGLE 2 div add cos mul def
    /Ypoint Rcylindre theta incrementANGLE 2 div add sin mul def
    /Zpoint H incrementHAUTEUR 2 div add def
CalculsPointsAfterTransformations
% Point sur l'axe du cylindre
% à la même hauteur que M1
    /Zpoint Z1 def
    /Xpoint 0 def
    /Ypoint 0 def
CalculsPointsAfterTransformations
% normale à la facette
    /nXfacette Xfacette Xabscisse sub def
    /nYfacette Yfacette Yordonnee sub def
    /nZfacette Zfacette Zcote sub def
% test de visibilité
    /PSfacette nXfacette Xfacette mul
    nYfacette Yfacette mul add
    nZfacette Zfacette mul add
    def
PSfacette 0 le {
theta 1 theta incrementANGLE add {%
    /theta1 exch def
    /Xpoint Rcylindre theta1 cos mul def
    /Ypoint Rcylindre theta1 sin mul def
    /Zpoint H def
CalculsPointsAfterTransformations
    CalcCoordinates
    lineto
    } for
H 1 H incrementHAUTEUR add {
    /H1 exch def
    /Xpoint Rcylindre  theta incrementANGLE add cos mul def
    /Ypoint Rcylindre theta incrementANGLE add sin mul def
    /Zpoint H1 def
CalculsPointsAfterTransformations
    CalcCoordinates
    lineto
    } for
theta incrementANGLE add -1 theta {%
    /theta1 exch def
    /Xpoint Rcylindre theta1 cos mul def
    /Ypoint Rcylindre theta1 sin mul def
    /Zpoint H incrementHAUTEUR add def
CalculsPointsAfterTransformations
    CalcCoordinates
    lineto
    } for
H incrementHAUTEUR add -1 H {
    /H1 exch def
    /Xpoint Rcylindre theta cos mul def
    /Ypoint Rcylindre theta sin mul def
    /Zpoint H1 def
CalculsPointsAfterTransformations
    CalcCoordinates
    lineto
    } for
} if
} for
} for
% Face supérieure
% centre de la face supérieure
    /Xpoint 0 def
    /Zpoint Hcylindre def
    /Ypoint 0 def
CalculsPointsAfterTransformations
    /CxFaceSup Xabscisse def
    /CyFaceSup Yordonnee def
    /CzFaceSup Zcote def
% centre de la face inférieure
    /CxFaceInf CX def
    /CyFaceInf CY def
    /CzFaceInf CZ def
% Normale à la face supérieure
    /nXFaceSup CxFaceSup CxFaceInf sub def
    /nYFaceSup CyFaceSup CyFaceInf sub def
    /nZFaceSup CzFaceSup CzFaceInf sub def
% Visibilité face supérieure
    /PSfaceSup nXFaceSup CxFaceSup mul
               nYFaceSup CyFaceSup mul add
               nZFaceSup CzFaceSup mul add def
% Visibilité face inférieure
    /PSfaceInf CX nXFaceSup mul neg
               CY nYFaceSup mul sub
               CZ nZFaceSup mul sub def
PSfaceSup 0 le {
/TableauxPoints [
0 1 359 {% on décrit le cercle
    /theta exch def [
    /Xpoint Rcylindre theta cos mul def
    /Ypoint Rcylindre theta sin mul def
    /Zpoint Hcylindre def
CalculsPointsAfterTransformations
    CalcCoordinates ]
    } for
    ] def
gsave
newpath
 TableauxPoints 0 get aload pop moveto
0 1 359 {
    /compteur exch def
    TableauxPoints compteur get aload pop
    lineto } for
0.7 setgray
closepath
fill
grestore
 } if
% face inférieure
PSfaceInf 0 le {
/TableauxPoints [
0 1 359 {% on décrit le cercle
    /theta exch def [
    /Xpoint Rcylindre theta cos mul def
    /Ypoint Rcylindre theta sin mul def
    /Zpoint 0 def
CalculsPointsAfterTransformations
    CalcCoordinates ]
    } for
    ] def
gsave
newpath
 TableauxPoints 0 get aload pop moveto
 0 1 359 {
    /compteur exch def
    TableauxPoints compteur get aload pop
    lineto } for
0.7 setgray
closepath
fill
grestore
 } if
end
 }% fin du code ps
  \showpointsfalse
  \end@ClosedObj}\ignorespaces}% % fin de la commande PSTricks
%
%
\def\pstSphereCone{\pst@object{pstSphereCone}}
\def\pstSphereCone@i#1#2{{%
% Le centre de la base sera placé avec
% les paramètres CX,CY et CZ
% #2 rayon
% #3 hauteur
% on peut ensuite faire tourner le cylindre
% avec RotX, RotY et RotZ
  \pst@killglue
  \begin@ClosedObj
  \addto@pscode{%
    \variables@Sphere
    /fracHcone \psk@Sphere@fracHcone\space def
% fraction de la hauteur du cone 0<fracHcone<1
    reduction reduction scale
    /Rcone #1 def
    /Hcone #2 def
    /AngleCone Rcone Hcone atan def
    /TanAngleCone AngleCone dup sin exch cos div def
    /incrementANGLE 10 def
    /incrementHAUTEUR Hcone fracHcone mul  5 div def
    tx@Sphere3DDict begin
    newpath
    0 incrementANGLE 360 {%
      /theta exch def
      0 incrementHAUTEUR Hcone fracHcone mul incrementHAUTEUR sub {%
      /H exch def
      % normale à la facette
      /nXfacette Hcone AngleCone dup sin exch cos mul theta incrementANGLE 2 div add cos mul mul def
      /nYfacette Hcone AngleCone dup sin exch cos mul theta incrementANGLE 2 div add sin mul mul def
      /nZfacette Hcone AngleCone sin dup mul mul def
      /Xpoint nXfacette def
      /Ypoint nYfacette def
      /Zpoint nZfacette def
      CalculsPointsAfterTransformations
      /nXfacette Xabscisse CX sub def
      /nYfacette Yordonnee CY sub def
      /nZfacette Zcote CZ sub def
%
      /OK Hcone H sub TanAngleCone mul def
      /Xpoint OK theta cos mul def
      /Ypoint OK theta sin mul def
      /Zpoint H def
      CalculsPointsAfterTransformations
      /Xfacette Xabscisse  def
    /Yfacette Yordonnee  def
    /Zfacette Zcote def
    CalcCoordinates
     moveto
% coordonnées du centre de la facette
    /OK Hcone H incrementHAUTEUR 2 div add sub TanAngleCone mul def
    /Xpoint OK theta incrementANGLE 2 div add cos mul def
    /Ypoint OK theta incrementANGLE 2 div add sin mul def
    /Zpoint H incrementHAUTEUR 2 div add def
CalculsPointsAfterTransformations
    /XcentreFacette Xabscisse  def
    /YcentreFacette Yordonnee  def
    /ZcentreFacette Zcote def
% test de visibilité
    /PSfacette nXfacette XcentreFacette mul
    nYfacette YcentreFacette mul add
    nZfacette ZcentreFacette mul add
    def
PSfacette 0 le {
theta 1 theta incrementANGLE add {%
    /theta1 exch def
    /OK Hcone H sub TanAngleCone mul def
    /Xpoint OK theta1 cos mul def
    /Ypoint OK theta1 sin mul def
    /Zpoint H def
CalculsPointsAfterTransformations
    CalcCoordinates
    lineto
    } for
H 1 H incrementHAUTEUR add {
    /H1 exch def
    /OK Hcone H1 sub TanAngleCone mul def
    /Xpoint OK theta incrementANGLE add cos mul def
    /Ypoint OK theta incrementANGLE add sin mul def
    /Zpoint H1 def
CalculsPointsAfterTransformations
    CalcCoordinates
    lineto
    } for
theta incrementANGLE add -1 theta {%
    /theta1 exch def
    /OK Hcone H incrementHAUTEUR add sub TanAngleCone mul def
    /Xpoint OK theta1 cos mul def
    /Ypoint OK theta1 sin mul def
    /Zpoint H incrementHAUTEUR add def
CalculsPointsAfterTransformations
    CalcCoordinates
    lineto
    } for
H incrementHAUTEUR add -1 H {
    /H1 exch def
    /OK Hcone H1 sub TanAngleCone mul def
    /Xpoint OK theta cos mul def
    /Ypoint OK theta sin mul def
    /Zpoint H1 def
CalculsPointsAfterTransformations
    CalcCoordinates
    lineto
    } for
} if
} for
} for
% centre de la base inférieure après transformations
    /CxFaceInf CX def
    /CyFaceInf CY def
    /CzFaceInf CZ def
% centre de la base supérieure avant transformations
    /CxFaceSup 0 def
    /CyFaceSup 0 def
    /CzFaceSup Hcone fracHcone mul def
% Sommet du cone
    /Xpoint 0 def
    /Ypoint 0 def
    /Zpoint Hcone def
CalculsPointsAfterTransformations
    /XsommetCone Xabscisse def
    /YsommetCone Yordonnee def
    /ZsommetCone Zcote def
% Normale extérieure à la base inférieure
    /nXBaseInf CxFaceInf XsommetCone sub def
    /nYBaseInf CyFaceInf YsommetCone sub def
    /nZBaseInf CzFaceInf ZsommetCone sub def
% centre de la base supérieure
    /Xpoint CxFaceSup def
    /Ypoint CyFaceSup def
    /Zpoint CzFaceSup def
CalculsPointsAfterTransformations
    /CxBaseSup Xabscisse def
    /CyBaseSup Yordonnee def
    /CzBaseSup Zcote def
% Normale extérieure à la base supérieure
    /nXBaseSup XsommetCone CxFaceSup sub def
    /nYBaseSup YsommetCone CyFaceSup sub def
    /nZBaseSup ZsommetCone CzFaceSup sub def
% Visibilité de la base inférieure
    /PSbaseInfCone nXBaseInf CxFaceInf mul
                nYBaseInf CyFaceInf mul add
                nZBaseInf CzFaceInf mul add def
% Visibilité de la base supérieure
    /PSbaseSupCone nXBaseSup CxFaceSup mul
                nYBaseSup CyFaceSup mul add
                nZBaseSup CzFaceSup mul add def
PSbaseInfCone 0 le {
/TableauxPoints [
0 1 359 {% on décrit le cercle
    /theta exch def [
    /Xpoint Rcone theta cos mul def
    /Ypoint Rcone theta sin mul def
    /Zpoint 0 def
CalculsPointsAfterTransformations
    CalcCoordinates ]
    } for
    ] def
gsave
newpath
 TableauxPoints 0 get aload pop moveto
0 1 359 {
    /compteur exch def
    TableauxPoints compteur get aload pop
    lineto } for
0.7 setgray
closepath
fill
grestore
 } if
PSbaseSupCone 0 le {
/TableauxPoints [
0 1 359 {% on décrit le cercle
    /theta exch def [
    /OK Hcone 1 fracHcone sub mul TanAngleCone mul def
    /Xpoint OK theta cos mul def
    /Ypoint OK theta sin mul def
    /Zpoint Hcone fracHcone mul def
CalculsPointsAfterTransformations
    CalcCoordinates ]
    } for
    ] def
gsave
newpath
 TableauxPoints 0 get aload pop moveto
0 1 359 {
    /compteur exch def
    TableauxPoints compteur get aload pop
    lineto } for
0.7 setgray
closepath
fill
grestore
 } if
end
 }% fin du code ps
\showpointsfalse
\end@ClosedObj}\ignorespaces}%
%
% pyramide
%
\def\pstFaceSAB{\pst@object{pstFaceSAB}}
\def\pstFaceSAB@i{{%
\pst@killglue
\begin@ClosedObj
\addto@pscode{%
  \variables@Sphere
  tx@Sphere3DDict begin
  SommetsPyramide
  PSAB 0 le { %
    reduction reduction scale
    1 setlinejoin
    /Xabscisse XS def
    /Yordonnee YS def
    /Zcote ZS def
    CalcCoordinates
    moveto
    0 0.01 1 { % k
      /K exch def
      /Zcote K ZA mul 1 K sub ZS mul add def
      /Xabscisse K XA mul 1 K sub XS mul add def
      /Yordonnee K YA mul 1 K sub YS mul add def
      CalcCoordinates
      lineto
    } for
    0 0.01 1 { % k
    /K exch def
    /Zcote K ZB mul 1 K sub ZA mul add def
    /Xabscisse K XB mul 1 K sub XA mul add def
    /Yordonnee K YB mul 1 K sub YA mul add def
    CalcCoordinates
    lineto
    } for
    0 0.01 1 { % k
    /K exch def
    /Zcote K ZS mul 1 K sub ZB mul add def
    /Xabscisse K XS mul 1 K sub XB mul add def
    /Yordonnee K YS mul 1 K sub YB mul add def
    CalcCoordinates
    lineto
    } for
} if
end
}% fin du code ps
\end@ClosedObj}\ignorespaces}
%
\def\pstFaceSBC{\pst@object{pstFaceSBC}}
\def\pstFaceSBC@i{{%
\pst@killglue
\begin@ClosedObj
\addto@pscode{%
\variables@Sphere
tx@Sphere3DDict begin
SommetsPyramide
 PSBC 0 le { %
reduction reduction scale
1 setlinejoin
    /Xabscisse XS def
    /Yordonnee YS def
    /Zcote ZS def
    CalcCoordinates
     moveto
0 0.01 1 { % k
    /K exch def
    /Zcote K ZB mul 1 K sub ZS mul add def
    /Xabscisse K XB mul 1 K sub XS mul add def
    /Yordonnee K YB mul 1 K sub YS mul add def
    CalcCoordinates
    lineto
    } for
0 0.01 1 { % k
    /K exch def
    /Zcote K ZC mul 1 K sub ZB mul add def
    /Xabscisse K XC mul 1 K sub XB mul add def
    /Yordonnee K YC mul 1 K sub YB mul add def
    CalcCoordinates
    lineto
    } for
0 0.01 1 { % k
    /K exch def
    /Zcote K ZS mul 1 K sub ZC mul add def
    /Xabscisse K XS mul 1 K sub XC mul add def
    /Yordonnee K YS mul 1 K sub YC mul add def
    CalcCoordinates
    lineto
    } for
} if
end
}% fin du code ps
\end@ClosedObj}\ignorespaces}
%
%
\def\pstFaceSCD{\pst@object{pstFaceSCD}}
\def\pstFaceSCD@i{{%
\pst@killglue
\begin@ClosedObj
\addto@pscode{%
\variables@Sphere
tx@Sphere3DDict begin
SommetsPyramide
PSCD 0 le { %
reduction reduction scale
1 setlinejoin
    /Xabscisse XS def
    /Yordonnee YS def
    /Zcote ZS def
    CalcCoordinates
     moveto
0 0.01 1 { % k
    /K exch def
    /Zcote K ZC mul 1 K sub ZS mul add def
    /Xabscisse K XC mul 1 K sub XS mul add def
    /Yordonnee K YC mul 1 K sub YS mul add def
    CalcCoordinates
    lineto
    } for
0 0.01 1 { % k
    /K exch def
    /Zcote K ZD mul 1 K sub ZC mul add def
    /Xabscisse K XD mul 1 K sub XC mul add def
    /Yordonnee K YD mul 1 K sub YC mul add def
    CalcCoordinates
    lineto
    } for
0 0.01 1 { % k
    /K exch def
    /Zcote K ZS mul 1 K sub ZD mul add def
    /Xabscisse K XS mul 1 K sub XD mul add def
    /Yordonnee K YS mul 1 K sub YD mul add def
    CalcCoordinates
    lineto
    } for
} if
end
}% fin du code ps
\end@ClosedObj}\ignorespaces}
%
\def\pstFaceSDA{\pst@object{pstFaceSDA}}
\def\pstFaceSDA@i{{%
\pst@killglue
\begin@ClosedObj
\addto@pscode{%
  \variables@Sphere
  tx@Sphere3DDict begin
  SommetsPyramide
  PSDA 0 le { %
    reduction reduction scale
    1 setlinejoin
    /Xabscisse XS def
    /Yordonnee YS def
    /Zcote ZS def
    CalcCoordinates
     moveto
0 0.01 1 { % k
    /K exch def
    /Zcote K ZD mul 1 K sub ZS mul add def
    /Xabscisse K XD mul 1 K sub XS mul add def
    /Yordonnee K YD mul 1 K sub YS mul add def
    CalcCoordinates
    lineto
    } for
0 0.01 1 { % k
    /K exch def
    /Zcote K ZA mul 1 K sub ZD mul add def
    /Xabscisse K XA mul 1 K sub XD mul add def
    /Yordonnee K YA mul 1 K sub YD mul add def
    CalcCoordinates
    lineto
    } for
0 0.01 1 { % k
    /K exch def
    /Zcote K ZS mul 1 K sub ZA mul add def
    /Xabscisse K XS mul 1 K sub XA mul add def
    /Yordonnee K YS mul 1 K sub YA mul add def
    CalcCoordinates
    lineto
    } for
} if
end
}% fin du code ps
\end@ClosedObj}\ignorespaces}
%
\def\pstFaceABCD{\pst@object{pstFaceABCD}}
\def\pstFaceABCD@i{{%
\pst@killglue
\begin@ClosedObj
\addto@pscode{%
\variables@Sphere
tx@Sphere3DDict begin
SommetsPyramide
 PSABCD 0 le { %
reduction reduction scale
1 setlinejoin
    /Xabscisse XA def
    /Yordonnee YA def
    /Zcote ZA def
    CalcCoordinates
     moveto
0 0.01 1 { % k
    /K exch def
    /Zcote K ZB mul 1 K sub ZA mul add def
    /Xabscisse K XB mul 1 K sub XA mul add def
    /Yordonnee K YB mul 1 K sub YA mul add def
    CalcCoordinates
    lineto
    } for
0 0.01 1 { % k
    /K exch def
    /Zcote K ZC mul 1 K sub ZB mul add def
    /Xabscisse K XC mul 1 K sub XB mul add def
    /Yordonnee K YC mul 1 K sub YB mul add def
    CalcCoordinates
    lineto
    } for
0 0.01 1 { % k
    /K exch def
    /Zcote K ZD mul 1 K sub ZC mul add def
    /Xabscisse K XD mul 1 K sub XC mul add def
    /Yordonnee K YD mul 1 K sub YC mul add def
    CalcCoordinates
    lineto
    } for
0 0.01 1 { % k
    /K exch def
    /Zcote K ZA mul 1 K sub ZD mul add def
    /Xabscisse K XA mul 1 K sub XD mul add def
    /Yordonnee K YA mul 1 K sub YD mul add def
    CalcCoordinates
    lineto
    } for
} if
end
}% fin du code ps
\end@ClosedObj}\ignorespaces}
%
\def\pstSpherePyramide{\pst@object{pstSpherePyramide}}
\def\pstSpherePyramide@i{%
  \begin@SpecialObj
  \pstFaceSAB[fillcolor=\psk@Sphere@TetraedreColorFaceA]%
  \pstFaceSBC[fillcolor=\psk@Sphere@TetraedreColorFaceB]%
  \pstFaceSCD[fillcolor=\psk@Sphere@TetraedreColorFaceC]%
  \pstFaceSDA[fillcolor=\psk@Sphere@TetraedreColorFaceD]%
  \pstFaceABCD[fillcolor=\psk@Sphere@TetraedreColorFaceE]%
  \end@SpecialObj}
%
%% === Chemin pour les dessins ---------------------------------------------
\define@key[psset]{pst-mirror}{path}{\edef\psk@mirror@Path{#1}} % chemin des dessins
\psset{path=}
%
%%%% ajout le 28/10/2011 --------------------------------------
\def\pstSphereImage{\def\pst@par{}\pst@object{pstSphereImage}}
\def\pstSphereImage@i{\@ifnextchar({\pstSphereImage@ii}{\pstSphereImage@ii(0,0,0)}}
\def\pstSphereImage@ii(#1,#2,#3)#4{{%
  \begin@SpecialObj
    \addto@pscode{%
  \variables@Sphere
         #1 %
         #2 %
         #3 %
\tx@TransformPlan
/fichier (\psk@mirror@Path#4) def
\ifPst@visibility /Condition { gt } def \else /Condition { le } def \fi
      gsave
      /showpage {} def
  tx@Sphere3DImageDict begin      
    fichier run
  end
      grestore
 }%
    \end@SpecialObj}%
  \ignorespaces}
%
\def\psparametricplotSphere{\pst@object{parametricplotSphere}}% 	
\def\parametricplotSphere{\pst@object{parametricplotSphere}}
\def\parametricplotSphere@i#1#2{\@ifnextchar[{\parametricplotSphere@x{#1}{#2}}{\parametricplotSphere@x{#1}{#2}[]}}
\def\parametricplotSphere@x#1#2[#3]{\@ifnextchar[{\parametricplotSphere@xi{#1}{#2}[#3]}{\parametricplotSphere@xi{#1}{#2}[#3][]}}
\def\parametricplotSphere@xi#1#2[#3][#4]#5{%
  \pst@killglue%
  \begingroup%
    \use@par%
    \@nameuse{beginplot@\psplotstyle}%
    \addto@pscode{%
  \variables@Sphere
    \psk@Sphere@Xorigine\space
    \psk@Sphere@Yorigine\space
    \psk@Sphere@Zorigine\space
    \tx@TransformPlan
      #3 %prefix PS code
      \psplot@init
      /t #1 def
      /t1 #2 def
      /dt t1 t sub \psk@plotpoints div def
      /F@pstplot \ifPst@algebraic (#5)
                    \ifx\psk@PlotDerivative\@none\else
                      \psk@PlotDerivative\space { (t) tx@Derive begin Derive end } repeat
                    \fi\space
                    tx@AlgToPs begin AlgToPs end cvx
                 \else { #5 } \fi  def
      \ifPst@VarStep
         /StillZero 0 def /LastNonZeroStep dt def
         /F2@pstplot tx@Derive begin (#5) (t) Derive (t) Derive end
                     \ifx\psk@PlotDerivative\@none\else
                       \psk@PlotDerivative\space { (t) tx@Derive begin Derive end } repeat
                     \fi\space
                    tx@AlgToPs begin AlgToPs end cvx def
         %% computation of the tolerance defined by plotpoints
         /epsilon12 \ifx\psk@VarStepEpsilon\@default
                       tx@Derive begin F2@pstplot end Pyth
                       dt 3 exp abs mul
                    \else\psk@VarStepEpsilon\space 12 mul \fi def
         /ComputeStep {
           dup 1e-4 lt
           { pop StillZero 2 ge { LastNonZeroStep 2 mul } { LastNonZeroStep } ifelse /StillZero StillZero 1 add def }
           { epsilon12 exch div 1 3 div exp /StillZero 0 def }
           ifelse } bind def
      \fi
      /xy {
        \ifPst@algebraic F@pstplot \else #5 \fi
%        \pst@number\psyunit mul exch
%        \pst@number\psxunit mul exch
        /Ypoint exch def /Xpoint exch def
%    tx@mirror3DDict begin
      2dto3d
   /Zpoint exch def
   /Ypoint exch def
   /Xpoint exch def
  CalculsPointsApresTransformations
   3dto2d
%   end
      } def
      }%
    \gdef\psplot@init{}%
    \@pstfalse
    \@nameuse{testqp@\psplotstyle}%
    \if@pst\parametricplotSphere@ii{#4}\else\parametricplotSphere@iii{#4}\fi
  \endgroup%
  \ignorespaces}
%
\def\parametricplotSphere@ii#1{% para is the post code
  \ifPst@VarStep%
    \addto@pscode{%
      mark xy \@nameuse{beginqp@\psplotstyle}
      { F2@pstplot Pyth ComputeStep
        t 2 copy add dup t1 gt {pop t1} if /t exch def F2@pstplot Pyth ComputeStep
        /t 3 -1 roll def 2 copy gt { exch } if pop
        /t t 3 -1 roll add dup t1 gt {pop t1} if def
        xy \@nameuse{doqp@\psplotstyle}
        t t1 eq { exit } if } loop}%
  \else\pst@killglue%
    \addto@pscode{%
      /ps@Exit false def
      xy \@nameuse{beginqp@\psplotstyle}
      \psk@plotpoints 1 sub {
        /t t dt add def
        xy \@nameuse{doqp@\psplotstyle}
        ps@Exit { exit } if
      } repeat
      ps@Exit not {
        /t t1 def
        xy \@nameuse{doqp@\psplotstyle}
      } if
    }%
  \fi%
  \addto@pscode{ #1 }%
  \@nameuse{endqp@\psplotstyle}}
%
\def\parametricplotSphere@iii#1{%
  \ifPst@VarStep%
    \addto@pscode{%
      /n 2 def
      mark
      { xy n 2 roll F2@pstplot Pyth
        ComputeStep t 2 copy add dup t1 gt {pop t1} if
        /t exch def F2@pstplot Pyth ComputeStep
        /t 3 -1 roll def 2 copy gt { exch } if pop
        /t t 3 -1 roll dup /LastNonZeroStep exch def add dup t1 gt {pop t1} if def /n n 2 add def
        t t1 eq { exit } if } loop
      xy n 2 roll}%
  \else\pst@killglue%
    \addto@pscode{
      mark
      /n 2 def
      \psk@plotpoints {
        xy
        n 2 roll
        /n n 2 add def
        /t t dt add def
      } repeat
      /t t1 def
      xy
      n 2 roll}%
  \fi%
  \addto@pscode{ #1 }%
  \@nameuse{endplot@\psplotstyle}}
%
\pst@def{WARP}<%
%% D'après un fichier original de
%%(c) P. Kleiweg 1997
%% adapté par :
%% Manuel Luque
%% Arnaud Schmittbuhl
%% Jean-Paul Vignault
%% les commentaires sont de Jean-Paul Vignault
/warpmove{
   %% on teste le booleen place 2 tokens plus en avant sur la pile
   %% si c'est 'true', alors on en est au 1er appel => on initialise
   %% le chemin
   2 index {
     newpath
   } if
   %% puis on applique warp a notre point
   warp  moveto
   %% on enleve le 'true' pour mettre un 'false' a la place
   pop false
} bind def
%% pour remplacer 'lineto
/warpline {
   warp lineto
} bind def
%% pour remplacer 'curveto'
/warpcurve {
   6 2 roll warp
   6 2 roll warp
   6 2 roll warp
   curveto
}  bind def
%% 'warpit' declenche la transformation du chemin courant
/warpit {
true
{ warpmove } { warpline } { warpcurve } { closepath } pathforall
pop
}  bind def
>%

\pst@def{PathForAll}<%
/warp {
4 dict begin
    /Ypoint exch def %
    /Xpoint exch def %
%% coordonnées dans le repère absolu
   2dto3d
   /Zpoint exch def
   /Ypoint exch def
   /Xpoint exch def
 CalculsPointsApresTransformations
%% les coordonnées sur l'écran dans la représentation en perspective
   3dto2d
end
} bind def
\tx@WARP
%% maintenant on y va
% 0 0 moveto
 warpit                  %% on applique le pathforall
 >%

\pst@def{TransformPlan}< % le calcul des coefficients
%% pour passer des coordonnées du plan aux coordonnées
%% (x,y,z) du repère absolu
%% les coordonnées sphériques du vecteur normal
%% au plan
%% l'origine du plan
/zO' exch def
/yO' exch def
/xO' exch def
%% les coefficients de la matrice de transformation
/C11 {K_theta sin neg} def
/C12 {K_theta cos K_phi sin mul neg} bind def
/C21 {K_theta cos} bind def
/C22 {K_phi sin K_theta sin mul neg } bind def
/C31 {K_phi cos} bind def
/2dto3d{
%% coordonnées dans le repère absolu
3 dict begin
  C11 Xpoint mul C12 Ypoint mul add xO' add % x
  C21 Xpoint mul C22 Ypoint mul add yO' add % y
  C31 Ypoint mul zO' add
end }
  def
  >%

%
\catcode`\@=\PstAtCode\relax
%% END: pst-mirror.tex
\endinput
